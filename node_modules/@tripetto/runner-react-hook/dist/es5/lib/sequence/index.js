"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addItemToSequence = exports.findActiveItem = void 0;
var runner_1 = require("@tripetto/runner");
var promise_1 = require("../promise");
var enumerator = 0;
function findActiveItem(sequence) {
    return (0, runner_1.findLast)(sequence, function (item) {
        return (
            item.isPreActive ||
            item.isBeforeActive ||
            item.isActive ||
            item.isAfterActive ||
            item.isPostActive
        );
    });
}
exports.findActiveItem = findActiveItem;
function findPreviousItem(sequence, index, validate) {
    var currentItem = (0, runner_1.arrayItem)(sequence, index);
    if (currentItem && currentItem.isHealthy) {
        var previous = currentItem.index;
        while (--previous >= 0) {
            var item = sequence[previous];
            if (item.isHistory) {
                break;
            }
            if (!validate || validate(item)) {
                return item;
            }
        }
    }
    return undefined;
}
function activateItem(sequence, index, isPreview, doAction) {
    if (
        sequence.length === 0 ||
        index < 0 ||
        index >= sequence.length ||
        !sequence[index].isHealthy ||
        (!isPreview &&
            sequence[index].isHistory &&
            sequence[index].type !== "prologue")
    ) {
        return false;
    }
    var activeItem = findActiveItem(sequence);
    var currentIndex = (activeItem || { index: -1 }).index;
    if (currentIndex !== index) {
        var from =
            currentIndex === -1 ? 0 : runner_1.Num.min(index, currentIndex);
        var to =
            currentIndex === -1
                ? sequence.length - 1
                : runner_1.Num.max(index, currentIndex);
        var activate = void 0;
        for (var i = from; i <= to; i++) {
            var item = sequence[i];
            if (!item.isHistory || item.type === "prologue") {
                item.changeState(
                    i === index
                        ? "active"
                        : i < index
                        ? item.type !== "node"
                            ? "history"
                            : "past"
                        : "upcoming"
                );
                if (!activate && i === index) {
                    activate = item;
                }
                if (
                    !isPreview &&
                    i > index &&
                    item.type !== "node" &&
                    item.type !== "epilogue"
                ) {
                    sequence.splice(i, sequence.length - i);
                    break;
                }
            }
        }
        if (doAction) {
            if (activeItem && !activeItem.isActive) {
                doAction("unstage", activeItem.node);
            }
            if (activate) {
                doAction("stage", activate.node);
            }
        }
    }
    return true;
}
function deactivateItem(sequence, index, doAction) {
    if (
        index < 0 ||
        index >= sequence.length ||
        !sequence[index].isHealthy ||
        !sequence[index].isActive
    ) {
        return false;
    }
    if (doAction) {
        var current = sequence[index];
        if (
            current === null || current === void 0 ? void 0 : current.isActive
        ) {
            doAction("unstage", current.node);
        }
    }
    while (index < sequence.length) {
        var item = sequence[index];
        if (!item.isHistory && !item.isAfterActive && !item.isPostActive) {
            item.changeState(item.type !== "node" ? "history" : "past");
        }
        index++;
    }
    return true;
}
function addItemToSequence(refs, state, type, data, doAction) {
    var node = (type === "node" && data) || undefined;
    var prologue = (type === "prologue" && data) || undefined;
    var epilogue = (type === "epilogue" && data) || undefined;
    var cancel =
        ((type === "finishing" || type === "pausing") && data) || undefined;
    var n = enumerator++;
    var item = {
        id:
            "_" +
            runner_1.SHA2.CSHA2_256(
                node
                    ? node.key +
                          (refs.viewRef.current === "live" &&
                              refs.storylineRef.current &&
                              refs.storylineRef.current.instance.id)
                    : "".concat(type, "-").concat(refs.sequence.length)
            ),
        key:
            (node && node.key) ||
            "_" +
                runner_1.SHA2.CSHA2_256(
                    "".concat(type, "-").concat(refs.sequence.length)
                ),
        type: type,
        node: node,
        prologue: prologue,
        epilogue: epilogue,
        cancel: cancel,
        index: refs.sequence.length,
        state: state,
        changeState: function (newState) {
            (0, runner_1.set)(
                item,
                "state",
                item.type === "prologue" &&
                    refs.viewRef.current !== "preview" &&
                    newState === "active"
                    ? "history"
                    : newState
            );
            if (
                item.state === "history" &&
                refs.viewRef.current === "live" &&
                node
            ) {
                (0, runner_1.set)(
                    item,
                    "key",
                    "_" + runner_1.SHA2.CSHA2_256("history-".concat(n))
                );
            }
            if (node && item.state === "upcoming") {
                (0, runner_1.set)(item, "timeStamp", undefined);
            }
        },
        get isHealthy() {
            var currentItem = (0, runner_1.arrayItem)(
                refs.sequence,
                item.index
            );
            return (currentItem && currentItem.id === item.id) || false;
        },
        get isHistory() {
            return item.state === "history";
        },
        get isPast() {
            return item.state === "past";
        },
        get isPreActive() {
            return item.state === "pre-active";
        },
        get isBeforeActive() {
            return item.state === "before-active";
        },
        get isActive() {
            return item.state === "active";
        },
        get isAfterActive() {
            return item.state === "after-active";
        },
        get isPostActive() {
            return item.state === "post-active";
        },
        get isUpcoming() {
            return item.state === "upcoming";
        },
        get isFirst() {
            return item.index === 0;
        },
        get isLast() {
            return item.index === refs.sequence.length - 1;
        },
        get isPaused() {
            if (item.index + 1 < refs.sequence.length) {
                var nextItem = refs.sequence[item.index + 1];
                if (
                    nextItem.type === "pausing" ||
                    nextItem.type === "paused" ||
                    (nextItem.type === "error" && nextItem.error === "paused")
                ) {
                    return true;
                }
            }
            return false;
        },
        get allowActivate() {
            return item.isHealthy &&
                !item.isHistory &&
                node &&
                refs.storylineRef.current &&
                !refs.storylineRef.current.isFinishing &&
                !refs.storylineRef.current.isPausing
                ? true
                : false;
        },
        activate: function (useTransition) {
            if (useTransition === void 0) {
                useTransition = false;
            }
            if (
                node &&
                refs.storylineRef.current &&
                refs.storylineRef.current.isPausing
            ) {
                var activeItem = findActiveItem(refs.sequence);
                if (activeItem && activeItem.cancel) {
                    activeItem.cancel();
                }
            }
            if (
                node &&
                (!refs.storylineRef.current ||
                    refs.storylineRef.current.isFinishing ||
                    refs.storylineRef.current.isPausing)
            ) {
                return false;
            }
            (0, promise_1.promise)(refs.promiseRef).reject();
            if (
                activateItem(
                    refs.sequence,
                    item.index,
                    refs.viewRef.current === "preview",
                    doAction
                )
            ) {
                var makeActive_1 = function () {
                    item.changeState("active");
                    refs.update();
                    if (refs.rules.onInteraction) {
                        refs.rules.onInteraction();
                    }
                };
                var beforeActive_1 = function () {
                    if (
                        useTransition &&
                        refs.viewRef.current !== "preview" &&
                        refs.rules.beforeActiveDuration
                    ) {
                        var beforeActiveDuration =
                            refs.rules.beforeActiveDuration(item) || 0;
                        if (beforeActiveDuration) {
                            refs.promiseRef.current = {
                                resolve: function () {
                                    return (
                                        item.state === "before-active" &&
                                        makeActive_1()
                                    );
                                },
                                reject: function () {
                                    return item.changeState("upcoming");
                                },
                                handle: setTimeout(function () {
                                    return item.continue();
                                }, beforeActiveDuration),
                            };
                            item.changeState("before-active");
                            refs.update();
                        } else {
                            makeActive_1();
                        }
                    } else {
                        makeActive_1();
                    }
                };
                if (item.type === "node") {
                    refs.reset();
                }
                if (
                    useTransition &&
                    refs.viewRef.current !== "preview" &&
                    refs.rules.preActiveDuration
                ) {
                    var preActiveDuration =
                        refs.rules.preActiveDuration(item) || 0;
                    if (preActiveDuration > 0) {
                        refs.promiseRef.current = {
                            resolve: function () {
                                return (
                                    item.state === "pre-active" &&
                                    beforeActive_1()
                                );
                            },
                            reject: function () {
                                return item.changeState("upcoming");
                            },
                            handle: setTimeout(function () {
                                return item.continue();
                            }, preActiveDuration),
                        };
                        item.changeState("pre-active");
                        refs.update();
                    } else {
                        beforeActive_1();
                    }
                } else {
                    beforeActive_1();
                }
                if (refs.rules.onInteraction) {
                    refs.rules.onInteraction();
                }
                return true;
            }
            return false;
        },
        deactivate: function () {
            if (
                refs.viewRef.current === "preview" &&
                deactivateItem(refs.sequence, item.index, doAction)
            ) {
                refs.update();
                return true;
            }
            return false;
        },
        get allowNext() {
            return (
                (!item.isHistory &&
                    refs.storylineRef.current &&
                    !refs.storylineRef.current.isEvaluating &&
                    !refs.storylineRef.current.isFinishing &&
                    !refs.storylineRef.current.isPausing &&
                    (!item.node || item.node.isPassed) &&
                    item.isHealthy &&
                    (refs.viewRef.current === "preview" ||
                        item.index + 1 < refs.sequence.length ||
                        refs.storylineRef.current.isFinishable ||
                        false)) ||
                false
            );
        },
        next: function () {
            if (!item.isHealthy) {
                return false;
            }
            if (refs.viewRef.current !== "preview") {
                var lock = function () {
                    if (item.node && item.node.block) {
                        item.node.block.lock();
                    }
                };
                var unlock_1 = function () {
                    if (item.node && item.node.block) {
                        item.node.block.unlock();
                    }
                    return true;
                };
                if (refs.rules.afterActiveDuration && item.isActive) {
                    var duration = refs.rules.afterActiveDuration(item) || 0;
                    if (duration > 0) {
                        refs.promiseRef.current = {
                            resolve: function () {
                                return (
                                    item.state === "after-active" && item.next()
                                );
                            },
                            reject: function () {
                                return (
                                    unlock_1() &&
                                    item.changeState(
                                        item.type !== "node"
                                            ? "history"
                                            : "past"
                                    )
                                );
                            },
                            handle: setTimeout(function () {
                                return item.continue();
                            }, duration),
                        };
                        lock();
                        item.changeState("after-active");
                        refs.update();
                        return true;
                    }
                }
                if (
                    refs.rules.postActiveDuration &&
                    (item.isActive || item.isAfterActive)
                ) {
                    var duration = refs.rules.postActiveDuration(item) || 0;
                    if (duration > 0) {
                        refs.promiseRef.current = {
                            resolve: function () {
                                return (
                                    item.state === "post-active" && item.next()
                                );
                            },
                            reject: function () {
                                return (
                                    unlock_1() &&
                                    item.changeState(
                                        item.type !== "node"
                                            ? "history"
                                            : "past"
                                    )
                                );
                            },
                            handle: setTimeout(function () {
                                return item.continue();
                            }, duration),
                        };
                        lock();
                        item.changeState("post-active");
                        refs.update();
                        return true;
                    }
                }
                unlock_1();
            } else if (item.deactivate()) {
                return true;
            }
            if ((item.node && !item.node.isPassed) || item.isHistory) {
                return false;
            }
            if (item.index + 1 < refs.sequence.length) {
                return refs.sequence[item.index + 1].activate(true);
            }
            if (item.type !== "node") {
                item.changeState("history");
                return false;
            }
            item.changeState("past");
            return (
                (refs.storylineRef.current &&
                    refs.storylineRef.current.stepForward()) ||
                false
            );
        },
        get allowUndo() {
            return (
                (refs.storylineRef.current &&
                    !refs.storylineRef.current.isFinishing &&
                    !refs.storylineRef.current.isEvaluating &&
                    ((item.type === "node" &&
                        !refs.storylineRef.current.isPausing) ||
                        (item.type === "pausing" && item.pausingRecipe)) &&
                    findPreviousItem(
                        refs.sequence,
                        item.index,
                        refs.rules.canInteract
                    ) &&
                    true) ||
                false
            );
        },
        undo: function () {
            if (
                refs.storylineRef.current &&
                !refs.storylineRef.current.isEvaluating
            ) {
                if (item.type === "pausing" && item.pausingRecipe) {
                    item.pausingRecipe.cancel();
                    return true;
                }
                var previousItem = findPreviousItem(
                    refs.sequence,
                    item.index,
                    refs.rules.canInteract
                );
                return (previousItem && previousItem.activate(false)) || false;
            }
            return false;
        },
        get allowSkip() {
            return (
                (refs.storylineRef.current &&
                    !refs.storylineRef.current.isFinishing &&
                    !refs.storylineRef.current.isPausing &&
                    !refs.storylineRef.current.isEvaluating &&
                    item.type === "node" &&
                    refs.rules.canSkip &&
                    refs.rules.canSkip(item)) ||
                false
            );
        },
        skip: function () {
            if (item.isHealthy && item.allowSkip) {
                if (item.node && item.node.block) {
                    item.node.block.clear();
                }
                return item.next();
            }
            return false;
        },
        wait: function () {
            return (0, promise_1.promise)(refs.promiseRef).cancel();
        },
        continue: function () {
            return (0, promise_1.promise)(refs.promiseRef).resolve();
        },
        get repeat() {
            if (
                item.type === "epilogue" &&
                item.epilogue &&
                (refs.viewRef.current === "test" ||
                    (refs.viewRef.current === "live" &&
                        item.epilogue.repeatable))
            ) {
                for (
                    var index = item.index + 1;
                    index < refs.sequence.length;
                    index++
                ) {
                    if (refs.sequence[index].type !== "epilogue") {
                        return undefined;
                    }
                }
                return function () {
                    if (refs.viewRef.current === "test") {
                        refs.restart();
                    } else if (
                        refs.runnerRef.current &&
                        !refs.runnerRef.current.isRunning
                    ) {
                        refs.runnerRef.current.start();
                    }
                };
            }
            return undefined;
        },
        get kickOff() {
            if (
                refs.viewRef.current !== "preview" &&
                item.type === "prologue" &&
                refs.runnerRef.current &&
                !refs.runnerRef.current.isRunning &&
                !refs.runnerRef.current.isFinishing &&
                !refs.runnerRef.current.isPausing &&
                item.isLast
            ) {
                return function () {
                    return (
                        refs.runnerRef.current && refs.runnerRef.current.start()
                    );
                };
            }
            return undefined;
        },
        changeToError: function (errorType, retry, cancelPausing) {
            (0, runner_1.set)(item, "type", "error");
            (0, runner_1.set)(item, "error", errorType);
            (0, runner_1.set)(item, "retry", retry);
            (0, runner_1.set)(item, "cancel", cancelPausing);
            (0, runner_1.set)(item, "timeStamp", runner_1.DateTime.now);
            if (!item.activate(true)) {
                refs.update();
            }
        },
        changeToEpilogue: function (epilogueRef) {
            (0, runner_1.set)(item, "type", "epilogue");
            (0, runner_1.set)(item, "epilogue", epilogueRef);
            (0, runner_1.set)(item, "timeStamp", runner_1.DateTime.now);
            if (!item.activate(true)) {
                refs.update();
            }
        },
        changeToPausing: function (cancelPausing) {
            (0, runner_1.set)(item, "type", "pausing");
            (0, runner_1.set)(item, "retry", undefined);
            (0, runner_1.set)(item, "cancel", cancelPausing);
            (0, runner_1.set)(item, "timeStamp", undefined);
            if (!item.activate(true)) {
                refs.update();
            }
        },
        changeToPaused: function () {
            (0, runner_1.set)(item, "type", "paused");
            (0, runner_1.set)(item, "retry", undefined);
            (0, runner_1.set)(item, "cancel", undefined);
            (0, runner_1.set)(item, "timeStamp", runner_1.DateTime.now);
            if (!item.activate(true)) {
                refs.update();
            }
        },
        pausingRecipe: undefined,
        setPausingRecipe: function (recipeDescriptor) {
            switch (recipeDescriptor.recipe) {
                case "email":
                    if (item.type === "pausing") {
                        var reset_1 = function () {
                            (0, runner_1.set)(item, "pausingRecipe", undefined);
                            (0, runner_1.set)(item, "cancel", undefined);
                            refs.update();
                        };
                        (0, runner_1.set)(item, "pausingRecipe", {
                            recipe: recipeDescriptor.recipe,
                            complete: function (emailAddress) {
                                reset_1();
                                recipeDescriptor.complete(emailAddress);
                            },
                            cancel: function () {
                                reset_1();
                                recipeDescriptor.cancel();
                            },
                        });
                        refs.update();
                    }
                    break;
            }
        },
    };
    refs.sequence.push(item);
    if (doAction && state === "active") {
        doAction("stage", item.node);
    }
    return item;
}
exports.addItemToSequence = addItemToSequence;
