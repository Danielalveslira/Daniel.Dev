"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NumberFabric = void 0;
var jsx_runtime_1 = require("react/jsx-runtime");
var react_1 = require("react");
var runner_1 = require("@tripetto/runner");
var input_1 = require("../input");
var helpers_1 = require("../helpers");
var const_1 = require("../const");
var NumberFabric = function (props) {
    var _a;
    var valueRef = props.value;
    var debounceRef = (0, react_1.useRef)({
        duration: 0,
        handle: 0,
    });
    var _b = (0, react_1.useState)("text"),
        type = _b[0],
        setType = _b[1];
    var _c = (0, react_1.useState)(false),
        focus = _c[0],
        setFocus = _c[1];
    var _d = (0, react_1.useState)(
            typeof valueRef === "object"
                ? (0, runner_1.castToString)(valueRef.pristine)
                : typeof valueRef === "number"
                ? valueRef.toString()
                : ""
        ),
        focusValue = _d[0],
        setFocusValue = _d[1];
    var _e =
            typeof valueRef === "object"
                ? [
                      focus
                          ? focusValue
                          : valueRef.hasValue
                          ? valueRef.slot.formatString(
                                valueRef.slot.digits
                                    ? runner_1.Str.padLeft(valueRef.value, "0", valueRef.slot.digits, false, true)
                                    : (((_a = props.l10n) === null || _a === void 0 ? void 0 : _a.locale) || runner_1.L10n.Locales).number(
                                          valueRef.value,
                                          valueRef.slot.precision,
                                          (valueRef.slot.separator && true) || false
                                      ),
                                valueRef.value !== 1
                            )
                          : "",
                      function (val) {
                          (0, runner_1.cancelUITimeout)(debounceRef.current.handle);
                          setFocusValue(val);
                          var nTimeout = runner_1.Num.range(debounceRef.current.duration * 2, const_1.DEBOUNCE_MIN, const_1.DEBOUNCE_MAX);
                          debounceRef.current.handle = (0, runner_1.scheduleUITimeout)(function () {
                              var start = runner_1.DateTime.precise;
                              debounceRef.current.handle = 0;
                              debounceRef.current.update = function () {
                                  debounceRef.current.duration = runner_1.DateTime.elapsed(start, true);
                                  debounceRef.current.update = undefined;
                              };
                              valueRef.pristine = val !== "" ? valueRef.slot.toValue(val) : undefined;
                              valueRef.pristine = val || undefined;
                          }, nTimeout);
                      },
                  ]
                : [focusValue, setFocusValue],
        value = _e[0],
        setValue = _e[1];
    var _f = (0, react_1.useState)(value ? true : false),
        errorVisible = _f[0],
        makeErrorVisible = _f[1];
    var focusRef = (0, react_1.useRef)(0);
    var currentValue = focus && typeof valueRef === "object" ? (0, runner_1.castToFloat)(focusValue) : 0;
    var error =
        props.error ||
        (focus &&
            typeof valueRef === "object" &&
            (((0, runner_1.isNumberFinite)(valueRef.slot.minimum) && currentValue < valueRef.slot.minimum) ||
                ((0, runner_1.isNumberFinite)(valueRef.slot.maximum) && currentValue > valueRef.slot.maximum))) ||
        false;
    (0, react_1.useEffect)(function () {
        return function () {
            (0, runner_1.cancelUITimeout)(debounceRef.current.handle);
        };
    }, []);
    if (debounceRef.current.update) {
        debounceRef.current.update();
    }
    return (0, jsx_runtime_1.jsx)(input_1.InputElement, {
        id: props.id,
        ref: props.onAutoFocus,
        type: type,
        tabIndex: props.tabIndex,
        placeholder: props.placeholder,
        required: props.required || false,
        disabled: props.disabled || false,
        readOnly: props.readOnly || (typeof valueRef === "object" && (valueRef.isFrozen || valueRef.isLocked)) || false,
        maxLength: props.maxLength,
        value: value,
        autoComplete: "off",
        step:
            type === "number"
                ? (typeof valueRef === "object" &&
                      valueRef.slot.precision &&
                      "0.".concat(runner_1.Str.fill("0", valueRef.slot.precision - 1), "1")) ||
                  "1"
                : undefined,
        inputMode: props.precision || (typeof valueRef === "object" && valueRef.slot.precision) ? "decimal" : "numeric",
        "aria-describedby": props.ariaDescribedBy,
        onChange: function (e) {
            setValue(e.target.value);
            makeErrorVisible(true);
            if (props.onChange) {
                (0, helpers_1.setReturnValue)(setValue, props.onChange(e.target.value));
            }
        },
        onFocus: function (e) {
            if (focusRef.current) {
                cancelAnimationFrame(focusRef.current);
                focusRef.current = 0;
            }
            if (type === "text") {
                var el_1 = e.target;
                requestAnimationFrame(function () {
                    el_1.focus();
                });
                setType("number");
            }
            (0, helpers_1.handleFocus)(setFocus, setValue, props.onFocus)(e);
        },
        onBlur: function (e) {
            focusRef.current = requestAnimationFrame(function () {
                focusRef.current = 0;
                if (type === "number") {
                    setType("text");
                }
                if (typeof valueRef === "object" && valueRef.hasValue) {
                    setFocusValue((0, runner_1.castToString)(valueRef.pristine));
                }
                (0, helpers_1.handleBlur)(setFocus, setValue, props.onBlur)(e);
            });
        },
        onKeyDown: function (e) {
            if (e.key === "Enter" && props.onSubmit) {
                e.preventDefault();
                props.onSubmit();
            } else if (e.key === "Escape") {
                e.currentTarget.blur();
            } else if (e.key === "Tab") {
                if (e.shiftKey) {
                    if (props.onCancel) {
                        e.preventDefault();
                        props.onCancel();
                    }
                } else if (props.onSubmit) {
                    e.preventDefault();
                    props.onSubmit();
                }
            }
        },
        $backgroundColor: props.styles.backgroundColor || "transparent",
        $borderColor: props.styles.borderColor || "transparent",
        $borderSize: props.styles.borderSize || 1,
        $roundness: props.styles.roundness,
        $textColor: props.styles.textColor,
        $errorColor: props.styles.errorColor,
        $errorVisible: errorVisible,
        $error: error,
        $scale: props.styles.scale || 1,
    });
};
exports.NumberFabric = NumberFabric;
