"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PictureChoiceFabric = void 0;
var tslib_1 = require("tslib");
var jsx_runtime_1 = require("react/jsx-runtime");
var styled_components_1 = require("styled-components");
var react_1 = require("react");
var runner_1 = require("@tripetto/runner");
var helpers_1 = require("../helpers");
var button_1 = require("../button");
var color_1 = require("../../color");
var placeholder_1 = require("../../icons/placeholder");
var const_1 = require("../const");
var PictureChoiceElement = styled_components_1.styled.div(
    templateObject_1 ||
        (templateObject_1 = tslib_1.__makeTemplateObject(
            [
                "\n    display: flex;\n    width: 100%;\n    flex-direction: row;\n    flex-wrap: wrap;\n    align-items: stretch;\n\n    > * {\n        margin-top: 8px;\n        margin-right: 8px;\n        display: flex;\n        flex-direction: column;\n        align-items: center;\n    }\n",
            ],
            [
                "\n    display: flex;\n    width: 100%;\n    flex-direction: row;\n    flex-wrap: wrap;\n    align-items: stretch;\n\n    > * {\n        margin-top: 8px;\n        margin-right: 8px;\n        display: flex;\n        flex-direction: column;\n        align-items: center;\n    }\n",
            ]
        ))
);
var assertValue = function (valueRef, options, reference) {
    var selected = (0, runner_1.findFirst)(options, function (option) {
        return option.id === reference;
    });
    if (valueRef.reference !== (selected === null || selected === void 0 ? void 0 : selected.id)) {
        valueRef.set(
            selected && (selected.value || selected.name),
            selected === null || selected === void 0 ? void 0 : selected.id,
            selected === null || selected === void 0 ? void 0 : selected.name
        );
    }
    return (selected && selected.id) || "";
};
var PictureChoiceFabric = function (props) {
    var valueRef = props.value;
    var debounceRef = (0, react_1.useRef)(0);
    var optionsRef = (0, react_1.useRef)({});
    var _a = (0, react_1.useState)((typeof valueRef !== "object" && valueRef) || ""),
        proxy = _a[0],
        setProxy = _a[1];
    var _b =
            typeof valueRef === "object"
                ? [
                      debounceRef.current !== 0 ? proxy : assertValue(valueRef, props.options, valueRef.reference),
                      function (reference) {
                          (0, runner_1.cancelUITimeout)(debounceRef.current);
                          setProxy(reference);
                          debounceRef.current = (0, runner_1.scheduleUITimeout)(function () {
                              debounceRef.current = 0;
                              assertValue(valueRef, props.options, reference);
                              if (props.autoSubmit && reference) {
                                  (0, helpers_1.handleAutoSubmit)(autoSubmit);
                              }
                          }, const_1.DEBOUNCE_NORMAL);
                      },
                  ]
                : [proxy, setProxy],
        value = _b[0],
        setValue = _b[1];
    var _c = (0, react_1.useState)({}),
        update = _c[1];
    var autoSubmit = (0, react_1.useRef)({
        id: 0,
        cb: props.onSubmit,
    });
    var toggle = function (option) {
        if (option.url) {
            return;
        }
        var isSelected = option.slot ? (0, runner_1.castToBoolean)(optionsRef.current[option.id], option.slot.value) : value === option.id;
        if (option.slot) {
            (0, runner_1.cancelUITimeout)(debounceRef.current);
            optionsRef.current[option.id] = !isSelected;
            update({});
            debounceRef.current = (0, runner_1.scheduleUITimeout)(function () {
                debounceRef.current = 0;
                (0, runner_1.each)(
                    optionsRef.current,
                    function (val, id) {
                        var changedOption = (0, runner_1.findFirst)(props.options, function (ref) {
                            return ref.id === id;
                        });
                        delete optionsRef.current[id];
                        if (changedOption && changedOption.slot) {
                            changedOption.slot.value = val;
                        }
                    },
                    {
                        keys: true,
                    }
                );
            }, const_1.DEBOUNCE_NORMAL);
        } else {
            var val = isSelected && !props.required ? "" : option.id;
            if (autoSubmit.current.id) {
                clearTimeout(autoSubmit.current.id);
                autoSubmit.current.id = 0;
            }
            setValue(val);
            if (props.onChange) {
                props.onChange(val);
            }
            if (typeof valueRef !== "object" && props.autoSubmit && val) {
                (0, helpers_1.handleAutoSubmit)(autoSubmit);
            }
        }
        if (option.onChange) {
            option.onChange(!option.slot && props.required ? true : !isSelected);
        }
    };
    (0, react_1.useEffect)(function () {
        return function () {
            (0, runner_1.cancelUITimeout)(debounceRef.current);
        };
    }, []);
    autoSubmit.current.cb = props.onSubmit;
    return (0, jsx_runtime_1.jsx)(PictureChoiceElement, {
        children: props.options.map(function (option, index) {
            var isSelected = option.slot
                ? (0, runner_1.castToBoolean)(optionsRef.current[option.id], option.slot.value)
                : value === option.id;
            if (option.slot) {
                option.slot.confirm();
            }
            return (
                (props.view === "preview" || option.image || option.emoji || (option.nameVisible && option.name) || option.description) &&
                (0, jsx_runtime_1.jsx)(
                    button_1.ButtonFabric,
                    {
                        styles: {
                            baseColor: option.color || props.styles.color,
                            mode: isSelected ? "fill" : "outline",
                            hover: "outline",
                            outlineSize: props.styles.outlineSize,
                            roundness: props.styles.roundness,
                            scale: props.styles.scale,
                        },
                        hyperlink:
                            (option.url && {
                                url: option.url,
                                target: option.target || "blank",
                            }) ||
                            undefined,
                        image:
                            option.image ||
                            (!option.emoji &&
                                "data:image/svg+xml;base64,".concat(
                                    (0, placeholder_1.placeholderImage)(
                                        (0, color_1.color)(props.styles.color, function (o) {
                                            return o.makeBlackOrWhite(isSelected).manipulate(function (m) {
                                                return m.alpha(0.2);
                                            });
                                        })
                                    )
                                )) ||
                            undefined,
                        emoji: option.emoji,
                        label: (option.nameVisible && (option.label || option.name)) || undefined,
                        description: option.description,
                        size: props.size,
                        tabIndex: option.tabIndex || props.tabIndex,
                        ariaDescribedBy: props.ariaDescribedBy,
                        disabled:
                            option.disabled ||
                            props.disabled ||
                            props.readOnly ||
                            (typeof valueRef === "object" && (valueRef.isFrozen || valueRef.isLocked)) ||
                            (option.slot && (option.slot.isFrozen || option.slot.isLocked)) ||
                            false,
                        onAutoFocus: ((option.slot || !value ? index === 0 : isSelected) && props.onAutoFocus) || undefined,
                        onFocus: props.onFocus,
                        onBlur: props.onBlur,
                        onKeyDown: function (e) {
                            if (e.shiftKey && e.key === "Enter" && props.onSubmit) {
                                e.preventDefault();
                                props.onSubmit();
                            } else if (e.key === "Escape") {
                                e.currentTarget.blur();
                            } else if (e.key === "Tab") {
                                if (e.shiftKey) {
                                    if (props.onCancel && index === 0) {
                                        e.preventDefault();
                                        props.onCancel();
                                    }
                                } else if (props.onSubmit && index + 1 === props.options.length) {
                                    e.preventDefault();
                                    props.onSubmit();
                                }
                            } else {
                                var keyCode = (e.key.length === 1 && e.key.charCodeAt(0)) || 0;
                                var offset =
                                    (keyCode <= 57 ? keyCode - 48 : 0) ||
                                    (keyCode <= 90 ? keyCode - 64 : 0) ||
                                    (keyCode <= 122 ? keyCode - 96 : 0);
                                if (offset > 0 && offset <= 26) {
                                    var toggleOption = (0, runner_1.arrayItem)(props.options, offset - 1);
                                    if (toggleOption) {
                                        toggle(toggleOption);
                                    }
                                }
                            }
                        },
                        onClick: function () {
                            return toggle(option);
                        },
                    },
                    option.id || index
                )
            );
        }),
    });
};
exports.PictureChoiceFabric = PictureChoiceFabric;
var templateObject_1;
