import { jsx } from "react/jsx-runtime";
import { styled } from "styled-components";
import { useRef, useState, useEffect } from "react";
import { cancelUITimeout, scheduleUITimeout, castToBoolean, arrayItem, findFirst, each } from "@tripetto/runner";
import { handleAutoSubmit } from "../helpers.mjs";
import { ButtonFabric } from "../button/index.mjs";
import { hyperlinkIcon } from "../../icons/hyperlink.mjs";
import { DEBOUNCE_NORMAL } from "../const.mjs";

const MultipleChoiceElement = styled.div`
    display: table;
    width: ${(props) => (props.$alignment === "equal" && "auto") || "100%"};

    > * {
        display: ${(props) =>
            ((props.$alignment === "vertical" || props.$alignment === "equal" || props.$alignment === "full") && "block") ||
            "inline-block"};
        width: ${(props) =>
            ((props.$alignment === "equal" || props.$alignment === "full") && "100%") ||
            (props.$alignment === "columns" && "calc(50% - 4px)") ||
            undefined};
        margin-top: 8px;
        margin-right: ${(props) =>
            ((props.$alignment === "columns" || props.$alignment === "horizontal") && `${props.$margin || 8}px`) || undefined};

        &:nth-child(even) {
            margin-right: ${(props) => (props.$alignment === "columns" && "0px") || undefined};
        }

        &:last-child {
            margin-right: ${(props) => (props.$alignment === "horizontal" && "0px") || undefined};
        }

        > span {
            display: ${(props) => (props.$alignment === "full" && "flex") || undefined};
            justify-content: ${(props) => (props.$alignment === "full" && "center") || undefined};
            text-align: ${(props) => (props.$alignment === "full" && "center") || undefined};
            overflow: hidden;
        }
    }
`;
const assertValue = (valueRef, buttons, reference) => {
    const selected = findFirst(buttons, (button) => button.id === reference);
    if (valueRef.reference !== (selected === null || selected === void 0 ? void 0 : selected.id)) {
        valueRef.set(
            selected && (selected.value || selected.name),
            selected === null || selected === void 0 ? void 0 : selected.id,
            selected === null || selected === void 0 ? void 0 : selected.name
        );
    }
    return (selected && selected.id) || "";
};
const MultipleChoiceFabric = (props) => {
    const valueRef = props.value;
    const debounceRef = useRef(0);
    const buttonsRef = useRef({});
    const [proxy, setProxy] = useState((typeof valueRef !== "object" && valueRef) || "");
    const [value, setValue] =
        typeof valueRef === "object"
            ? [
                  debounceRef.current !== 0 ? proxy : assertValue(valueRef, props.buttons, valueRef.reference),
                  (reference) => {
                      cancelUITimeout(debounceRef.current);
                      setProxy(reference);
                      debounceRef.current = scheduleUITimeout(() => {
                          debounceRef.current = 0;
                          assertValue(valueRef, props.buttons, reference);
                          if (props.autoSubmit && reference) {
                              handleAutoSubmit(autoSubmit);
                          }
                      }, DEBOUNCE_NORMAL);
                  },
              ]
            : [proxy, setProxy];
    const [, update] = useState({});
    const autoSubmit = useRef({
        id: 0,
        cb: props.onSubmit,
    });
    const toggle = (button) => {
        if (button.url) {
            return;
        }
        const isSelected = button.slot ? castToBoolean(buttonsRef.current[button.id], button.slot.value) : value === button.id;
        if (button.slot) {
            cancelUITimeout(debounceRef.current);
            buttonsRef.current[button.id] = !isSelected;
            update({});
            debounceRef.current = scheduleUITimeout(() => {
                debounceRef.current = 0;
                each(
                    buttonsRef.current,
                    (val, id) => {
                        const changedButton = findFirst(props.buttons, (ref) => ref.id === id);
                        delete buttonsRef.current[id];
                        if (changedButton && changedButton.slot) {
                            changedButton.slot.value = val;
                        }
                    },
                    {
                        keys: true,
                    }
                );
            }, DEBOUNCE_NORMAL);
        } else {
            const val = isSelected && !props.required ? "" : button.id;
            if (autoSubmit.current.id) {
                clearTimeout(autoSubmit.current.id);
                autoSubmit.current.id = 0;
            }
            setValue(val);
            if (props.onChange) {
                props.onChange(val);
            }
            if (typeof valueRef !== "object" && props.autoSubmit && val) {
                handleAutoSubmit(autoSubmit);
            }
        }
        if (button.onChange) {
            button.onChange(!button.slot && props.required ? true : !isSelected);
        }
    };
    useEffect(() => {
        return () => {
            cancelUITimeout(debounceRef.current);
        };
    }, []);
    autoSubmit.current.cb = props.onSubmit;
    return jsx(MultipleChoiceElement, {
        $alignment: props.alignment || "vertical",
        $margin: props.styles.margin,
        children: props.buttons.map((button, index) => {
            const isSelected = button.slot ? castToBoolean(buttonsRef.current[button.id], button.slot.value) : value === button.id;
            if (button.slot) {
                button.slot.confirm();
            }
            return (
                (props.view === "preview" || button.name || button.description) &&
                jsx(
                    ButtonFabric,
                    {
                        styles: {
                            baseColor: button.color || props.styles.color,
                            mode: isSelected ? "fill" : "outline",
                            hover: "outline",
                            outlineSize: props.styles.outlineSize,
                            roundness: props.styles.roundness,
                            scale: props.styles.scale,
                        },
                        hyperlink:
                            (button.url && {
                                url: button.url,
                                target: button.target || "blank",
                            }) ||
                            undefined,
                        label: button.label || button.name || "...",
                        description: button.description,
                        icon: (button.url && button.target !== "self" && hyperlinkIcon) || undefined,
                        iconPosition: "right",
                        tabIndex: button.tabIndex || props.tabIndex,
                        ariaDescribedBy: props.ariaDescribedBy,
                        disabled:
                            button.disabled ||
                            props.disabled ||
                            props.readOnly ||
                            (typeof valueRef === "object" && (valueRef.isFrozen || valueRef.isLocked)) ||
                            (button.slot && (button.slot.isFrozen || button.slot.isLocked)) ||
                            false,
                        onAutoFocus: ((button.slot || !value ? index === 0 : isSelected) && props.onAutoFocus) || undefined,
                        onFocus: props.onFocus,
                        onBlur: props.onBlur,
                        onKeyDown: (e) => {
                            if (e.shiftKey && e.key === "Enter" && props.onSubmit) {
                                e.preventDefault();
                                props.onSubmit();
                            } else if (e.key === "Escape") {
                                e.currentTarget.blur();
                            } else if (e.key === "Tab") {
                                if (e.shiftKey) {
                                    if (props.onCancel && index === 0) {
                                        e.preventDefault();
                                        props.onCancel();
                                    }
                                } else if (props.onSubmit && index + 1 === props.buttons.length) {
                                    e.preventDefault();
                                    props.onSubmit();
                                }
                            } else {
                                const keyCode = (e.key.length === 1 && e.key.charCodeAt(0)) || 0;
                                const offset =
                                    (keyCode <= 57 ? keyCode - 48 : 0) ||
                                    (keyCode <= 90 ? keyCode - 64 : 0) ||
                                    (keyCode <= 122 ? keyCode - 96 : 0);
                                if (offset > 0 && offset <= 26) {
                                    const toggleButton = arrayItem(props.buttons, offset - 1);
                                    if (toggleButton) {
                                        toggle(toggleButton);
                                    }
                                }
                            }
                        },
                        onClick: () => toggle(button),
                    },
                    button.id || index
                )
            );
        }),
    });
};

export { MultipleChoiceFabric };
