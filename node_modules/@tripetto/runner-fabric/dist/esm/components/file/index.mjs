import { jsx, Fragment, jsxs } from "react/jsx-runtime";
import { styled } from "styled-components";
import { useState, useEffect, useRef } from "react";
import { isNumberFinite, Str, Num } from "@tripetto/runner";
import { color } from "../../color/index.mjs";
import { ButtonFabric } from "../button/index.mjs";
import { warningIcon } from "../../icons/warning.mjs";
import { fileIcon } from "../../icons/file.mjs";
import { uploadIcon } from "../../icons/upload.mjs";

const FileElement = styled.div`
    outline: none;
    box-sizing: border-box;
    display: block;
    width: 100%;
    height: ${(props) => `${14 * props.$scale}em`};
    position: relative;
    overflow: hidden;
    font-size: 1em;
    line-height: 1.5em;
    background-color: ${(props) => color(props.$backgroundColor)};
    background-image: ${(props) =>
        props.$error
            ? `url("data:image/svg+xml;base64,${warningIcon(
                  color(props.$errorColor, (o) =>
                      o.makeBlackOrWhite(props.$backgroundColor !== "transparent" && props.$borderColor === "transparent")
                  )
              )}")`
            : undefined};
    background-repeat: no-repeat;
    background-size: ${8 / 7}em;
    background-position: right 0.375em top 0.375em;
    border: ${(props) =>
        `${props.$backgroundColor === "transparent" && props.$borderColor === "transparent" ? 0 : props.$borderSize}px solid ${color(
            props.$borderColor && props.$borderColor !== "transparent" ? props.$borderColor : props.$backgroundColor
        )}`};
    color: ${(props) =>
        color(
            props.$textColor
                ? props.$textColor
                : props.$borderColor && props.$borderColor !== "transparent"
                ? props.$borderColor
                : color(props.$backgroundColor, (o) => o.makeBlackOrWhite())
        )};
    border-radius: ${(props) => (isNumberFinite(props.$roundness) ? `${props.$roundness}px` : "0.5em")};
    padding: ${(props) =>
        props.$backgroundColor === "transparent" && props.$borderColor === "transparent" ? "0" : `${0.375 * props.$scale}em 0.75em`};
    margin: 0;
    opacity: ${(props) => (props.$disabled ? 0.65 : 1)};
    transition:
        color 0.15s ease-in-out,
        background-color 0.15s ease-in-out,
        border-color 0.15s ease-in-out,
        box-shadow 0.15s ease-in-out,
        opacity 0.15s ease-in-out;
    cursor: default;

    svg {
        fill: ${(props) =>
            color(
                props.$textColor
                    ? props.$textColor
                    : props.$borderColor && props.$borderColor !== "transparent"
                    ? props.$borderColor
                    : color(props.$backgroundColor, (o) => o.makeBlackOrWhite())
            )};
        transition: fill 0.15s ease-in-out;
    }

    > div,
    > label {
        position: absolute;
        left: 0.75em;
        right: 0.75em;
        top: 0.75em;
        bottom: 0.75em;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
    }

    &:hover {
        box-shadow: ${(props) =>
            (!props.$disabled &&
                (props.$backgroundColor !== "transparent" || props.$borderColor !== "transparent") &&
                `0 0 0 0.2rem ${color(
                    props.$borderColor && props.$borderColor !== "transparent" ? props.$borderColor : props.$backgroundColor,
                    (o) => o.manipulate((m) => m.alpha(0.2))
                )}`) ||
            undefined};
    }

    &:focus {
        background-color: ${(props) => (!props.$disabled && color(props.$backgroundColor)) || undefined};
        background-image: ${(props) => (!props.$errorVisible && "none") || undefined};
        border-color: ${(props) =>
            (!props.$disabled &&
                color(props.$borderColor && props.$borderColor !== "transparent" ? props.$borderColor : props.$backgroundColor)) ||
            undefined};
        color: ${(props) =>
            (!props.$disabled &&
                color(
                    props.$textColor
                        ? props.$textColor
                        : props.$borderColor && props.$borderColor !== "transparent"
                        ? props.$borderColor
                        : color(props.$backgroundColor, (o) => o.makeBlackOrWhite())
                )) ||
            undefined};
        box-shadow: ${(props) =>
            (!props.$disabled &&
                (props.$backgroundColor !== "transparent" || props.$borderColor !== "transparent") &&
                `0 0 0 0.2rem ${color(
                    props.$borderColor && props.$borderColor !== "transparent" ? props.$borderColor : props.$backgroundColor,
                    (o) => o.manipulate((m) => m.alpha(0.5))
                )}`) ||
            undefined};
    }
`;
const FileBrowseElement = styled.label`
    cursor: pointer;

    * {
        pointer-events: none;
    }

    > svg {
        display: block;
        height: ${(props) => `${5 * props.$scale}em`};
        margin-bottom: 0.375em;
    }

    > input {
        width: 1px;
        height: 1px;
        opacity: 0;
        overflow: hidden;
        position: absolute;
        z-index: -1;
    }

    > span {
        display: block;
        text-align: center;
    }

    > small {
        display: block;
        text-align: center;
    }
`;
const FileErrorElement = styled.div`
    > div {
        display: block;
        text-align: center;
    }

    > div:first-child {
        font-weight: bold;
    }

    > div:last-of-type {
        margin-bottom: 0.375em;
    }
`;
const FileProgressElement = styled.div`
    > div {
        display: inline-block;
        width: 80%;
        max-width: 300px;
        height: 16px;
        background-color: ${(props) => color(props.$color, (o) => o.manipulate((m) => m.alpha(0.25)))};
        border-radius: 4px;
        overflow: hidden;
        margin-bottom: 0.375em;

        > div {
            width: 0%;
            height: 16px;
            background-color: ${(props) => color(props.$color)};
            background-image: linear-gradient(
                45deg,
                ${(props) => color(props.$color, (o) => o.makeBlackOrWhite().manipulate((m) => m.alpha(0.25)))} 25%,
                transparent 25%,
                transparent 50%,
                ${(props) => color(props.$color, (o) => o.makeBlackOrWhite().manipulate((m) => m.alpha(0.25)))} 50%,
                ${(props) => color(props.$color, (o) => o.makeBlackOrWhite().manipulate((m) => m.alpha(0.25)))} 75%,
                transparent 75%,
                transparent
            );
            background-size: 1rem 1rem;
            transition: width 0.5s ease-out;
        }
    }

    > span {
        display: block;
        text-align: center;
    }
`;
const FilePreviewElement = styled.div`
    > img,
    > svg {
        display: block;
        height: ${(props) => `${6 * props.$scale}em`};
        margin: 0.375em;
    }

    > div {
        display: block;
        text-align: center;
        white-space: nowrap;
        text-overflow: ellipsis;
    }

    > div:last-of-type {
        margin-bottom: 0.75em;
    }
`;
const FileThumbnailFabric = (props) => {
    const [data, setData] = useState({
        loading: props.controller.isImage,
        base64data: "",
    });
    useEffect(() => {
        if (props.controller.isImage) {
            if (!data.loading) {
                setData({
                    loading: true,
                    base64data: "",
                });
            }
            props.controller
                .download(props.service)
                .then((base64data) =>
                    setData({
                        loading: false,
                        base64data,
                    })
                )
                .catch(() =>
                    setData({
                        loading: false,
                        base64data: "",
                    })
                );
        }
    }, [props.controller.fileSlot.reference]);
    if (data.loading) {
        return jsx(Fragment, { children: props.loading });
    }
    return (
        (data.base64data &&
            (props.host ? jsx(props.host, { children: jsx("img", { src: data.base64data }) }) : jsx("img", { src: data.base64data }))) ||
        jsx(Fragment, { children: props.error })
    );
};
const FileFabric = (props) => {
    const [dragging, setDragging] = useState(false);
    const [deleting, setDeleting] = useState(false);
    const [progress, setProgress] = useState(-1);
    const [error, setError] = useState("");
    const [errorVisible, makeErrorVisible] = useState(false);
    const inputRef = useRef();
    const disabled = props.disabled || props.controller.fileSlot.isFrozen || props.controller.fileSlot.isLocked || false;
    const baseColor = props.styles.textColor
        ? props.styles.textColor
        : props.styles.borderColor && props.styles.borderColor !== "transparent"
        ? props.styles.borderColor
        : color(props.styles.backgroundColor || "transparent", (o) => o.makeBlackOrWhite());
    const handleUpload = (files) => {
        if (!disabled) {
            setProgress(0);
            makeErrorVisible(true);
            props.controller
                .upload(files, props.service, (percent) => setProgress(Num.floor(percent)))
                .then(() => setProgress(-1))
                .catch((err) => {
                    setError(err);
                    setProgress(-1);
                });
        }
    };
    const handleDelete = () => {
        if (props.controller.fileSlot.hasValue && !error && progress === -1) {
            setDeleting(true);
            makeErrorVisible(true);
            props.controller
                .delete(props.service)
                .then(() => setDeleting(false))
                .catch(() => setDeleting(false));
        }
    };
    return jsxs(FileElement, {
        ref: props.onAutoFocus,
        tabIndex: props.tabIndex || 0,
        onFocus: props.onFocus,
        onBlur: props.onBlur,
        onKeyDown: (e) => {
            if (e.key === "Enter") {
                if (!e.shiftKey) {
                    if (!error && progress === -1) {
                        if (props.controller.fileSlot.hasValue && props.onSubmit) {
                            e.preventDefault();
                            props.onSubmit();
                        } else if (inputRef.current) {
                            e.preventDefault();
                            inputRef.current.click();
                        }
                    }
                } else if (props.onSubmit) {
                    e.preventDefault();
                    props.onSubmit();
                }
            } else if (e.key === "Escape") {
                e.currentTarget.blur();
            } else if (e.key === "Tab") {
                if (e.shiftKey) {
                    if (props.onCancel) {
                        e.preventDefault();
                        props.onCancel();
                    }
                } else if (props.onSubmit) {
                    e.preventDefault();
                    props.onSubmit();
                }
            } else if (e.key === "Delete" && props.controller.fileSlot.hasValue && !error && progress === -1) {
                e.preventDefault();
                handleDelete();
            }
        },
        $backgroundColor: props.styles.backgroundColor || "transparent",
        $borderColor: props.styles.borderColor || "transparent",
        $borderSize: props.styles.borderSize || 1,
        $roundness: props.styles.roundness,
        $textColor: props.styles.textColor,
        $errorColor: props.styles.errorColor,
        $errorVisible: errorVisible,
        $error: props.error || false,
        $scale: props.styles.scale || 1,
        $disabled: disabled,
        children: [
            !props.controller.fileSlot.hasValue &&
                !error &&
                progress === -1 &&
                jsxs(FileBrowseElement, {
                    onDragEnter: (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        if (!disabled && progress === -1) {
                            setDragging(true);
                        }
                    },
                    onDragOver: (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                    },
                    onDragLeave: (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        setDragging(false);
                    },
                    onDrop: (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        setDragging(false);
                        if (!disabled && progress === -1) {
                            const files = e.dataTransfer.files;
                            if (files) {
                                handleUpload(files);
                            }
                        }
                    },
                    $scale: props.styles.scale || 1,
                    children: [
                        uploadIcon,
                        jsx("input", {
                            ref: (el) => (inputRef.current = el),
                            type: "file",
                            multiple: false,
                            tabIndex: -1,
                            disabled: disabled,
                            "aria-describedby": props.ariaDescribedBy,
                            onChange: (e) => {
                                if (e.target && e.target.files) {
                                    handleUpload(e.target.files);
                                }
                            },
                        }),
                        jsx("span", { children: props.labels(dragging ? "dragging" : "explanation", "") }),
                        props.controller.limit > 0 && jsx("small", { children: props.labels("limit", `${props.controller.limit}Mb`) }),
                        props.controller.allowedExtensions.length > 0 &&
                            jsx("small", {
                                children: props.labels("extensions", Str.iterateToString(props.controller.allowedExtensions, ", ")),
                            }),
                    ],
                }),
            !error &&
                progress !== -1 &&
                jsxs(FileProgressElement, {
                    onDragOver: (e) => {
                        e.preventDefault();
                    },
                    onDrop: (e) => {
                        e.preventDefault();
                    },
                    $color: baseColor,
                    children: [
                        jsx("div", {
                            children: jsx("div", {
                                style: {
                                    width: `${Num.range(progress, 0, 100)}%`,
                                },
                            }),
                        }),
                        jsx("span", { children: props.labels("progress", `${Num.range(progress, 0, 100)}%`) }),
                    ],
                }),
            error &&
                jsxs(FileErrorElement, {
                    onDragOver: (e) => {
                        e.preventDefault();
                    },
                    onDrop: (e) => {
                        e.preventDefault();
                    },
                    children: [
                        jsx("div", { children: props.labels("invalid-file", "") }),
                        jsx("div", {
                            children:
                                error === "invalid-amount"
                                    ? props.labels("invalid-amount", "")
                                    : error === "invalid-extension"
                                    ? props.labels("invalid-extension", "")
                                    : error === "invalid-size"
                                    ? props.labels("invalid-size", "")
                                    : props.labels("error", error),
                        }),
                        jsx(ButtonFabric, {
                            styles: {
                                baseColor,
                                mode: "outline",
                            },
                            tabIndex: props.tabIndex || 0,
                            label: props.labels("retry", ""),
                            onClick: () => setError(""),
                        }),
                    ],
                }),
            props.controller.fileSlot.hasValue &&
                !error &&
                progress === -1 &&
                jsxs(FilePreviewElement, {
                    onDragOver: (e) => {
                        e.preventDefault();
                    },
                    onDrop: (e) => {
                        e.preventDefault();
                    },
                    $scale: props.styles.scale || 1,
                    children: [
                        props.controller.isImage
                            ? jsx(FileThumbnailFabric, {
                                  controller: props.controller,
                                  service: props.service,
                                  loading: fileIcon,
                                  error: fileIcon,
                              })
                            : fileIcon,
                        jsx("div", { children: props.controller.fileSlot.string }),
                        jsx(ButtonFabric, {
                            styles: {
                                baseColor,
                                mode: "outline",
                            },
                            tabIndex: props.tabIndex || 0,
                            label: props.labels("delete", ""),
                            disabled: deleting,
                            onClick: handleDelete,
                        }),
                    ],
                }),
        ],
    });
};

export { FileFabric, FileThumbnailFabric };
