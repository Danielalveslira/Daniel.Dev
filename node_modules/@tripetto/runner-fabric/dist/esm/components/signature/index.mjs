import { jsx, Fragment, jsxs } from "react/jsx-runtime";
import { styled } from "styled-components";
import { useState, useEffect, useRef } from "react";
import { isNumberFinite, castToNumber, Num, L10n, DateTime } from "@tripetto/runner";
import { color, getColor } from "../../color/index.mjs";
import { penIcon } from "../../icons/pen.mjs";
import { warningIcon } from "../../icons/warning.mjs";
import { clearIcon } from "../../icons/clear.mjs";
import { ButtonFabric } from "../button/index.mjs";

const SignatureElement = styled.div`
    outline: none;
    box-sizing: border-box;
    display: block;
    width: 100%;
    height: ${(props) => `${(props.$size === "sm" ? 9 : props.$size === "lg" ? 19 : 14) * props.$scale}em`};
    position: relative;
    overflow: hidden;
    font-size: 1em;
    line-height: 1.5em;
    background-color: ${(props) => color(props.$backgroundColor)};
    background-image: ${(props) =>
        props.$error
            ? `url("data:image/svg+xml;base64,${warningIcon(
                  color(props.$errorColor, (o) =>
                      o.makeBlackOrWhite(props.$backgroundColor !== "transparent" && props.$borderColor === "transparent")
                  )
              )}")`
            : undefined};
    background-repeat: no-repeat;
    background-size: ${8 / 7}em;
    background-position: right 0.375em top 0.375em;
    border: ${(props) =>
        `${props.$backgroundColor === "transparent" && props.$borderColor === "transparent" ? 0 : props.$borderSize}px solid ${color(
            props.$borderColor && props.$borderColor !== "transparent" ? props.$borderColor : props.$backgroundColor
        )}`};
    color: ${(props) =>
        color(
            props.$textColor
                ? props.$textColor
                : props.$borderColor && props.$borderColor !== "transparent"
                ? props.$borderColor
                : color(props.$backgroundColor, (o) => o.makeBlackOrWhite())
        )};
    border-radius: ${(props) => (isNumberFinite(props.$roundness) ? `${props.$roundness}px` : "0.5em")};
    margin: 0;
    opacity: ${(props) => (props.$disabled ? 0.65 : 1)};
    transition:
        color 0.15s ease-in-out,
        background-color 0.15s ease-in-out,
        border-color 0.15s ease-in-out,
        box-shadow 0.15s ease-in-out,
        opacity 0.15s ease-in-out;
    cursor: default;

    &:hover {
        box-shadow: ${(props) =>
            (!props.$disabled &&
                (props.$backgroundColor !== "transparent" || props.$borderColor !== "transparent") &&
                `0 0 0 0.2rem ${color(
                    props.$borderColor && props.$borderColor !== "transparent" ? props.$borderColor : props.$backgroundColor,
                    (o) => o.manipulate((m) => m.alpha(0.2))
                )}`) ||
            undefined};
    }

    &:focus {
        background-color: ${(props) => (!props.$disabled && color(props.$backgroundColor)) || undefined};
        border-color: ${(props) =>
            (!props.$disabled &&
                color(props.$borderColor && props.$borderColor !== "transparent" ? props.$borderColor : props.$backgroundColor)) ||
            undefined};
        color: ${(props) =>
            (!props.$disabled &&
                color(
                    props.$textColor
                        ? props.$textColor
                        : props.$borderColor && props.$borderColor !== "transparent"
                        ? props.$borderColor
                        : color(props.$backgroundColor, (o) => o.makeBlackOrWhite())
                )) ||
            undefined};
        box-shadow: ${(props) =>
            (!props.$disabled &&
                (props.$backgroundColor !== "transparent" || props.$borderColor !== "transparent") &&
                `0 0 0 0.2rem ${color(
                    props.$borderColor && props.$borderColor !== "transparent" ? props.$borderColor : props.$backgroundColor,
                    (o) => o.manipulate((m) => m.alpha(0.5))
                )}`) ||
            undefined};
    }

    > canvas {
        position: absolute;
        left: 0;
        top: 0;
        width: 1px;
        height: 1px;
        touch-action: none;

        &:first-of-type {
            pointer-events: none;
            opacity: 0;
        }

        &:last-of-type {
            cursor: ${(props) =>
                `url("data:image/svg+xml;base64,${penIcon(
                    color(
                        props.$textColor
                            ? props.$textColor
                            : props.$borderColor && props.$borderColor !== "transparent"
                            ? props.$borderColor
                            : color(props.$backgroundColor, (o) => o.makeBlackOrWhite())
                    )
                )}") 1 32, auto`};
            pointer-events: ${(props) => (!props.$disabled && props.$allowSign ? "auto" : "none")};
            opacity: ${(props) => (props.$disabled || props.$processing ? 0.3 : 1)};
            transition: opacity 0.3s;
            filter: blur(0.5px);
        }
    }

    > div {
        position: absolute;
        left: 0;
        right: 0;
        top: 0;
        bottom: 0;
        opacity: ${(props) => (!props.$disabled && !props.$allowSign ? 1 : 0)};
        pointer-events: ${(props) => (props.$disabled || props.$allowSign ? "none" : "auto")};
        transition: opacity 0.3s;
        display: flex;
        align-items: center;
        justify-content: center;
    }
`;
const SignatureProgressElement = styled.div`
    position: absolute;
    left: 0;
    right: 0;
    top: 0;
    bottom: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-direction: column;

    > div {
        display: inline-block;
        width: 80%;
        max-width: 300px;
        height: 16px;
        background-color: ${(props) => color(props.$color, (o) => o.manipulate((m) => m.alpha(0.25)))};
        border-radius: 4px;
        overflow: hidden;
        margin-bottom: 0.375em;

        > div {
            width: 0%;
            height: 16px;
            background-color: ${(props) => color(props.$color)};
            background-image: linear-gradient(
                45deg,
                ${(props) => color(props.$color, (o) => o.makeBlackOrWhite().manipulate((m) => m.alpha(0.25)))} 25%,
                transparent 25%,
                transparent 50%,
                ${(props) => color(props.$color, (o) => o.makeBlackOrWhite().manipulate((m) => m.alpha(0.25)))} 50%,
                ${(props) => color(props.$color, (o) => o.makeBlackOrWhite().manipulate((m) => m.alpha(0.25)))} 75%,
                transparent 75%,
                transparent
            );
            background-size: 1rem 1rem;
            transition: width 0.5s ease-out;
        }
    }

    > span {
        display: block;
        text-align: center;
        white-space: nowrap;
    }
`;
const SignatureSignedElement = styled.div`
    position: absolute;
    right: 10px;
    top: 10px;
    display: flex;
    align-items: center;

    > span {
        display: block;
        margin-right: 10px;
        white-space: nowrap;
    }
`;
const SignatureViewFabric = (props) => {
    const [data, setData] = useState({
        loading: true,
        base64data: "",
    });
    useEffect(() => {
        if (!data.loading) {
            setData({
                loading: true,
                base64data: "",
            });
        }
        props.controller
            .download(props.service)
            .then((base64data) =>
                setData({
                    loading: false,
                    base64data,
                })
            )
            .catch(() =>
                setData({
                    loading: false,
                    base64data: "",
                })
            );
    }, [props.controller.signatureSlot.reference]);
    if (data.loading) {
        return jsx(Fragment, { children: props.loading });
    }
    return (
        (data.base64data &&
            (props.host ? jsx(props.host, { children: jsx("img", { src: data.base64data }) }) : jsx("img", { src: data.base64data }))) ||
        jsx(Fragment, { children: props.error })
    );
};
const SignatureFabric = (props) => {
    var _a;
    const canvasRef = useRef();
    const bufferRef = useRef();
    const [progress, setProgress] = useState(-1);
    const [reset, setReset] = useState(false);
    const [loading, setLoading] = useState(false);
    const propsRef = useRef();
    const allowSign = useRef(false);
    const signedRef = useRef(false);
    const colorRef = useRef("");
    const disabled = props.disabled || props.controller.signatureSlot.isFrozen || props.controller.signatureSlot.isLocked || false;
    const baseColor = props.styles.textColor
        ? props.styles.textColor
        : props.styles.borderColor && props.styles.borderColor !== "transparent"
        ? props.styles.borderColor
        : color(props.styles.backgroundColor || "transparent", (o) => o.makeBlackOrWhite());
    colorRef.current = props.color || baseColor;
    const updateColor = () => {
        const canvas = canvasRef.current;
        if (canvas && canvas.width > 0 && canvas.height > 0) {
            const canvasCtx = canvas.getContext("2d");
            if (canvasCtx) {
                const signatureData = canvasCtx.getImageData(0, 0, canvas.width, canvas.height);
                const color = getColor(colorRef.current);
                for (let i = 0; i < signatureData.data.length; i += 4) {
                    if (signatureData.data[i + 3] !== 0) {
                        signatureData.data[i] = color.red();
                        signatureData.data[i + 1] = color.green();
                        signatureData.data[i + 2] = color.blue();
                    }
                }
                canvasCtx.putImageData(signatureData, 0, 0);
            }
        }
    };
    const handleReset = () => {
        if (props.controller.signatureSlot.hasValue && progress === -1) {
            setReset(true);
            props.controller
                .delete(props.service)
                .then(() => {
                    var _a;
                    const canvas = canvasRef.current;
                    if (canvas) {
                        (_a = canvas.getContext("2d")) === null || _a === void 0 ? void 0 : _a.clearRect(0, 0, canvas.width, canvas.height);
                    }
                    setReset(false);
                })
                .catch(() => setReset(false));
        }
    };
    useEffect(() => {
        var _a;
        if (!canvasRef.current) {
            return;
        }
        const parentRect = (_a = canvasRef.current.parentElement) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect();
        if (!parentRect) {
            return;
        }
        let drawing = false;
        let waiting = 0;
        const canvas = canvasRef.current;
        const canvasCtx = canvas.getContext("2d", { willReadFrequently: true });
        const scale = 2;
        const resizeObserver =
            "ResizeObserver" in window &&
            new ResizeObserver(() => {
                const computedStyles = getComputedStyle(canvas.parentElement);
                const width = castToNumber(computedStyles.width);
                const height = castToNumber(computedStyles.height);
                if (width > 0 && height > 0 && (width * scale !== canvas.width || height * scale !== canvas.height)) {
                    const buffer =
                        (canvas.width > 0 &&
                            canvas.height > 0 &&
                            (canvasCtx === null || canvasCtx === void 0
                                ? void 0
                                : canvasCtx.getImageData(0, 0, canvas.width, canvas.height))) ||
                        undefined;
                    canvas.style.width = `${width}px`;
                    canvas.style.height = `${height}px`;
                    canvas.width = width * scale;
                    canvas.height = height * scale;
                    if (buffer) {
                        canvasCtx === null || canvasCtx === void 0 ? void 0 : canvasCtx.putImageData(buffer, 0, 0);
                    }
                }
            });
        canvas.style.width = `${parentRect.width}px`;
        canvas.style.height = `${parentRect.height}px`;
        canvas.width = parentRect.width * scale;
        canvas.height = parentRect.height * scale;
        if (!canvasCtx) {
            return;
        }
        const startSignature = (event) => {
            var _a;
            const rect = event.target.getBoundingClientRect();
            if (waiting) {
                clearTimeout(waiting);
                waiting = 0;
            }
            if (!allowSign.current || canvas.width < 1 || canvas.height < 1) {
                drawing = false;
                return;
            }
            canvasCtx.lineWidth = 3 * scale;
            canvasCtx.lineJoin = canvasCtx.lineCap = "round";
            canvasCtx.imageSmoothingQuality = "high";
            canvasCtx.strokeStyle = color(colorRef.current);
            canvasCtx.beginPath();
            canvasCtx.moveTo((event.clientX - rect.x) * scale, (event.clientY - rect.y) * scale);
            drawing = true;
            (_a = canvas.parentElement) === null || _a === void 0 ? void 0 : _a.focus();
        };
        const drawSignature = (event) => {
            if (event.target && drawing && allowSign.current) {
                const rect = event.target.getBoundingClientRect();
                if (waiting) {
                    clearTimeout(waiting);
                    waiting = 0;
                }
                const x = (event.clientX - rect.x) * scale;
                const y = (event.clientY - rect.y) * scale;
                canvasCtx.lineTo(x, y);
                canvasCtx.stroke();
            }
            event.preventDefault();
            event.stopPropagation();
        };
        const endSignature = () => {
            drawing = false;
            if (waiting) {
                clearTimeout(waiting);
            }
            waiting = setTimeout(() => {
                const buffer = bufferRef.current;
                setProgress(0);
                if (buffer && canvas.width > 0 && canvas.height > 0) {
                    const bufferCtx = buffer.getContext("2d");
                    if (bufferCtx) {
                        const signatureData = canvasCtx.getImageData(0, 0, canvas.width, canvas.height);
                        let x1 = -1;
                        let y1 = -1;
                        let x2 = 0;
                        let y2 = 0;
                        for (let i = 0; i < signatureData.data.length; i += 4) {
                            if (signatureData.data[i + 3] !== 0) {
                                const x = (i / 4) % canvas.width;
                                const y = Num.floor(i / 4 / canvas.width);
                                signatureData.data[i] = 0;
                                signatureData.data[i + 1] = 0;
                                signatureData.data[i + 2] = 0;
                                if (x1 === -1 || x < x1) {
                                    x1 = x;
                                }
                                if (y1 === -1 || y < y1) {
                                    y1 = y;
                                }
                                if (x > x2) {
                                    x2 = x;
                                }
                                if (y > y2) {
                                    y2 = y;
                                }
                            }
                        }
                        const width = x2 - x1;
                        const height = y2 - y1;
                        if (x1 >= 0 && y1 >= 0 && width > 0 && height > 0) {
                            const bufferData = canvasCtx.getImageData(x1, y1, width, height);
                            for (let i = 0; i < bufferData.data.length; i += 4) {
                                if (bufferData.data[i + 3] !== 0) {
                                    bufferData.data[i] = 0;
                                    bufferData.data[i + 1] = 0;
                                    bufferData.data[i + 2] = 0;
                                }
                            }
                            buffer.width = Num.min(width + 50, canvas.width);
                            buffer.height = Num.min(height + 50, canvas.height);
                            bufferCtx.clearRect(0, 0, buffer.width, buffer.height);
                            bufferCtx.putImageData(bufferData, (buffer.width - width) / 2, (buffer.height - height) / 2);
                            signedRef.current = true;
                            buffer.toBlob((blob) => {
                                if (blob && propsRef.current) {
                                    const dataTransfer = new DataTransfer();
                                    dataTransfer.items.add(
                                        new File([blob], `signature-${DateTime.format("yyyyMMddHHmmss")}.png`, {
                                            type: "image/png",
                                            lastModified: new Date().getTime(),
                                        })
                                    );
                                    propsRef.current.controller
                                        .upload(dataTransfer.files, propsRef.current.service, (percent) => setProgress(Num.floor(percent)))
                                        .then(() => setProgress(-1))
                                        .catch(() => setProgress(-1));
                                }
                            }, "image/png");
                        } else {
                            setProgress(-1);
                        }
                    }
                }
                waiting = 0;
            }, 1500);
        };
        canvas.addEventListener("pointerdown", startSignature);
        canvas.addEventListener("pointermove", drawSignature);
        canvas.addEventListener("pointerup", endSignature);
        if (resizeObserver && canvas.parentElement) {
            resizeObserver.observe(canvas.parentElement);
        }
        return () => {
            if (resizeObserver) {
                resizeObserver.disconnect();
            }
            canvas.removeEventListener("pointerdown", startSignature);
            canvas.removeEventListener("pointermove", drawSignature);
            canvas.removeEventListener("pointerup", endSignature);
        };
    }, []);
    useEffect(() => {
        if (props.controller.signatureSlot.hasValue && progress === -1 && !loading && !signedRef.current) {
            setLoading(true);
            props.controller
                .download(props.service)
                .then((base64data) => {
                    if (base64data) {
                        const buffer = new Image();
                        buffer.onload = () => {
                            const canvas = canvasRef.current;
                            if (canvas) {
                                const ctx = canvas.getContext("2d");
                                if (ctx) {
                                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                                    ctx.drawImage(
                                        buffer,
                                        Num.min(50, Num.max(canvas.width - buffer.width, 0)),
                                        Num.max(canvas.height - buffer.height, 0) / 2
                                    );
                                    updateColor();
                                }
                            }
                        };
                        buffer.src = base64data;
                    }
                    setLoading(false);
                })
                .catch(() => setLoading(false));
        }
    }, [props.controller.signatureSlot.reference]);
    useEffect(() => updateColor(), [colorRef.current]);
    propsRef.current = props;
    allowSign.current = !loading && !reset && progress === -1 && !props.controller.signatureSlot.hasValue;
    return jsxs(SignatureElement, {
        ref: props.onAutoFocus,
        tabIndex: props.tabIndex || 0,
        onFocus: props.onFocus,
        onBlur: props.onBlur,
        $backgroundColor: props.styles.backgroundColor || "transparent",
        $borderColor: props.styles.borderColor || "transparent",
        $borderSize: props.styles.borderSize || 1,
        $roundness: props.styles.roundness,
        $textColor: props.styles.textColor,
        $errorColor: props.styles.errorColor,
        $error: props.error || false,
        $scale: props.styles.scale || 1,
        $disabled: disabled,
        $allowSign: allowSign.current,
        $size: props.size || "md",
        $processing: progress !== -1,
        children: [
            jsx("canvas", { ref: (c) => (bufferRef.current = c), width: "1", height: "1" }),
            jsx("canvas", { ref: (c) => (canvasRef.current = c), width: "1", height: "1" }),
            jsx("div", {
                children:
                    progress !== -1
                        ? jsxs(SignatureProgressElement, {
                              $color: baseColor,
                              children: [
                                  jsx("div", {
                                      children: jsx("div", {
                                          style: {
                                              width: `${Num.range(progress, 0, 100)}%`,
                                          },
                                      }),
                                  }),
                                  jsx("span", { children: props.labels("processing", `${Num.range(progress, 0, 100)}%`) }),
                              ],
                          })
                        : jsxs(SignatureSignedElement, {
                              children: [
                                  (props.controller.signatureSlot.hasValue &&
                                      (props.controller.signatureSlot.time || 0) > 0 &&
                                      jsx("span", {
                                          children: props.labels(
                                              "signed",
                                              (((_a = props.l10n) === null || _a === void 0 ? void 0 : _a.locale) || L10n.Locales).dateLong(
                                                  props.controller.signatureSlot.time
                                              )
                                          ),
                                      })) ||
                                      undefined,
                                  jsx(ButtonFabric, {
                                      styles: {
                                          baseColor,
                                          mode: "outline",
                                      },
                                      tabIndex: props.tabIndex || 0,
                                      label: props.labels("clear", ""),
                                      icon: clearIcon,
                                      disabled: reset,
                                      onClick: handleReset,
                                  }),
                              ],
                          }),
            }),
        ],
    });
};

export { SignatureFabric, SignatureSignedElement, SignatureViewFabric };
