import { jsxs, jsx } from "react/jsx-runtime";
import { styled } from "styled-components";
import { useRef, useState, useEffect } from "react";
import { isNumberFinite, cancelUITimeout, scheduleUITimeout, findFirst } from "@tripetto/runner";
import { color } from "../../color/index.mjs";
import { dropdownIcon } from "../../icons/dropdown.mjs";
import { warningIcon } from "../../icons/warning.mjs";
import { DEBOUNCE_NORMAL } from "../const.mjs";

const SelectElement = styled.select`
    appearance: none;
    outline: none;
    box-sizing: border-box;
    display: block;
    width: 100%;
    font-size: 1em;
    line-height: 1.5em;
    background-color: ${(props) =>
        color(
            props.$error && props.$backgroundColor !== "transparent" && props.$borderColor === "transparent"
                ? props.$errorColor
                : props.$backgroundColor
        )};
    background-image: ${(props) =>
        `url("data:image/svg+xml;base64,${dropdownIcon(
            color(
                props.$textColor
                    ? props.$textColor
                    : props.$borderColor && props.$borderColor !== "transparent"
                    ? props.$borderColor
                    : color(props.$backgroundColor, (o) => o.makeBlackOrWhite())
            )
        )}")` +
        (props.$error
            ? `,url("data:image/svg+xml;base64,${warningIcon(
                  color(props.$errorColor, (o) =>
                      o.makeBlackOrWhite(props.$backgroundColor !== "transparent" && props.$borderColor === "transparent")
                  )
              )}")`
            : "")};
    background-repeat: no-repeat;
    background-size: 1em, ${8 / 7}em;
    background-position:
        right 0.375em center,
        right 1.75em center;
    border: ${(props) =>
        `${props.$backgroundColor === "transparent" && props.$borderColor === "transparent" ? 0 : props.$borderSize}px solid ${color(
            props.$error
                ? props.$errorColor
                : props.$borderColor && props.$borderColor !== "transparent"
                ? props.$borderColor
                : props.$backgroundColor
        )}`};
    border-radius: ${(props) => (isNumberFinite(props.$roundness) ? `${props.$roundness}px` : "0.5em")};
    color: ${(props) =>
        color(
            props.$error
                ? props.$backgroundColor !== "transparent" && props.$borderColor === "transparent"
                    ? color(props.$errorColor, (o) => o.makeBlackOrWhite())
                    : props.$errorColor
                : props.$textColor
                ? props.$textColor
                : props.$borderColor && props.$borderColor !== "transparent"
                ? props.$borderColor
                : color(props.$backgroundColor, (o) => o.makeBlackOrWhite()),
            (o) => o.manipulate((m) => m.alpha(0.5), props.$placeholder && !props.$error)
        )};
    padding: ${(props) =>
        props.$backgroundColor === "transparent" && props.$borderColor === "transparent"
            ? `0 1.75em 0 0`
            : `${0.375 * props.$scale}em 1.75em ${0.375 * props.$scale}em 0.75em`};
    padding-right: ${(props) => (props.$error && `${1.75 + 8 / 7 + 0.375}em`) || undefined};
    margin: 0;
    opacity: 0.65;
    transition:
        background-color 0.15s ease-in-out,
        border-color 0.15s ease-in-out,
        box-shadow 0.15s ease-in-out,
        opacity 0.15s ease-in-out;

    &::-ms-expand {
        display: none;
    }

    > option {
        background-color: ${(props) => color(props.$backgroundColor)};
        color: ${(props) =>
            color(
                props.$textColor
                    ? props.$textColor
                    : props.$borderColor && props.$borderColor !== "transparent"
                    ? props.$borderColor
                    : color(props.$backgroundColor, (o) => o.makeBlackOrWhite())
            )};
    }

    &:not(:disabled) {
        opacity: 1;

        &:hover {
            box-shadow: ${(props) =>
                ((props.$backgroundColor !== "transparent" || props.$borderColor !== "transparent") &&
                    `0 0 0 0.2rem ${color(
                        props.$error
                            ? props.$errorColor
                            : props.$borderColor && props.$borderColor !== "transparent"
                            ? props.$borderColor
                            : props.$backgroundColor,
                        (o) => o.manipulate((m) => m.alpha(0.2))
                    )}`) ||
                undefined};
        }

        &:focus {
            background-color: ${(props) => color(props.$backgroundColor)};
            background-image: ${(props) =>
                (!props.$errorVisible &&
                    `url("data:image/svg+xml;base64,${dropdownIcon(
                        color(
                            props.$textColor
                                ? props.$textColor
                                : props.$borderColor && props.$borderColor !== "transparent"
                                ? props.$borderColor
                                : color(props.$backgroundColor, (o) => o.makeBlackOrWhite())
                        )
                    )}")`) ||
                undefined};
            border-color: ${(props) =>
                color(props.$borderColor && props.$borderColor !== "transparent" ? props.$borderColor : props.$backgroundColor)};
            color: ${(props) =>
                color(
                    props.$textColor
                        ? props.$textColor
                        : props.$borderColor && props.$borderColor !== "transparent"
                        ? props.$borderColor
                        : color(props.$backgroundColor, (o) => o.makeBlackOrWhite()),
                    (o) => o.manipulate((m) => m.alpha(0.5), props.$placeholder)
                )};
            box-shadow: ${(props) =>
                ((props.$backgroundColor !== "transparent" || props.$borderColor !== "transparent") &&
                    `0 0 0 0.2rem ${color(
                        props.$borderColor && props.$borderColor !== "transparent" ? props.$borderColor : props.$backgroundColor,
                        (o) => o.manipulate((m) => m.alpha(0.5))
                    )}`) ||
                undefined};
        }
    }
`;
const PlaceholderElement = styled.option`
    color: ${(props) =>
        color(
            props.$textColor
                ? props.$textColor
                : props.$borderColor && props.$borderColor !== "transparent"
                ? props.$borderColor
                : color(props.$backgroundColor, (o) => o.makeBlackOrWhite()),
            (o) => o.manipulate((m) => m.alpha(0.5))
        )} !important;
`;
const assertValue = (valueRef, props, reference) => {
    const selected = findFirst(props.options, (option) => option.id === reference);
    if (!selected && !props.placeholder && props.options.length > 0) {
        const defaultOption = findFirst(props.options, (option) => (option.name ? true : false));
        if (defaultOption) {
            valueRef.default(defaultOption.value || defaultOption.name, defaultOption.id, defaultOption.name);
        }
    } else if (valueRef.reference !== (selected === null || selected === void 0 ? void 0 : selected.id)) {
        valueRef.set(
            selected && (selected.value || selected.name),
            selected === null || selected === void 0 ? void 0 : selected.id,
            selected === null || selected === void 0 ? void 0 : selected.name
        );
    }
    return (selected && selected.id) || "";
};
const DropdownFabric = (props) => {
    const valueRef = props.value;
    const debounceRef = useRef(0);
    const [proxy, setProxy] = useState((typeof valueRef !== "object" && valueRef) || "");
    const [value, setValue] =
        typeof valueRef === "object"
            ? [
                  debounceRef.current !== 0 ? proxy : assertValue(valueRef, props, valueRef.reference),
                  (reference) => {
                      cancelUITimeout(debounceRef.current);
                      setProxy(reference);
                      debounceRef.current = scheduleUITimeout(() => {
                          debounceRef.current = 0;
                          assertValue(valueRef, props, reference);
                      }, DEBOUNCE_NORMAL);
                  },
              ]
            : [proxy, setProxy];
    const [errorVisible, makeErrorVisible] = useState(value ? true : false);
    useEffect(() => {
        return () => {
            cancelUITimeout(debounceRef.current);
        };
    }, []);
    return jsxs(SelectElement, {
        id: props.id,
        ref: props.onAutoFocus,
        tabIndex: props.tabIndex,
        required: props.required || false,
        disabled: props.disabled || props.readOnly || (typeof valueRef === "object" && (valueRef.isFrozen || valueRef.isLocked)) || false,
        value: value,
        "aria-describedby": props.ariaDescribedBy,
        onChange: (e) => {
            setValue(e.target.value);
            makeErrorVisible(true);
            if (props.onChange) {
                props.onChange(e.target.value);
            }
        },
        onFocus: props.onFocus,
        onBlur: props.onBlur,
        onKeyDown: (e) => {
            if (e.shiftKey && e.key === "Enter" && props.onSubmit) {
                e.preventDefault();
                props.onSubmit();
            } else if (e.key === "Escape") {
                e.currentTarget.blur();
            } else if (e.key === "Tab") {
                if (e.shiftKey) {
                    if (props.onCancel) {
                        e.preventDefault();
                        props.onCancel();
                    }
                } else if (props.onSubmit) {
                    e.preventDefault();
                    props.onSubmit();
                }
            }
        },
        $backgroundColor: props.styles.backgroundColor || "transparent",
        $borderColor: props.styles.borderColor || "transparent",
        $borderSize: props.styles.borderSize || 1,
        $roundness: props.styles.roundness,
        $textColor: props.styles.textColor,
        $errorColor: props.styles.errorColor,
        $errorVisible: errorVisible,
        $error: props.error || false,
        $scale: props.styles.scale || 1,
        $placeholder: (props.placeholder && value === "") || false,
        children: [
            props.placeholder &&
                jsx(PlaceholderElement, {
                    value: "",
                    $backgroundColor: props.styles.backgroundColor || "transparent",
                    $borderColor: props.styles.borderColor || "transparent",
                    $textColor: props.styles.textColor,
                    $errorColor: props.styles.errorColor,
                    $error: props.error || false,
                    children: props.placeholder,
                }),
            props.options.map(
                (option, index) => option.name && option.id && jsx("option", { value: option.id, children: option.name }, index)
            ),
        ],
    });
};

export { DropdownFabric };
