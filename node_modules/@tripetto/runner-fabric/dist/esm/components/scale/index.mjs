import { jsx, jsxs } from "react/jsx-runtime";
import { styled } from "styled-components";
import { useRef, useState, useEffect } from "react";
import { isArray, isNumberFinite, cancelUITimeout, scheduleUITimeout, Num, castToString, findFirst } from "@tripetto/runner";
import { handleAutoSubmit } from "../helpers.mjs";
import { ButtonFabric } from "../button/index.mjs";
import { DEBOUNCE_NORMAL } from "../const.mjs";

const ScaleElement = styled.div`
    display: block;
    width: 100%;

    > div {
        max-width: calc(100% + 0.4rem);
        overflow-x: scroll;
        -ms-overflow-style: none;
        -webkit-overflow-scrolling: touch;
        scrollbar-width: none;
        padding: 0.2rem;
        margin -0.2rem;

        &::-webkit-scrollbar {
            display: none;
        }

        > div {
            display: inline-block;
            white-space: nowrap;
            min-width: ${(props) => (props.$justify && "100%") || undefined};

            @media (max-device-width: 500px) {
                min-width: 100%;
            }

            @media (max-width: 500px) {
                min-width: 100%;
            }

            > div {
                display: flex;
                flex-wrap: nowrap;

                > button {
                    flex-grow: ${(props) => (props.$justify && "1") || undefined};
                    min-width: ${(props) => (!props.$justify && "3em") || undefined};

                    @media (max-device-width: 500px) {
                        min-width: auto;
                        flex-grow: 1;
                        padding-left: 0.55em;
                        padding-right: 0.55em;
                    }

                    @media (max-width: 500px) {
                        min-width: auto;
                        flex-grow: 1;
                        padding-left: 0.55em;
                        padding-right: 0.55em;
                    }

                    > span > span {
                        display: flex;
                        align-content: center;
                        justify-content: center;
                    }
                }
            }
        }
    }
`;
const ScaleLabelsElement = styled.div`
    display: flex;
    flex-direction: row;
    padding-top: 0.1em;

    > small {
        flex: 1 1 0%;
        font-size: 0.8em;
        color: ${(props) => props.$labelColor};

        &:first-child {
            text-align: left;
        }

        &:nth-child(2) {
            text-align: center;
        }

        &:last-child {
            text-align: right;
        }
    }
`;
const assertValue = (valueRef, options, reference) => {
    if (isArray(options)) {
        const selected = findFirst(options, (option) => option.id === reference);
        if (valueRef.reference !== (selected === null || selected === void 0 ? void 0 : selected.id)) {
            valueRef.set(
                selected && (selected.value || selected.name),
                selected === null || selected === void 0 ? void 0 : selected.id,
                selected === null || selected === void 0 ? void 0 : selected.name
            );
        }
        return (selected && selected.id) || "";
    } else if (isNumberFinite(reference) && options) {
        const value = Num.range(reference, Num.min(options.from, options.to), Num.max(options.from, options.to));
        valueRef.set(value);
        return value;
    }
    valueRef.clear();
    return undefined;
};
const ScaleFabric = (props) => {
    const valueRef = props.value;
    const debounceRef = useRef(0);
    const [proxy, setProxy] = useState((typeof valueRef !== "object" && valueRef) || undefined);
    const [value, setValue] =
        typeof valueRef === "object"
            ? [
                  debounceRef.current !== 0
                      ? proxy
                      : assertValue(
                            valueRef,
                            props.options,
                            isArray(props.options) ? valueRef.reference : isNumberFinite(valueRef.pristine) ? valueRef.pristine : undefined
                        ),
                  (val, submit) => {
                      cancelUITimeout(debounceRef.current);
                      setProxy(val);
                      debounceRef.current = scheduleUITimeout(() => {
                          debounceRef.current = 0;
                          assertValue(valueRef, props.options, val);
                          if (submit && props.autoSubmit && val !== undefined) {
                              handleAutoSubmit(autoSubmit);
                          }
                      }, DEBOUNCE_NORMAL);
                  },
              ]
            : [proxy, setProxy];
    const autoSubmit = useRef({
        id: 0,
        cb: props.onSubmit,
    });
    const changeValue = (val, submit) => {
        if (autoSubmit.current.id) {
            clearTimeout(autoSubmit.current.id);
            autoSubmit.current.id = 0;
        }
        setValue(val, submit);
        if (props.onChange) {
            props.onChange(val);
        }
        if (submit && props.autoSubmit && val !== undefined) {
            handleAutoSubmit(autoSubmit);
        }
    };
    let buttons = [];
    const handleKeyDown = (index, action) => (e) => {
        if (e.shiftKey && e.key === "Enter" && props.onSubmit) {
            e.preventDefault();
            props.onSubmit();
        } else if (e.key === "Escape") {
            e.currentTarget.blur();
        } else if (e.key === "Tab") {
            if (e.shiftKey) {
                if (props.onCancel && index === 0) {
                    e.preventDefault();
                    props.onCancel();
                }
            } else if (props.onSubmit && index + 1 === buttons.length) {
                e.preventDefault();
                props.onSubmit();
            }
        } else if (action) {
            if (e.key === "-" || e.key === "+") {
                action(e.key);
            } else {
                const n = e.key.length === 1 ? e.key.charCodeAt(0) - 48 : -1;
                if (n >= 0 && n <= 9) {
                    action(n);
                }
            }
        }
    };
    useEffect(() => {
        return () => {
            cancelUITimeout(debounceRef.current);
        };
    }, []);
    autoSubmit.current.cb = props.onSubmit;
    if (isArray(props.options)) {
        const options = props.view === "preview" ? props.options : props.options.filter((option) => (option.name ? true : false));
        const count = options.length;
        buttons = options.map((option, index) =>
            jsx(
                ButtonFabric,
                {
                    styles: {
                        baseColor: props.styles.color,
                        mode: value === option.id ? "fill" : "outline",
                        hover: "outline",
                        outlineSize: props.styles.outlineSize,
                        roundness: props.styles.roundness,
                        scale: props.styles.scale,
                        group: count > 1 ? (index === 0 ? "start" : index + 1 === count ? "end" : "middle") : undefined,
                    },
                    label: option.name || "...",
                    tabIndex: props.tabIndex,
                    ariaDescribedBy: props.ariaDescribedBy,
                    disabled:
                        props.disabled ||
                        props.readOnly ||
                        (typeof valueRef === "object" && (valueRef.isFrozen || valueRef.isLocked)) ||
                        false,
                    onAutoFocus: (((!value && index === 0) || value === option.id) && props.onAutoFocus) || undefined,
                    onFocus: props.onFocus,
                    onBlur: props.onBlur,
                    onKeyDown: handleKeyDown(index),
                    onClick: () => changeValue(props.required || value !== option.id ? option.id : undefined, true),
                },
                index
            )
        );
    } else if (props.options) {
        const from = Num.min(props.options.from, props.options.to);
        const to = Num.max(props.options.from, props.options.to);
        const stepSize = Num.max(props.options.stepSize || 0, 1);
        for (let index = from; index <= to; index += stepSize) {
            buttons.push(
                jsx(
                    ButtonFabric,
                    {
                        styles: {
                            baseColor: props.styles.color,
                            mode: value === index ? "fill" : "outline",
                            hover: "outline",
                            outlineSize: props.styles.outlineSize,
                            roundness: props.styles.roundness,
                            scale: props.styles.scale,
                            group:
                                to > from && from + stepSize <= to
                                    ? index === from
                                        ? "start"
                                        : index + stepSize > to
                                        ? "end"
                                        : "middle"
                                    : undefined,
                        },
                        label: castToString(index),
                        tabIndex: props.tabIndex,
                        ariaDescribedBy: props.ariaDescribedBy,
                        disabled:
                            props.disabled ||
                            props.readOnly ||
                            (typeof valueRef === "object" && (valueRef.isFrozen || valueRef.isLocked)) ||
                            false,
                        onAutoFocus: (index === (isNumberFinite(value) ? value : from) && props.onAutoFocus) || undefined,
                        onFocus: props.onFocus,
                        onBlur: props.onBlur,
                        onKeyDown: handleKeyDown(index - from, (key) => {
                            if (key === "-" || key === "+") {
                                if (!isNumberFinite(value)) {
                                    changeValue(index, false);
                                } else if ((key === "-" && value > from) || (key === "+" && value < to)) {
                                    changeValue(value + (key === "-" ? -1 : 1), false);
                                }
                            } else if (key >= from && key <= to) {
                                changeValue(value !== key ? key : undefined, true);
                            }
                        }),
                        onClick: () => changeValue(props.required || value !== index ? index : undefined, true),
                    },
                    index
                )
            );
        }
    }
    return jsx(ScaleElement, {
        $justify: props.justify,
        children: jsx("div", {
            children: jsxs("div", {
                children: [
                    jsx("div", { children: buttons }),
                    buttons.length > 0 &&
                        (props.labelLeft || (props.labelCenter && buttons.length > 2) || (props.labelRight && buttons.length > 1)) &&
                        jsxs(ScaleLabelsElement, {
                            $labelColor: props.styles.labelColor,
                            children: [
                                jsx("small", { children: props.labelLeft || "" }),
                                jsx("small", { children: (buttons.length > 2 && props.labelCenter) || "" }),
                                jsx("small", { children: (buttons.length > 1 && props.labelRight) || "" }),
                            ],
                        }),
                ],
            }),
        }),
    });
};

export { ScaleFabric };
