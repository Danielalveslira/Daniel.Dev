import { jsxs, jsx } from "react/jsx-runtime";
import { styled, css, keyframes } from "styled-components";
import { useRef, useState, useEffect } from "react";
import { cancelUITimeout, scheduleUITimeout, Num } from "@tripetto/runner";
import { handleAutoSubmit } from "../helpers.mjs";
import { color } from "../../color/index.mjs";
import { starShape } from "../../shapes/star.mjs";
import { heartShape } from "../../shapes/heart.mjs";
import { thumbsUpShape } from "../../shapes/thumbs-up.mjs";
import { thumbsDownShape } from "../../shapes/thumbs-down.mjs";
import { personShape } from "../../shapes/person.mjs";
import { DEBOUNCE_NORMAL } from "../const.mjs";

const RatingElement = styled.div`
    display: block;
    width: 100%;
`;
const RatingShapeElement = styled.button`
    appearance: none;
    box-sizing: border-box;
    background: none;
    border: none;
    outline: none;
    width: ${(props) => `${2 * props.$scale}em`};
    height: ${(props) => `${2 * props.$scale}em`};
    margin: 0;
    padding: 0;
    margin-bottom: ${(props) => props.$showLabels && "1em"};
    display: inline-block;
    opacity: 0.2;
    cursor: default;
    transition:
        width 0.15s ease-in-out,
        height 0.15s ease-in-out,
        opacity 0.15 ease-in-out;

    > svg {
        path {
            fill: ${(props) =>
                (props.$checked && color(props.$color)) ||
                (props.$hover && color(props.$color, (o) => o.manipulate((m) => m.alpha(0.3)))) ||
                "none"};
            stroke: ${(props) => color(props.$color)};
            stroke-width: 1px;
            transition:
                fill 0.15s ease-in-out,
                stroke 0.15s ease-in-out;
        }
    }

    > small {
        display: block;
        font-size: 0.8em;
        line-height: 1em;
        text-align: center;
        margin: 0;
        padding: 0;
        color: ${(props) => color(props.$color)};
    }

    animation: ${(props) =>
        props.$checked
            ? css`
                  ${keyframes`
                        50% {
                            transform: scale(1.1);
                        }

                        100% {
                            transform: none;
                        }
                    `} .5s linear
              `
            : undefined};

    &:not(:disabled) {
        opacity: 1;
        cursor: pointer;

        &:focus {
            > svg {
                path {
                    stroke-width: ${(props) => (props.$checked && "2px") || undefined};
                    fill: ${(props) => (!props.$checked && color(props.$color, (o) => o.manipulate((m) => m.alpha(0.3)))) || undefined};
                    stroke: ${(props) => (props.$checked && color(props.$color, (o) => o.manipulate((m) => m.alpha(0.3)))) || undefined};
                }
            }
        }
    }
`;
const getShape = (shape) => {
    switch (shape) {
        case "stars":
            return starShape;
        case "hearts":
            return heartShape;
        case "thumbs-up":
            return thumbsUpShape;
        case "thumbs-down":
            return thumbsDownShape;
        case "persons":
            return personShape;
    }
};
const assertValue = (valueRef, value) => {
    if (value) {
        return (valueRef.value = value);
    }
    valueRef.clear();
    return 0;
};
const RatingFabric = (props) => {
    const valueRef = props.value;
    const debounceRef = useRef(0);
    const [proxy, setProxy] = useState((typeof valueRef !== "object" && valueRef) || 0);
    const [value, setValue] =
        typeof valueRef === "object"
            ? [
                  debounceRef.current !== 0 ? proxy : assertValue(valueRef, valueRef.value),
                  (val, submit) => {
                      cancelUITimeout(debounceRef.current);
                      setProxy(val);
                      debounceRef.current = scheduleUITimeout(() => {
                          debounceRef.current = 0;
                          assertValue(valueRef, val);
                          if (submit && props.autoSubmit && val) {
                              handleAutoSubmit(autoSubmit);
                          }
                      }, DEBOUNCE_NORMAL);
                  },
              ]
            : [proxy, setProxy];
    const [hover, setHover] = useState(0);
    const items = [];
    const autoSubmit = useRef({
        id: 0,
        cb: props.onSubmit,
    });
    const steps = Num.max(1, props.steps);
    const isDisabled =
        props.disabled || props.readOnly || (typeof valueRef === "object" && (valueRef.isFrozen || valueRef.isLocked)) || false;
    const changeValue = (val, submit) => {
        if (props.disabled || props.readOnly) {
            return;
        }
        val = Num.range(val, 0, steps);
        if (autoSubmit.current.id) {
            clearTimeout(autoSubmit.current.id);
            autoSubmit.current.id = 0;
        }
        setValue(val, submit);
        if (props.onChange) {
            props.onChange(val);
        }
        if (submit && props.autoSubmit && val) {
            handleAutoSubmit(autoSubmit);
        }
    };
    useEffect(() => {
        return () => {
            cancelUITimeout(debounceRef.current);
        };
    }, []);
    for (let i = 1; i <= steps; i++) {
        items.push(
            jsxs(
                RatingShapeElement,
                {
                    ref: (i === (value || 1) && props.onAutoFocus) || undefined,
                    disabled: isDisabled,
                    tabIndex: props.tabIndex,
                    "aria-describedby": props.ariaDescribedBy,
                    onMouseOver: () => setHover(i),
                    onMouseOut: () => setHover(0),
                    onClick: () => changeValue(value === 1 && !props.required ? 0 : i, true),
                    onFocus: props.onFocus,
                    onBlur: props.onBlur,
                    onKeyDown: (e) => {
                        if (e.shiftKey && e.key === "Enter" && props.onSubmit) {
                            e.preventDefault();
                            props.onSubmit();
                        } else if (e.key === "Enter" || e.key === " ") {
                            e.preventDefault();
                            changeValue(value === 1 && !props.required ? 0 : i, true);
                        } else if (e.key === "Escape") {
                            e.currentTarget.blur();
                        } else if (e.key === "Tab") {
                            if (e.shiftKey) {
                                if (props.onCancel && i === 1) {
                                    e.preventDefault();
                                    props.onCancel();
                                }
                            } else if (props.onSubmit && i === steps) {
                                e.preventDefault();
                                props.onSubmit();
                            }
                        } else {
                            if (e.key === "-") {
                                if (value > 0) {
                                    changeValue(value - 1, false);
                                }
                            } else if (e.key === "+") {
                                if (value < steps) {
                                    changeValue(value + 1, false);
                                }
                            } else {
                                const n = e.key.length === 1 ? e.key.charCodeAt(0) - 48 : -1;
                                if (n >= 0 && n <= 9) {
                                    changeValue(value === n ? n - 1 : n, true);
                                }
                            }
                        }
                    },
                    $color: props.styles.color,
                    $scale: props.styles.scale || 1,
                    $hover: !isDisabled && hover >= i,
                    $checked: i <= value,
                    $showLabels: props.showLabels || false,
                    children: [getShape(props.shape || "stars"), props.showLabels && jsx("small", { children: i })],
                },
                i
            )
        );
    }
    autoSubmit.current.cb = props.onSubmit;
    return jsx(RatingElement, { children: items });
};

export { RatingFabric };
