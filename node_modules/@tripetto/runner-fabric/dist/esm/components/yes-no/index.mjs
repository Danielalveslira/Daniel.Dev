import { jsxs, jsx } from "react/jsx-runtime";
import { styled } from "styled-components";
import { useRef, useState, useEffect } from "react";
import { cancelUITimeout, scheduleUITimeout } from "@tripetto/runner";
import { handleAutoSubmit } from "../helpers.mjs";
import { ButtonFabric } from "../button/index.mjs";
import { yesIcon } from "../../icons/yes.mjs";
import { noIcon } from "../../icons/no.mjs";
import { DEBOUNCE_NORMAL } from "../const.mjs";

const YesNoElement = styled.div`
    display: block;
    width: 100%;

    > * {
        display: ${(props) => (props.$alignment === "vertical" && "block") || undefined};
    }

    > * + * {
        margin-top: ${(props) => (props.$alignment === "vertical" && `${props.$margin || 8}px`) || undefined};
    }
`;
const getIcon = (icon) => {
    switch (icon) {
        case "yes":
            return yesIcon;
        case "no":
            return noIcon;
    }
};
const assertValue = (valueRef, reference, labels) => {
    if (reference === "yes" || reference === "no") {
        if (valueRef.reference !== reference) {
            const value = reference === "yes" ? labels.yes.label : labels.no.label;
            valueRef.set(value, reference, value);
        }
        return reference;
    }
    valueRef.clear();
    return "";
};
const YesNoFabric = (props) => {
    const valueRef = props.value;
    const debounceRef = useRef(0);
    const [proxy, setProxy] = useState((typeof valueRef !== "object" && valueRef) || "");
    const [value, setValue] =
        typeof valueRef === "object"
            ? [
                  debounceRef.current !== 0 ? proxy : assertValue(valueRef, valueRef.reference, props),
                  (val) => {
                      cancelUITimeout(debounceRef.current);
                      setProxy(val);
                      debounceRef.current = scheduleUITimeout(() => {
                          debounceRef.current = 0;
                          assertValue(valueRef, val, props);
                          if (props.autoSubmit && val) {
                              handleAutoSubmit(autoSubmit);
                          }
                      }, DEBOUNCE_NORMAL);
                  },
              ]
            : [proxy, setProxy];
    const autoSubmit = useRef({
        id: 0,
        cb: props.onSubmit,
    });
    const changeValue = (val) => {
        if (autoSubmit.current.id) {
            clearTimeout(autoSubmit.current.id);
            autoSubmit.current.id = 0;
        }
        setValue(val || "");
        if (props.onChange) {
            props.onChange(val || "");
        }
        if (typeof valueRef !== "object" && props.autoSubmit && val) {
            handleAutoSubmit(autoSubmit);
        }
    };
    const handleKeyDown = (e, b) => {
        if (
            e.key === "y" ||
            e.key === "Y" ||
            e.key === props.yes.label.charAt(0).toLowerCase() ||
            e.key === props.yes.label.charAt(0).toUpperCase()
        ) {
            e.preventDefault();
            changeValue("yes");
        } else if (
            e.key === "n" ||
            e.key === "N" ||
            e.key === props.no.label.charAt(0).toLowerCase() ||
            e.key === props.no.label.charAt(0).toUpperCase()
        ) {
            e.preventDefault();
            changeValue("no");
        } else if (e.shiftKey && e.key === "Enter" && props.onSubmit) {
            e.preventDefault();
            props.onSubmit();
        } else if (e.key === "Escape") {
            e.currentTarget.blur();
        } else if (e.key === "Tab") {
            if (e.shiftKey) {
                if (b === "yes" && props.onCancel) {
                    e.preventDefault();
                    props.onCancel();
                }
            } else if (b === "no" && props.onSubmit) {
                e.preventDefault();
                props.onSubmit();
            }
        }
    };
    useEffect(() => {
        return () => {
            cancelUITimeout(debounceRef.current);
        };
    }, []);
    autoSubmit.current.cb = props.onSubmit;
    return jsxs(YesNoElement, {
        $alignment: props.styles.alignment,
        $margin: props.styles.margin,
        children: [
            jsx(ButtonFabric, {
                styles: {
                    baseColor: props.yes.color || props.styles.yesColor,
                    mode: value === "yes" ? "fill" : "outline",
                    hover: "outline",
                    outlineSize: props.styles.outlineSize,
                    roundness: props.styles.roundness,
                    scale: props.styles.scale,
                    group: (props.styles.alignment !== "vertical" && "start") || undefined,
                },
                label: props.yes.label,
                icon: props.yes.icon && getIcon(props.yes.icon),
                iconPosition: "left",
                tabIndex: props.tabIndex,
                ariaDescribedBy: props.ariaDescribedBy,
                disabled:
                    props.disabled || props.readOnly || (typeof valueRef === "object" && (valueRef.isFrozen || valueRef.isLocked)) || false,
                onAutoFocus: ((!value || value === "yes") && props.onAutoFocus) || undefined,
                onFocus: props.onFocus,
                onBlur: props.onBlur,
                onKeyDown: (e) => handleKeyDown(e, "yes"),
                onClick: () => changeValue((props.required || value !== "yes") && "yes"),
            }),
            jsx(ButtonFabric, {
                styles: {
                    baseColor: props.no.color || props.styles.noColor,
                    mode: value === "no" ? "fill" : "outline",
                    hover: "outline",
                    outlineSize: props.styles.outlineSize,
                    roundness: props.styles.roundness,
                    scale: props.styles.scale,
                    group: (props.styles.alignment !== "vertical" && "end") || undefined,
                },
                label: props.no.label,
                icon: props.no.icon && getIcon(props.no.icon),
                iconPosition: "right",
                tabIndex: props.tabIndex,
                ariaDescribedBy: props.ariaDescribedBy,
                disabled:
                    props.disabled || props.readOnly || (typeof valueRef === "object" && (valueRef.isFrozen || valueRef.isLocked)) || false,
                onAutoFocus: (value === "no" && props.onAutoFocus) || undefined,
                onFocus: props.onFocus,
                onBlur: props.onBlur,
                onKeyDown: (e) => handleKeyDown(e, "no"),
                onClick: () => changeValue((props.required || value !== "no") && "no"),
            }),
        ],
    });
};

export { YesNoFabric };
