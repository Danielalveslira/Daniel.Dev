/*! Tripetto Form Runner 8.2.0 - Copyright (C) 2024 Tripetto B.V. - All Rights Reserved */

declare module "@tripetto/runner" {
    import * as TripettoRunner from "@tripetto/runner/module";
    export * from "@tripetto/runner/module";
    export { TripettoRunner };
    export default TripettoRunner;
}

declare module "@tripetto/runner/es5" {
    import * as TripettoRunner from "@tripetto/runner/module";
    export * from "@tripetto/runner/module";
    export { TripettoRunner };
    export default TripettoRunner;
}

declare module "@tripetto/runner/module" {
    /** Contains the package name. */
    export const NAME: string;
    /** Contains the version number. */
    export const VERSION: string;
    /** Explicit exports */
    export {
        Context,
        Data,
        Errors,
        IDataValues,
        IMoment,
        Instance,
        ISnapshot,
        IVariable,
        Value,
        IOntologyResumeEvent as IRunnerResumeEvent,
    } from "@tripetto/runner/module/vfsm";
    export { ICondition, IConditionBlock, IDefinition, INode, INodeBlock, IPrologue } from "@tripetto/runner/module/map";
    export { Kinds, Slot } from "@tripetto/runner/module/slots";
    export { TSerializeTypes } from "@tripetto/runner/module/serializer";
    export { Condition } from "@tripetto/runner/lib/conditions/condition";
    export { ConditionBlock } from "@tripetto/runner/lib/conditions/blocks/block";
    export { ConditionBlocksNamespace } from "@tripetto/runner/lib/conditions/blocks/blocks";
    export { IConditionBlockType, TConditionBlock } from "@tripetto/runner/lib/conditions/blocks/type";
    export { Branch } from "@tripetto/runner/lib/branches/branch";
    export { Section } from "@tripetto/runner/lib/sections/section";
    export { Runner } from "@tripetto/runner/lib/runner";
    export { IRunnerProperties } from "@tripetto/runner/lib/properties";
    export { IRunnerChangeEvent, IRunnerRestartEvent } from "@tripetto/runner/lib/events";
    export { Node } from "@tripetto/runner/lib/nodes/node";
    export { NodeBlock } from "@tripetto/runner/lib/nodes/blocks/block";
    export { HeadlessBlock } from "@tripetto/runner/lib/nodes/blocks/headless";
    export { NodeBlocksNamespace } from "@tripetto/runner/lib/nodes/blocks/blocks";
    export { INodeBlockType, TNodeBlock } from "@tripetto/runner/lib/nodes/blocks/type";
    export { IObservableNode } from "@tripetto/runner/lib/storyline/observable";
    export { IBookmark } from "@tripetto/runner/lib/storyline/bookmark";
    export { ISlide } from "@tripetto/runner/lib/storyline/slide";
    export { TChanges } from "@tripetto/runner/lib/changes";
    export { TModes } from "@tripetto/runner/lib/modes";
    export { TStatus } from "@tripetto/runner/lib/status";
    export {
        markdownify,
        markdownifyTo,
        markdownifyToString,
        markdownifyToPlainText,
        markdownifyToURL,
    } from "@tripetto/runner/lib/markdown";
    export { MarkdownFeatures, MarkdownTypes, MarkdownParser } from "@tripetto/runner/module/markdown";
    export { isVariable } from "@tripetto/runner/lib/variables";
    export { Storyline } from "@tripetto/runner/lib/storyline/storyline";
    export { IStoryline } from "@tripetto/runner/lib/storyline/interface";
    export { Moment } from "@tripetto/runner/lib/storyline/moment";
    export { IPage } from "@tripetto/runner/lib/storyline/page";
    export { Import } from "@tripetto/runner/lib/data/import";
    export { Export } from "@tripetto/runner/lib/data/export";
    export { IEpilogueContext as IEpilogue } from "@tripetto/runner/lib/epilogue";
    export { Namespaces, INamespace, mountNamespace, unmountNamespace } from "@tripetto/runner/lib/namespaces";
    export { fingerprint, calculateFingerprintAndStencil } from "@tripetto/runner/lib/fingerprint";
    export { stencil } from "@tripetto/runner/lib/data/stencil";
    export { checksum } from "@tripetto/runner/lib/data/checksum";
    export { powSolve, powVerify, powHashRate, powSpentTime, powDuration } from "@tripetto/runner/lib/data/pow";
    export { licensee, verify } from "@tripetto/runner/lib/licensing";
    /** Decorators */
    export { tripetto, tripetto as block } from "@tripetto/runner/lib/decorators/tripetto";
    export { condition, IConditionHandler, ConditionResult } from "@tripetto/runner/lib/decorators/condition";
    export { validator, IValidatorHandler, ValidatorResult } from "@tripetto/runner/lib/decorators/validate";
    export { destroy, IDestroyHandler } from "@tripetto/runner/lib/decorators/destroy";
    /** Implicit exports */
    export * from "@tripetto/runner/module/callback";
    export * from "@tripetto/runner/module/functional";
    export * from "@tripetto/runner/module/hookup";
    export * from "@tripetto/runner/module/contracts";
    /** Namespace exports */
    export * as Slots from "@tripetto/runner/module/slots";
    export * as SHA2 from "@tripetto/runner/module/sha2";
    export * as AES from "@tripetto/runner/module/aes";
    export * as L10n from "@tripetto/runner/module/l10n";
}

declare module "@tripetto/runner/lib/conditions/condition" {
    /** Dependencies */
    import { Condition as ConditionFactory, Conditions, Context } from "@tripetto/runner/module/vfsm";
    import { Callback } from "@tripetto/runner/module/callback";
    import { Runner } from "@tripetto/runner/lib/runner";
    import { ConditionResult } from "@tripetto/runner/lib/decorators/condition";
    import { ICondition } from "@tripetto/runner/module/map";
    export class Condition extends ConditionFactory<ICondition> {
        /**
         * Creates a new condition instance.
         * @param pConditions Reference to the conditions dispatcher.
         * @param pCondition Reference to the condition properties.
         */
        constructor(pConditions: Conditions, pCondition: ICondition);
        /** Retrieves the identifier of the condition. */
        get id(): string;
        /** Reference to the runner. */
        get runner(): Runner | undefined;
        /**
         * Invoked when the runner wants to verify the condition.
         * @param pContext Reference to the context.
         * @param pCallback Reference to the callback pointer. Pass this pointer as
         * return value to enable the asynchronous condition callback.
         * @return Returns the result of the condition or the callback reference if
         * the condition should be handled asynchronously. Returns `false` when no
         * block is available.
         * @event
         */
        onCondition(pContext: Context, pCallback: Callback<boolean>): ConditionResult;
        /**
         * Invoked when the condition is approved.
         * @param pContext Reference to the context.
         * @event
         */
        onApproved(pContext: Context): void;
    }
}

declare module "@tripetto/runner/lib/conditions/blocks/block" {
    /** Dependencies */
    import { IBranch, ICondition, IConditionBlock, INode, ISection } from "@tripetto/runner/module/map";
    import { Condition } from "@tripetto/runner/lib/conditions/condition";
    import { Context, IVariable, ImmutableValue } from "@tripetto/runner/module/vfsm";
    import { IConditionBlockType } from "@tripetto/runner/lib/conditions/blocks/type";
    import { Kinds, Slot, Slots } from "@tripetto/runner/module/slots";
    import { TSerializeTypes } from "@tripetto/runner/module/serializer";
    export abstract class ConditionBlock<Properties extends {} = {}> {
        /** Contains the type identifier of the block. */
        static readonly identifier: string;
        /** Retrieves the block type. */
        readonly type: IConditionBlockType<ConditionBlock<Properties>>;
        /** Reference to the context. */
        readonly context: Context;
        /**
         * Creates a new condition block instance.
         * @param pCondition Reference to the condition.
         * @param pContext Reference to the context.
         */
        constructor(pCondition: Condition, pContext: Context);
        /** Retrieves the current view mode of the runner. */
        get view(): "live" | "test" | "preview";
        /** Retrieves the condition props. */
        get condition(): Readonly<ICondition>;
        /** Retrieves the block props. */
        get props(): Readonly<Properties & IConditionBlock>;
        /** Retrieves the node props. */
        get node(): Readonly<INode> | undefined;
        /** Retrieves the section props. */
        get section(): Readonly<ISection> | undefined;
        /** Retrieves the branch props. */
        get branch(): Readonly<IBranch> | undefined;
        /** Retrieves a reference to the slots (if the condition is connected to a node). */
        get slots(): Slots | undefined;
        /**
         * Retrieves a slot.
         * @param sId Specifies the slot identifier. If omitted the function
         * tries to find the slot that is attached to the condition block.
         * @return Returns the slot or `undefined` if the slot was not found.
         */
        protected slotOf<S extends Slot = Slot>(sId?: string): S | undefined;
        /**
         * Retrieves an immutable value. You can only retrieve values for the
         * slots of an attached node. If you want to retrieve values from other nodes
         * or for conditions without an attached node, use `immutableValueOf`.
         * @param pReference Optional parameter with a slot reference. If
         * omitted the function tries to find the slot that is attached to the
         * condition block.
         * @param sKind Specifies the slot kind.
         * @return Returns the mutable value or `undefined` if the value was not found.
         */
        protected valueOf<T extends TSerializeTypes, S extends Slot<T> = Slot<T>>(
            pReference?: Slot | string,
            sKind?: Kinds
        ): ImmutableValue<T, S> | undefined;
        /**
         * Retrieves an immutable value. You can retrieve immutable values for any node.
         * @param pReference Optional parameter with a slot instance or identifier. If
         * omitted the function tries to find the slot that is attached to the
         * condition block.
         * @return Returns the immutable value or `undefined` if the value was not found.
         */
        protected immutableValueOf<T extends TSerializeTypes, S extends Slot<T> = Slot<T>>(
            pReference?: Slot | string
        ): ImmutableValue<T, S> | undefined;
        /**
         * Retrieves a variable.
         * @param pReference Specifies the slot reference, value or variable identifier.
         * @return Returns the variable or `undefined` if the variable was not found.
         */
        protected variableFor(
            pReference:
                | Slot
                | {
                      slot: Slot;
                  }
                | string
        ): IVariable | undefined;
        /**
         * Parses the supplied markdown string, replacing all variables with their current values.
         * @param sString Specifies the markdown string to parse.
         * @param sPlaceholder Specifies a string for empty variables (disabled by default).
         * @param bLineBreaks Specifies if line breaks are supported (disabled by default).
         * @return Returns the parsed string.
         */
        protected parseVariables(sString: string, sPlaceholder?: string, bLineBreaks?: boolean): string;
    }
}

declare module "@tripetto/runner/lib/conditions/blocks/blocks" {
    /** Dependencies */
    import { Condition } from "@tripetto/runner/lib/conditions/condition";
    import { ConditionBlock } from "@tripetto/runner/lib/conditions/blocks/block";
    import { Context } from "@tripetto/runner/module/vfsm";
    import { TConditionBlock } from "@tripetto/runner/lib/conditions/blocks/type";
    export class ConditionBlocksNamespace {
        /** Creates a new namespace instance. */
        constructor(sIdentifier: string);
        /** Retrieves the identifier for the namespace. */
        get identifier(): string;
        /**
         * Registers a block.
         * @param pBlock Specifies the block.
         * @param sIdentifier Specifies the block type identifier.
         * @param pAliases Specifies type aliases for the block.
         * @param bLegacyBlock Specifies the block is a Tripetto legacy block.
         */
        register(pBlock: TConditionBlock, sIdentifier: string, pAliases: string[], bLegacyBlock: boolean): void;
        /**
         * Creates a new instance of a condition block for the supplied condition and context.
         * @param pCondition Reference to the condition.
         * @param pContext Reference to the context.
         * @return Returns a condition block instance.
         */
        create<T extends ConditionBlock>(pCondition: Condition, pContext: Context): T | undefined;
    }
}

declare module "@tripetto/runner/lib/conditions/blocks/type" {
    /** Dependencies */
    import { Condition } from "@tripetto/runner/lib/conditions/condition";
    import { ConditionBlock } from "@tripetto/runner/lib/conditions/blocks/block";
    import { Context } from "@tripetto/runner/module/vfsm";
    export interface IConditionBlockType<T extends ConditionBlock> {
        /** Contains the block type identifier. */
        readonly identifier: string;
        /**
         * Creates a new block instance.
         * @param pCondition Reference to the condition.
         * @param pContext Reference to the context.
         */
        new (pCondition: Condition, pContext: Context): T;
    }
    export type TConditionBlock = IConditionBlockType<ConditionBlock>;
}

declare module "@tripetto/runner/lib/branches/branch" {
    /** Dependencies */
    import { Branch as BranchFactory, Context } from "@tripetto/runner/module/vfsm";
    import { IBranch } from "@tripetto/runner/module/map";
    import { Runner } from "@tripetto/runner/lib/runner";
    import { Section } from "@tripetto/runner/lib/sections/section";
    export class Branch extends BranchFactory<IBranch> {
        /** Retrieves the identifier of the branch. */
        get id(): string;
        /** Reference to the runner. */
        get runner(): Runner | undefined;
        /** Reference to the parent section. */
        get section(): Section;
        /**
         * Invoked when the branch condition is requested.
         * @return For now, the branch condition is always true.
         * @event
         */
        onCondition(): boolean;
        /**
         * Invoked when the branch is left.
         * @param pContext Reference to the context.
         * @event
         */
        onLeave(pContext: Context): void;
    }
}

declare module "@tripetto/runner/lib/sections/section" {
    /** Dependencies */
    import { Await } from "@tripetto/runner/module/callback";
    import { Runner } from "@tripetto/runner/lib/runner";
    import { Context, State } from "@tripetto/runner/module/vfsm";
    import { ISection } from "@tripetto/runner/module/map";
    export class Section extends State<ISection> {
        /** Retrieves the identifier of the section. */
        get id(): string;
        /** Reference to the runner. */
        get runner(): Runner;
        /** Retrieves the position of the section in the runner as a percentage. */
        get percentageInRunner(): number;
        /**
         * Retrieves the validation state for the supplied context.
         * @param pContext Reference to the context.
         */
        getValidation(pContext: Context): "unknown" | "pass" | "fail";
        /**
         * Invoked when the enter condition for the section is requested.
         * @event
         */
        onEnterCondition(): boolean;
        /**
         * Invoked when the section is entered.
         * @param pContext Reference to the context.
         * @param pAwait Reference to the await pointer
         * @return Returns the await reference.
         * @event
         */
        onEnter(pContext: Context, pAwait: Await): Await;
        /**
         * Invoked when the section leave condition is requested.
         * @event
         */
        onLeaveCondition(): boolean;
        /**
         * Invoked when the section is left (only for paginated runners).
         * @param pContext Reference to the context.
         * @event
         */
        onLeave(pContext: Context): void;
        /**
         * Invoked when the section is canceled (only for paginated runners).
         * @param pContext Reference to the context.
         * @event
         */
        onCancel(pContext: Context): void;
        /**
         * Invoked when the section needs to be validated.
         * @event
         */
        onValidate(pContext: Context): boolean;
        /**
         * Invoked when the section is validated.
         * @param pContext Reference to the context.
         * @param sResult Specifies the validation state.
         * @param sType Specifies if the validation type.
         * @event
         */
        onValidated(pContext: Context, sResult: "fail" | "pass", sType: "initial" | "revalidate"): void;
        /**
         * Invoked when the section starts or stops evaluating.
         * @param pContext Reference to the context.
         * @param bEvaluating Specifies if the section is evaluating.
         * @event
         */
        onEvaluate(pContext: Context, bEvaluating: boolean): void;
    }
}

declare module "@tripetto/runner/lib/runner" {
    /** Dependencies */
    import { IRunnerProperties } from "@tripetto/runner/lib/properties";
    import { Branch } from "@tripetto/runner/lib/branches/branch";
    import { IDefinition, IPrologue } from "@tripetto/runner/module/map";
    import { Section } from "@tripetto/runner/lib/sections/section";
    import { Condition } from "@tripetto/runner/lib/conditions/condition";
    import { Context, IDataChangeEvent, ISnapshot, Instance, Ontology } from "@tripetto/runner/module/vfsm";
    import { IRunnerChangeEvent, TRunnerEvents } from "@tripetto/runner/lib/events";
    import { Await } from "@tripetto/runner/module/callback";
    import { IStoryline } from "@tripetto/runner/lib/storyline/interface";
    import { Node } from "@tripetto/runner/lib/nodes/node";
    import { NodeBlock } from "@tripetto/runner/lib/nodes/blocks/block";
    import { Storyline } from "@tripetto/runner/lib/storyline/storyline";
    import { TChanges } from "@tripetto/runner/lib/changes";
    import { TModes } from "@tripetto/runner/lib/modes";
    import { TStatus } from "@tripetto/runner/lib/status";
    import { IEpilogueContext } from "@tripetto/runner/lib/epilogue";
    import { INamespace } from "@tripetto/runner/lib/namespaces";
    export class Runner<T extends NodeBlock = NodeBlock, Data = undefined> extends Ontology<
        Section,
        Node<T>,
        Branch,
        Condition,
        IDefinition,
        TRunnerEvents
    > {
        /**
         * Invoked when the runner instance is changed.
         * @event
         */
        onChange?: (pEvent: IRunnerChangeEvent<T>) => void;
        /**
         * Invoked when the collected data of an instance is changed.
         * @event
         */
        onData?: (pInstance: Instance, pDataChangeEvent: IDataChangeEvent) => void;
        /**
         * Invoked when the runner instance finishes.
         * @event
         */
        onFinish?: (pInstance: Instance) => Promise<string | undefined> | boolean;
        /**
         * Invoked when the runner is restarted.
         * @event
         */
        onRestart?: (pInstance: Instance) => void;
        /** Retrieves an initial storyline. */
        static getInitialStoryline<T extends NodeBlock = NodeBlock>(sMode: TModes): IStoryline<T>;
        /**
         * Creates a new runner instance.
         * @param pProps Specifies the properties for the runner instance.
         */
        constructor(pProps: IRunnerProperties<Data>);
        /** Retrieves the namespace for the runner. */
        get namespace(): INamespace;
        /** Retrieves the definition. */
        get definition(): Readonly<IDefinition> | undefined;
        /** Sets the definition. */
        set definition(pDefinition: IDefinition | undefined);
        /** Retrieves a reference to the active instance. */
        get instance(): Instance | undefined;
        /** Retrieves the storyline of the running instance. */
        get storyline(): Storyline<T> | undefined;
        /** Retrieves the name of the definition. */
        get name(): string;
        /** Retrieves the mode of operation. */
        get mode(): TModes;
        /** Sets the operation mode. */
        set mode(sMode: TModes);
        /** Retrieves if the preview mode is enabled. */
        get isPreview(): boolean;
        /** Sets the preview mode. */
        set isPreview(bPreview: boolean);
        /** Retrieves the test flag. */
        get isTest(): boolean;
        /** Sets the test flag. */
        set isTest(bTest: boolean);
        /** Retrieves the status of the runner. */
        get status(): TStatus;
        /** Retrieves if the runner is empty. */
        get isEmpty(): boolean;
        /** Retrieves the prologue of the loaded definition. */
        get prologue(): IPrologue | undefined;
        /** Retrieves the epilogue of the loaded definition. */
        get epilogue(): IEpilogueContext;
        /**
         * Invoked when the runner is updated.
         * @param pInstance Reference to the instance.
         * @param sChange Specifies the type of change.
         * @param pStoryline Contains the storyline (if the instance is running).
         * @event
         */
        protected onInstanceChange(pInstance: Instance, sChange: TChanges, pStoryline: Storyline<T> | undefined): void;
        /**
         * Invoked when an instance is started.
         * @param pInstance Reference to the instance.
         * @event
         */
        protected onInstanceStart(pInstance: Instance): void;
        /**
         * Invoked when the collected data of an instance is changed.
         * @param pInstance Reference to the instance.
         * @param pDataChangeEvent Reference to a value change event.
         * @event
         */
        protected onInstanceData(pInstance: Instance, pDataChangeEvent: IDataChangeEvent): void;
        /**
         * Invoked when an instance is processing.
         * @param pInstance Reference to the instance.
         * @param bProcessing Specifies if the instance is processing.
         * @event
         */
        protected onInstanceProcessing(pInstance: Instance, bProcessing: boolean): void;
        /**
         * Invoked when an instance wants to check if it can step forward.
         * @param pInstance Reference to the instance.
         * @param pSection Reference to the current section.
         * @return Returns `true` if step forward is allowed.
         * @event
         */
        protected onInstanceStepForward(pInstance: Instance, pSection: Section): boolean;
        /**
         * Invoked when the instance is updated.
         * @param pInstance Reference to the instance.
         * @event
         */
        protected onInstanceUpdate(pInstance: Instance): void;
        /**
         * Invoked when an instance is about to finish.
         * @param pInstance Reference to the instance.
         * @param fnFinish A callback function that can be used to control the finish process when you override this event and return `false`.
         * @return Return `true` if the instance finish is allowed or `false` if the instance finish should wait till the callback function is invoked.
         * @event
         */
        protected onInstanceFinishing(pInstance: Instance, fnFinish: (bFinish: boolean, sReference?: string) => void): boolean;
        /**
         * Invoked when an instance ends. This event is always invoked
         * when an instance is finished, stopped or paused.
         * @param pInstance Reference to the instance.
         * @param sType Specifies why the instance has ended. Can be one of the
         * following values:
         * - `finished`: The instance has finished;
         * - `stopped`: The instance was forced to stop;
         * - `paused`: The instance was paused.
         * @event
         */
        protected onInstanceEnd(pInstance: Instance, sType: "finished" | "stopped" | "paused"): void;
        /**
         * Invoked when a section is entered.
         * @param pContext Reference to the context.
         * @param pSection Reference to the section to render.
         * @param pObserver Reference to the await pointer that signals the
         * runner to validate the section and make a step forward. If the
         * mode is set to `progressive` this is done automatically.
         * @event
         */
        onInstanceSection(pContext: Context, pSection: Section, pObserver: Await): void;
        /**
         * Invoked when a section starts or stops evaluating.
         * @param pInstance Reference to the instance.
         * @param pSection Reference to the section that is evaluating.
         * @param bEvaluating Specifies if the section is evaluating.
         * @event
         */
        onInstanceSectionEvaluating(pInstance: Instance, pSection: Section, bEvaluating: boolean): void;
        /**
         * Invoked when a section is left.
         * @param pInstance Reference to the instance.
         * @param sDirection Specifies the step direction.
         * @param pSection Reference to the section that is left.
         * @event
         */
        onInstanceSectionLeave(pInstance: Instance, sDirection: "forward" | "backward", pSection: Section): void;
        /**
         * Invoked when a branch is left.
         * @param pContext Reference to the context.
         * @param pBranch Reference to the branch that is left.
         * @event
         */
        onInstanceBranchLeave(pContext: Context, pBranch: Branch): void;
        /**
         * Invoked when a node is entered.
         * @param pContext Reference to the context.
         * @param pNode Reference to the node to render.
         * @param pObserver Reference to the await pointer that signals the
         * runner to validate the node. If the mode is set to `progressive` this
         * is done automatically.
         * @event
         */
        onInstanceNode(pContext: Context, pNode: Node<T>, pObserver: Await): void;
        /**
         * Invoked when the progress changes.
         * @param pInstance Reference to the instance.
         * @param nPercentage Contains the progress percentage.
         * @event
         */
        onInstanceProgress(pInstance: Instance, nPercentage: number): void;
        /**
         * Invoked when the instance makes a step.
         * @param pInstance Reference to the instance.
         * @param sDirection Specifies the step direction.
         * @event
         */
        onInstanceStep(pInstance: Instance, sDirection: "forward" | "backward"): void;
        /**
         * Invoked when the section is validated.
         * @param pInstance Reference to the instance.
         * @param sResult Specifies the validation state.
         * @param sType Specifies if the validation type.
         * @event
         */
        onInstanceValidated(pInstance: Instance, sResult: "fail" | "pass", sType: "initial" | "revalidate"): void;
        /**
         * Restores a runner snapshot.
         * @param pSnapshot Specifies the snapshot data.
         * @return Returns a reference to the instance.
         */
        restore(pSnapshot: ISnapshot<Data>): Instance | undefined;
        /**
         * Reloads the runner with the specified definition. During a reload
         * the runner tries to maintain any collected data.
         * @param pDefinition Specifies the definition.
         * @param bOnlyRestartWhenRunning Specifies to only restart the runner
         * if it was running before the reload was requested (defaults to `false`).
         * @return Returns the new instance or `undefined` if no new instance was started.
         */
        reload(pDefinition: IDefinition, bOnlyRestartWhenRunning?: boolean): Instance | undefined;
        /**
         * Restarts the runner.
         * @param bPreserveData Specifies if the data of an existing running
         * instance should be preserved (defaults to `false`).
         * @return Returns a reference to the instance.
         */
        restart(bPreserveData?: boolean): Instance;
        /**
         * Rerenders the runner for the specified instance.
         * @param pInstance Reference to the instance.
         */
        rerender(pInstance: Instance): void;
        /**
         * Step forward in the active instance.
         * @return Returns `true` if the step succeeded.
         */
        stepForward(): boolean;
        /**
         * Step backward in the active instance.
         * @return Returns `true` if the step succeeded.
         */
        stepBackward(): boolean;
        /**
         * Step to the start of the active instance.
         * @return Returns `true` if the step succeeded.
         */
        stepToStart(): boolean;
        /**
         * Step to the head in the history of the active instance.
         * @return Returns `true` if the step succeeded.
         */
        stepToHead(): boolean;
        /**
         * Finish the active instance when it is finishable.
         * @return Returns a promise that resolves when the instance was finished.
         */
        finish(): Promise<void> | false;
    }
}

declare module "@tripetto/runner/lib/properties" {
    /** Dependencies */
    import { IDefinition } from "@tripetto/runner/module/map";
    import { Namespace } from "@tripetto/runner/module/l10n";
    import { ISnapshot, Instance } from "@tripetto/runner/module/vfsm";
    import { TModes } from "@tripetto/runner/lib/modes";
    export interface IRunnerProperties<Data = undefined> {
        /** Specifies the definition to load. */
        readonly definition: IDefinition | string;
        /**
         * Specifies the mode of operation. Can be one of the following values:
         * - `paginated`: Render each section on a separate page;
         * - `continuous`: Render all completed sections and the current section on one page;
         * - `progressive`: Render all completed, current and future sections on one page
         * till the point where one of the sections fails validation;
         * - `ahead`: Always render all completed, current, and future sections on one page,
         * regardless of the section's validation result.
         */
        readonly mode: TModes;
        /** Specifies a namespace identifier for the runner. */
        readonly namespace?: string;
        /** Specifies the l10n namespace to use. */
        readonly l10n?: Namespace;
        /**
         * Specifies the bookmarks mode for the runner. Can be one of the following values:
         * - `default`: List sections in chronological order (this is the default behavior);
         * - `group`: Group sections with bookmarks with identical names (section order may not be chronological).
         */
        readonly bookmarks?: "default" | "group";
        /** Specifies if the runner should be started. */
        readonly start?: boolean;
        /** Specifies if the runner should run in preview mode (this will start the runner when the `start`-prop is omitted). */
        readonly preview?: boolean;
        /** Specifies if the runner runs in test mode. */
        readonly test?: boolean;
        /** Specifies the snapshot to restore (this will start the runner when the `start`-prop is omitted). */
        readonly snapshot?: ISnapshot<Data>;
        /** Specifies data for instances. */
        readonly data?: (pInstance: Instance) => void;
    }
}

declare module "@tripetto/runner/lib/events" {
    /** Dependencies */
    import { Runner } from "@tripetto/runner/lib/runner";
    import { IHookPayload, THooks } from "@tripetto/runner/module/hookup";
    import { Instance } from "@tripetto/runner/module/vfsm";
    import { IStoryline } from "@tripetto/runner/lib/storyline/interface";
    import { NodeBlock } from "@tripetto/runner/lib/nodes/blocks/block";
    import { TChanges } from "@tripetto/runner/lib/changes";
    export type TRunnerEvents = "OnChange" | "OnRestart";
    interface IRunnerEvent<H extends THooks, T extends NodeBlock, Data> extends IHookPayload<H> {
        /** Reference to the runner. */
        readonly runner: Runner<T, Data>;
    }
    export interface IRunnerChangeEvent<T extends NodeBlock = NodeBlock, Data = undefined> extends IRunnerEvent<"OnChange", T, Data> {
        /** Specifies the type of change. */
        readonly change: TChanges;
        /** Reference to the instance. */
        readonly instance: Instance | undefined;
        /** Reference to the storyline. */
        readonly storyline: IStoryline<T>;
    }
    export interface IRunnerRestartEvent<T extends NodeBlock = NodeBlock, Data = undefined> extends IRunnerEvent<"OnRestart", T, Data> {
        /** Reference to the instance. */
        readonly instance: Instance;
    }
    export {};
}

declare module "@tripetto/runner/lib/nodes/node" {
    /** Dependencies */
    import { Await, Callback } from "@tripetto/runner/module/callback";
    import { Section } from "@tripetto/runner/lib/sections/section";
    import { INode } from "@tripetto/runner/module/map";
    import { Runner } from "@tripetto/runner/lib/runner";
    import { ConditionResult } from "@tripetto/runner/lib/decorators/condition";
    import { Context, Transducer, Transducers } from "@tripetto/runner/module/vfsm";
    import { ValidatorResult } from "@tripetto/runner/lib/decorators/validate";
    import { NodeBlock } from "@tripetto/runner/lib/nodes/blocks/block";
    import { HeadlessBlock } from "@tripetto/runner/lib/nodes/blocks/headless";
    export class Node<T extends NodeBlock | HeadlessBlock = NodeBlock> extends Transducer<INode> {
        /**
         * Creates a new node instance.
         * @param pNodes Reference to the nodes dispatcher.
         * @param pNode Reference to the node properties.
         */
        constructor(pNodes: Transducers, pNode: INode);
        /** Retrieves the identifier of the node. */
        get id(): string;
        /** Reference to the runner. */
        get runner(): Runner;
        /** Reference to the parent section. */
        get section(): Section;
        /** Retrieves if the node is a visible block. */
        get isVisible(): boolean;
        /**
         * Retrieves the block instance.
         * @param pContext Reference to the context.
         * @return Returns the block instance or `undefined` if the block was not found.
         */
        block(pContext: Context): T | undefined;
        /**
         * Invoked when the runner wants to verify the condition for the node.
         * This event is invoked just before the node is entered.
         * @param pContext Reference to the context.
         * @param pCallback Reference to the callback pointer. Pass this pointer as
         * return value to enable the asynchronous condition callback.
         * @return Returns the result of the condition or the callback reference if
         * the condition should be handled asynchronously.
         * @event
         */
        onEnterCondition(pContext: Context, pCallback: Callback<boolean>): ConditionResult;
        /**
         * Invoked when the node is entered.
         * @param pContext Reference to the context.
         * @param pAwait Reference to the await pointer.
         * @event
         */
        onEnter(pContext: Context, pAwait: Await): Await | void;
        /**
         * Invoked when the node is left.
         * @param pContext Reference to the context.
         * @event
         */
        onLeave(pContext: Context): void;
        /**
         * Invoked when the transducer is canceled.
         * @param pContext Reference to the context.
         * @event
         */
        onCancel(pContext: Context): void;
        /**
         * Invoked when the node needs to be validated.
         * @param pContext Reference to the context.
         * @param sCurrent Specifies the current node validation state.
         * @param pCallback Reference to the callback pointer. Pass this pointer as
         * return value to enable the asynchronous validation callback.
         * @return Returns the result of the validation or the callback reference if
         * the validation should be handled asynchronously.
         * @event
         */
        onValidate(pContext: Context, sCurrent: "unknown" | "fail" | "pass", pCallback: Callback<boolean>): ValidatorResult;
        /**
         * Invoked when the node is validated.
         * @param pContext Reference to the context.
         * @param sResult Specifies the validation result.
         * @param sType Specifies the validation type.
         * @event
         */
        onValidated(pContext: Context, sResult: "fail" | "pass", sType: "initial" | "revalidate"): void;
        /**
         * Invoked when a side effect is generated.
         * @param pContext Reference to the context.
         * @event
         */
        onSideEffect(pContext: Context): void;
    }
}

declare module "@tripetto/runner/lib/nodes/blocks/block" {
    import { Context, IVariable, ImmutableValue, Value } from "@tripetto/runner/module/vfsm";
    import { INode, INodeBlock } from "@tripetto/runner/module/map";
    import { INodeBlockType } from "@tripetto/runner/lib/nodes/blocks/type";
    import { Kinds, Slot } from "@tripetto/runner/module/slots";
    import { Node } from "@tripetto/runner/lib/nodes/node";
    import { TSerializeTypes } from "@tripetto/runner/module/serializer";
    export abstract class NodeBlock<Properties extends {} = {}> {
        /** Contains the type name of the block. */
        static readonly identifier: string;
        /** Contains an optional ref. */
        static readonly ref?: {};
        /** Specifies if the block needs an automatic render upon value store. */
        static readonly autoRender: boolean;
        /** Specifies if the block needs automatic validation. */
        static readonly autoValidate: boolean;
        /** Retrieves the block type. */
        readonly type: INodeBlockType<NodeBlock<Properties>>;
        /** Reference to the context. */
        readonly context: Context;
        /**
         * Creates a new node block instance.
         * @param pNode Reference to the node.
         * @param pContext Reference to the context.
         */
        constructor(pNode: Node, pContext: Context);
        /** Retrieves the current view of the runner. */
        get view(): "live" | "test" | "preview";
        /** Retrieves the validation state of the block. */
        get validation(): "unknown" | "pass" | "fail";
        /** Reference to the node props. */
        get node(): Readonly<INode>;
        /** Contains the block props. */
        get props(): Readonly<Properties & INodeBlock>;
        /** Specifies if an automatic render is needed upon value store. */
        get shouldAutoRender(): boolean;
        /** Specifies if automatic validation is applied. */
        get shouldAutoValidate(): boolean;
        /** Retrieves if the validation of the block failed. */
        get isFailed(): boolean;
        /** Retrieves if the validation of the block passed. */
        get isPassed(): boolean;
        /**
         * Retrieves a slot.
         * @param sReference Specifies the slot reference.
         * @param sKind Specifies the slot kind.
         * @return Returns the slot or `undefined` if the slot was not found.
         */
        protected slotOf<S extends Slot = Slot>(sReference: string, sKind?: Kinds): S | undefined;
        /**
         * Retrieves a mutable value. You can only retrieve mutable values for the
         * slots managed by the block. If you want values from other nodes, use the
         * `immutableValueOf` method.
         * @param pReference Specifies the slot reference.
         * @param sKind Specifies the slot kind.
         * @param pOptions Specifies optional options.
         * @return Returns the mutable value or `undefined` if the value was not found.
         */
        protected valueOf<T extends TSerializeTypes, S extends Slot<T> = Slot<T>>(
            pReference: Slot | string,
            sKind?: Kinds,
            pOptions?: {
                /** Specifies if the slot always has a confirmed value. Use `shallow` to improve performance when confirming a lot of slots at once. */
                readonly confirm?: boolean | "shallow";
                /** Specifies a prefill value. */
                readonly prefill?: {
                    readonly value: TSerializeTypes;
                    readonly reference?: string;
                };
                /** Specifies a modifier function that is invoked when the data is about to change. */
                readonly modifier?: (pValue: Value<T, S>) =>
                    | {
                          readonly value: TSerializeTypes;
                          readonly reference?: string;
                      }
                    | undefined;
                /** Invoked when a value is changed. */
                readonly onChange?: (pValue: Value<T, S>) => void;
                /** Invoked when a value is used within another context. */
                readonly onContext?: (pValue: Value<T, S>, pContext: Context) => void;
            }
        ): Value<T, S> | undefined;
        /**
         * Retrieves an immutable value. You can retrieve immutable values for any node.
         * @param pReference Specifies the slot instance or identifier.
         * @return Returns the immutable value or `undefined` if the value was not found.
         */
        protected immutableValueOf<T extends TSerializeTypes, S extends Slot<T> = Slot<T>>(
            pReference: Slot | string
        ): ImmutableValue<T, S> | undefined;
        /**
         * Retrieves a variable.
         * @param pReference Specifies the slot reference, value or variable identifier.
         * @return Returns the variable or `undefined` if the variable was not found.
         */
        protected variableFor(
            pReference:
                | Slot
                | {
                      slot: Slot;
                  }
                | string
        ): IVariable | undefined;
        /**
         * Parses the supplied markdown string, replacing all variables with their current values.
         * @param sString Specifies the markdown string to parse.
         * @param sPlaceholder Specifies a string for empty variables (disabled by default).
         * @param bLineBreaks Specifies if line breaks are supported (disabled by default).
         * @return Returns the parsed string.
         */
        protected parseVariables(sString: string, sPlaceholder?: string, bLineBreaks?: boolean): string;
        /**
         * Retrieves a unique key for the block within the current context for the
         * specified label (the key is prefixed with an underscore). Use this function
         * if you need stable unique keys (for example to use as element IDs).
         * @param sLabel Optional label for the key (if omitted the default key will
         * be returned).
         * @return Returns the key.
         */
        key(sLabel?: string): string;
        /** Invokes a block rerendering. */
        rerender(): void;
        /** Locks the data values of a block (makes the whole block write-protected). */
        lock(): void;
        /** Unlocks the data values of a block (removes the write-protected flag from the whole block). */
        unlock(): void;
        /** Clears all data values of a block. */
        clear(): void;
    }
}

declare module "@tripetto/runner/lib/nodes/blocks/headless" {
    /** Dependencies */
    import { Await } from "@tripetto/runner/module/callback";
    import { NodeBlock } from "@tripetto/runner/lib/nodes/blocks/block";
    import { Value } from "@tripetto/runner/module/vfsm";
    import { Slot } from "@tripetto/runner/module/slots";
    import { TSerializeTypes } from "@tripetto/runner/module/serializer";
    export abstract class HeadlessBlock<Properties extends {} = {}> extends NodeBlock<Properties> {
        /**
         * Retrieves the mutable value for the supplied slot instance or identifier.
         * @param pReference Specifies the slot instance or identifier.
         * @return Returns the value or `undefined` if no value was found.
         */
        protected mutableValueOf<T extends TSerializeTypes, S extends Slot<T> = Slot<T>>(
            pReference: Slot | string
        ): Value<T, S> | undefined;
        /**
         * Implements the operation for the block.
         * @param pDone Reference to an await pointer that can be used for asynchronous operations.
         */
        abstract do(pDone?: Await): Await | void;
    }
}

declare module "@tripetto/runner/lib/nodes/blocks/blocks" {
    /** Dependencies */
    import { Context } from "@tripetto/runner/module/vfsm";
    import { Node } from "@tripetto/runner/lib/nodes/node";
    import { NodeBlock } from "@tripetto/runner/lib/nodes/blocks/block";
    import { HeadlessBlock } from "@tripetto/runner/lib/nodes/blocks/headless";
    import { TNodeBlock } from "@tripetto/runner/lib/nodes/blocks/type";
    export class NodeBlocksNamespace {
        /** Creates a new namespace instance. */
        constructor(sIdentifier: string);
        /** Retrieves the identifier for the namespace. */
        get identifier(): string;
        /**
         * Registers the supplied block.
         * @param pBlock Specifies the block.
         * @param sIdentifier Specifies the block type identifier.
         * @param pAliases Specifies type aliases for the block.
         * @param pRef Specifies an optional ref to something.
         * @param bAutoRender Specifies if the block needs to be rerendered upon
         * value store (disabled by default).
         * @param bAutoValidate Specifies if the block checks if all required
         * slots contain a value (enabled by default).
         * @param bLegacyBlock Specifies the block is a Tripetto legacy block.
         */
        register(
            pBlock: TNodeBlock,
            sIdentifier: string,
            pAliases: string[],
            bLegacyBlock: boolean,
            pRef?: {},
            bAutoRender?: boolean,
            bAutoValidate?: boolean
        ): void;
        /**
         * Creates a new instance of a node block for the supplied node.
         * @param pNode Reference to the node.
         * @param pContext Reference to the context.
         * @return Returns a node block instance.
         */
        create<T extends NodeBlock | HeadlessBlock>(pNode: Node<T>, pContext: Context): T | undefined;
    }
}

declare module "@tripetto/runner/lib/nodes/blocks/type" {
    /** Dependencies */
    import { Context } from "@tripetto/runner/module/vfsm";
    import { Node } from "@tripetto/runner/lib/nodes/node";
    import { NodeBlock } from "@tripetto/runner/lib/nodes/blocks/block";
    export interface INodeBlockType<T extends NodeBlock> {
        /** Contains the block type identifier. */
        readonly identifier: string;
        /** Optional reference to something. */
        readonly ref?: {};
        /** Specifies if the block needs an automatic render upon value store. */
        readonly autoRender?: boolean;
        /** Specifies if the block needs automatic validation. */
        readonly autoValidate?: boolean;
        /**
         * Creates a new block instance.
         * @param pNode Reference to the node.
         * @param pContext Reference to the context.
         */
        new (pNode: Node, pContext: Context): T;
    }
    export type TNodeBlock = INodeBlockType<NodeBlock>;
}

declare module "@tripetto/runner/lib/storyline/observable" {
    /** Dependencies */
    import { Await } from "@tripetto/runner/module/callback";
    import { Context } from "@tripetto/runner/module/vfsm";
    import { INode } from "@tripetto/runner/module/map";
    import { Node } from "@tripetto/runner/lib/nodes/node";
    import { NodeBlock } from "@tripetto/runner/lib/nodes/blocks/block";
    import { Moment } from "@tripetto/runner/lib/storyline/moment";
    export interface IObservableNode<T extends NodeBlock> {
        /** Contains a unique identifier for the node. */
        readonly id: string;
        /** Contains a unique key for the node within the current context (the key is prefixed with an underscore). */
        readonly key: string;
        /** Reference to the node. */
        readonly node: Node;
        /** Reference to the node properties. */
        readonly props: INode;
        /** Reference to the node block. */
        readonly block: T | undefined;
        /** Reference to the context. */
        readonly context: Context;
        /** Specifies if the node collects data. */
        readonly collectsData: boolean;
        /** Specifies if the node has collected data. */
        readonly hasDataCollected: boolean;
        /**
         * Specifies if the node has changed and needs to be rerendered.
         * @param bReset Specifies if the change flag needs to reset to `false`
         * after this function is invoked (defaults to `true`).
         * @return Returns `true` if the node has changed.
         */
        readonly hasChanged: (bReset?: boolean) => boolean;
        /**
         * Contains the enumerator for the node. Enumerators are only granted to nodes
         * that have a block that collects data.
         */
        readonly enumerator: number | undefined;
        /** Contains the validation state of the node. */
        readonly validation: "unknown" | "pass" | "fail";
        /** Retrieves if the validation of the node failed. */
        readonly isFailed: boolean;
        /** Retrieves if the validation of the node passed. */
        readonly isPassed: boolean;
        /** Reference to the moment. */
        readonly moment: Moment<T>;
        /** Reference to the node observer. */
        readonly observer: Await | undefined;
    }
}

declare module "@tripetto/runner/lib/storyline/bookmark" {
    /** Dependencies */
    import { Context } from "@tripetto/runner/module/vfsm";
    import { NodeBlock } from "@tripetto/runner/lib/nodes/blocks/block";
    import { Section } from "@tripetto/runner/lib/sections/section";
    import { IObservableNode } from "@tripetto/runner/lib/storyline/observable";
    export interface IBookmark<T extends NodeBlock> {
        /** Identifier for the bookmark. */
        readonly id: string;
        /** Reference to the section that defined the bookmark. */
        readonly section: Section | undefined;
        /** Contains the context for the bookmark. */
        readonly context: Context | undefined;
        /** Name for the bookmark (this is the name of the bookmark with any markdown processed). */
        readonly label: string;
        /** Name for the bookmark. */
        readonly name: string;
        /** Description for the bookmark. */
        readonly description: string;
        /** Specifies the bookmark (indentation) level (the first level is `1`). */
        readonly level: number;
        /**
         * Contains the validation state of the bookmark. Can be one of the following
         * values:
         * - `passed`: All nodes (and sub-bookmarks) passed validation;
         * - `partial`: All nodes of the bookmark passed validation, but one or more
         * sub-bookmarks failed;
         * - `failed`: One or more nodes failed validation.
         */
        readonly validation: "passed" | "partial" | "failed";
        /** Contains the nodes in the bookmark. */
        readonly nodes: IObservableNode<T>[];
        /** Specifies any sub-bookmarks. */
        readonly bookmarks: IBookmark<T>[];
    }
}

declare module "@tripetto/runner/lib/storyline/slide" {
    /** Dependencies */
    import { Context } from "@tripetto/runner/module/vfsm";
    import { NodeBlock } from "@tripetto/runner/lib/nodes/blocks/block";
    import { Section } from "@tripetto/runner/lib/sections/section";
    import { IObservableNode } from "@tripetto/runner/lib/storyline/observable";
    import { IBookmark } from "@tripetto/runner/lib/storyline/bookmark";
    export interface ISlide<T extends NodeBlock> {
        /** Contains the index number of the slide. */
        readonly index: number;
        /** Identifier for the slide. */
        readonly id: string;
        /** Reference to the section that defined the slide. */
        readonly section: Section | undefined;
        /** Contains the context for the slide. */
        readonly context: Context | undefined;
        /** Label of the slide (this is the name of the slide with any markdown processed). */
        readonly label: string;
        /** Name of the slide. */
        readonly name: string;
        /** Description of the slide. */
        readonly description: string;
        /** Reference to the slide bookmark. */
        readonly bookmark: IBookmark<T>;
        /** Contains the nodes in the bookmark. */
        readonly nodes: IObservableNode<T>[];
        /** Contains if this is the first slide. */
        readonly isFirst: boolean;
        /** Contains if this is the last slide. */
        readonly isLast: boolean;
        /** Contains if the validation of all nodes in the slide is passed. */
        readonly isPassed: boolean;
        /** Contains if the validation of one the nodes in the slide has failed. */
        readonly isFailed: boolean;
        /** Reference to the previous slide. */
        readonly previous: ISlide<T> | undefined;
        /** Reference to the next slide. */
        readonly next: ISlide<T> | undefined;
    }
}

declare module "@tripetto/runner/lib/changes" {
    export type TChanges =
        | "started"
        | "render"
        | "evaluating"
        | "validated"
        | "forward"
        | "backward"
        | "progress"
        | "finishing"
        | "finished"
        | "stopped"
        | "paused"
        | "mode"
        | "preview";
}

declare module "@tripetto/runner/lib/modes" {
    export type TModes = "paginated" | "continuous" | "progressive" | "ahead";
}

declare module "@tripetto/runner/lib/status" {
    export type TStatus = "idle" | "empty" | "preview" | "running" | "pausing" | "paused" | "stopped" | "finishing" | "finished";
}

declare module "@tripetto/runner/lib/markdown" {
    /** Dependencies */
    import { MarkdownFeatures, MarkdownParser, MarkdownTypes } from "@tripetto/runner/module/markdown";
    import { Context, IVariable } from "@tripetto/runner/module/vfsm";
    /**
     * Creates a markdown parser for the specified markdown text.
     * @param sMarkdown Specifies the markdown text to parse.
     * @param pContext Optional context for the parser.
     * @param pOptions Specifies the markdown options.
     * @return Returns a markdown parser instance.
     */
    export function markdownify(
        sMarkdown: string,
        pContext?: Context,
        pOptions?: {
            /** Specifies the supported markdown features (defaults to `MarkdownFeatures.Formatting | MarkdownFeatures.Hyperlinks`). */
            features?: MarkdownFeatures;
            /** Specifies the placeholder for empty variables. */
            placeholder?: string;
            /** Specifies if line breaks are supported. */
            lineBreaks?: boolean;
        }
    ): MarkdownParser<IVariable>;
    /**
     * Parses a markdown string to a plain text string.
     * @param sMarkdown Specifies the markdown string to parse.
     * @param pContext Optional context for the parser.
     * @param sPlaceholder Specifies a string for empty variables (defaults to `___`).
     * @param bLineBreaks Specifies if line breaks are supported (disabled by default).
     * @param nFeatures Specifies the features to parse (defaults to `MarkdownFeatures.None`).
     * @return Returns a plain text string.
     */
    export function markdownifyToString(
        sMarkdown: string,
        pContext?: Context,
        sPlaceholder?: string,
        bLineBreaks?: boolean,
        nFeatures?: MarkdownFeatures
    ): string;
    /**
     * Parses a markdown string to a valid URL.
     * @param sMarkdown Specifies the markdown string to parse.
     * @param pContext Optional context for the parser.
     * @param sPlaceholder Optional placeholder to use (disabled by default).
     * @param pAllowedDataMIMEs Specifies the MIMEs that are allowed as data URL.
     * @return Returns the URL.
     */
    export function markdownifyToURL(sMarkdown: string, pContext?: Context, sPlaceholder?: string, pAllowedDataMIMEs?: string[]): string;
    /**
     * Reduces or maps a markdown string to a certain structure.
     * @param sMarkdown Specifies the markdown string to parse.
     * @param pContext Specifies the context.
     * @param pOptions Specifies the markdown options.
     * @return Returns the parsed structure.
     */
    export function markdownifyTo<T>(
        sMarkdown: string,
        pContext: Context | undefined,
        pOptions: (
            | {
                  reduce: (sType: MarkdownTypes | undefined, pContent: string | T[], pValue: string | IVariable | undefined) => T;
              }
            | {
                  map: (
                      sType: MarkdownTypes | undefined,
                      sContent: string,
                      pValue: string | IVariable | undefined,
                      pParent: T | undefined,
                      sKind: "root" | "text" | "node"
                  ) => T;
              }
        ) & {
            /** Specifies the supported markdown features (defaults to `MarkdownFeatures.Formatting | MarkdownFeatures.Hyperlinks`). */
            features?: MarkdownFeatures;
            /** Specifies the placeholder for empty variables. */
            placeholder?: string;
            /** Specifies if line breaks are supported (default is `false`). */
            lineBreaks?: boolean;
        }
    ): T;
    /**
     * Converts markdown to plain text, replacing mentions with a placeholder string and removing formatting and hyperlink markdown.
     * @param sMarkdown Specifies the markdown.
     * @return Returns a plain text string.
     */
    export function markdownifyToPlainText(sMarkdown: string): string;
}

declare module "@tripetto/runner/lib/variables" {
    import { Context, ImmutableValue } from "@tripetto/runner/module/vfsm";
    export function localizeVariable(pValue: ImmutableValue, pContext: Context): string | undefined;
    /**
     * Verifies if the supplied input is a possible variable.
     * @param sInput Specifies the input to verify.
     * @return Returns `true` if the input could be a variable.
     */
    export function isVariable(sInput: string | undefined): sInput is string;
}

declare module "@tripetto/runner/lib/storyline/storyline" {
    /** Dependencies */
    import { Section } from "@tripetto/runner/lib/sections/section";
    import { IPrologue } from "@tripetto/runner/module/map";
    import { Instance } from "@tripetto/runner/module/vfsm";
    import { IObservableNode } from "@tripetto/runner/lib/storyline/observable";
    import { IPage } from "@tripetto/runner/lib/storyline/page";
    import { IStoryline } from "@tripetto/runner/lib/storyline/interface";
    import { IStorylineOrchestrator } from "@tripetto/runner/lib/storyline/orchestrator";
    import { IBookmark } from "@tripetto/runner/lib/storyline/bookmark";
    import { ISlide } from "@tripetto/runner/lib/storyline/slide";
    import { Moment } from "@tripetto/runner/lib/storyline/moment";
    import { NodeBlock } from "@tripetto/runner/lib/nodes/blocks/block";
    import { TModes } from "@tripetto/runner/lib/modes";
    import { IEpilogueContext } from "@tripetto/runner/lib/epilogue";
    export class Storyline<T extends NodeBlock = NodeBlock> {
        /**
         * Creates a new storyline.
         * @param pOrchestrator Reference to the storyline orchestrator.
         */
        constructor(pOrchestrator: IStorylineOrchestrator);
        /** Retrieves the storyline checksum. */
        get checksum(): string | undefined;
        /** Retrieves an immutable representation of the storyline. */
        get immutable(): IStoryline<T>;
        /** Retrieves the instance of the storyline. */
        get instance(): Instance;
        /** Retrieves the collection of moments. */
        get moments(): Moment<T>[];
        /** Retrieves the collection of pages (only available in paginated mode). */
        get pages(): IPage[];
        /** Retrieves the active page. */
        get activePage(): IPage | undefined;
        /** Retrieves the observable nodes of the active moments. */
        get nodes(): IObservableNode<T>[];
        /** Retrieves the bookmarks array. */
        get bookmarks(): IBookmark<T>[];
        /** Retrieves the slides array. */
        get slides(): ISlide<T>[];
        /** Retrieves all nodes with their corresponding bookmark. */
        get all(): (IObservableNode<T> & {
            readonly bookmark: IBookmark<T>;
        })[];
        /**
         * Retrieves the observable nodes of the active moments. This property
         * is deprectated. Use `all` instead.
         * @deprecated
         */
        get activeNodes(): IObservableNode<T>[];
        /**
         * Retrieves all the unique observable nodes of the active moments. This
         * property is deprectated. Use `all` instead.
         * @deprecated
         */
        get uniqueNodes(): IObservableNode<T>[];
        /** Retrieves the present moment. */
        get presentMoment(): Moment<T> | undefined;
        /** Retrieves the section of the present moment. */
        get presentSection(): Section | undefined;
        /** Retrieves the observable nodes of the present moment. */
        get presentNodes(): IObservableNode<T>[];
        /** Retrieves if the storyline is evaluating. */
        get isEvaluating(): boolean;
        /** Retrieves if the storyline has changed since the last call of this prop. */
        get isChanged(): boolean;
        /** Retrieves if the storyline is empty (has no observable nodes). */
        get isEmpty(): boolean;
        /** Retrieves if the present moment is at the begin of the storyline. */
        get isAtStart(): boolean;
        /** Retrieves if the present moment is at the head of the storyline. */
        get isAtHead(): boolean;
        /** Retrieves if the present moment is at the finish of the storyline. */
        get isAtFinish(): boolean;
        /** Retrieves if the storyline is finishable using the `finish()` method. */
        get isFinishable(): boolean;
        /** Retrieves if the storyline is finishing. */
        get isFinishing(): boolean;
        /** Retrieves if the storyline is finished. */
        get isFinished(): boolean;
        /** Retrieves if the storyline is pausing. */
        get isPausing(): boolean;
        /** Retrieves if the storyline is paused. */
        get isPaused(): boolean;
        /** Retrieves if the storyline has any data collected. */
        get hasDataCollected(): boolean;
        /** Retrieves if the validation of the storyline failed. */
        get isFailed(): boolean;
        /** Retrieves if the validation of the storyline passed. */
        get isPassed(): boolean;
        /** Retrieves the mode of operation. */
        get mode(): TModes;
        /** Retrieves the most recent step direction of the storyline. */
        get direction(): "forward" | "backward";
        /** Retrieves the total number of observable nodes in the storyline. */
        get count(): number;
        /** Retrieves the total number of observable nodes that have an enumerator value. */
        get enumerators(): number;
        /** Retrieves the progress percentage of the storyline. */
        get percentage(): number;
        /** Retrieves the prologue of the storyline. */
        get prologue(): IPrologue | undefined;
        /** Retrieves the epilogue of the storyline. */
        get epilogue(): IEpilogueContext;
        /** Invalidates the current storyline. */
        invalidate(): void;
        /** Resets the storyline and clears the moments cache. */
        reset(): void;
        /**
         * Maps moments to a certain type.
         * @param fnMoment Specifies the function to invoke for each moment.
         * @returns Returns the resulting array of the map operation.
         */
        map<R>(fnMoment: (pMoment: Moment<T>, nIndex: number) => R): R[];
        /**
         * Step forward in the storyline.
         * @return Returns `true` if the step succeeded.
         */
        stepForward(): boolean;
        /**
         * Step backward in the storyline.
         * @return Returns `true` if the step succeeded.
         */
        stepBackward(): boolean;
        /**
         * Step to the start of the storyline.
         * @return Returns `true` if the step succeeded.
         */
        stepToStart(): boolean;
        /**
         * Step to the head of the storyline.
         * @return Returns `true` if the step succeeded.
         */
        stepToHead(): boolean;
        /**
         * Steps to a page.
         * @param nPage Specifies the page to step to.
         * @return Returns `true` if the step succeeded.
         */
        stepToPage(nPage: number): boolean;
        /**
         * Finish the storyline when it is at the end.
         * @return Returns a promise that resolves when the instance was finished.
         */
        finish(): Promise<void>;
        /**
         * Find the node that belongs to the supplied key.
         * @param sKey Specifies the key to use.
         * @return Returns the node of `undefined` if the node is not found.
         */
        getNodeByKey(sKey: string): IObservableNode<T> | undefined;
        /**
         * Finds the first key for the supplied node identifier.
         * @param sId Specifies the node id.
         * @return Returns the key of the node or `undefined` if the node is not found.
         */
        getKeyByNodeId(sId: string): string | undefined;
    }
}

declare module "@tripetto/runner/lib/storyline/interface" {
    /** Dependencies */
    import { Section } from "@tripetto/runner/lib/sections/section";
    import { IObservableNode } from "@tripetto/runner/lib/storyline/observable";
    import { IPage } from "@tripetto/runner/lib/storyline/page";
    import { Moment } from "@tripetto/runner/lib/storyline/moment";
    import { NodeBlock } from "@tripetto/runner/lib/nodes/blocks/block";
    import { Storyline } from "@tripetto/runner/lib/storyline/storyline";
    import { TModes } from "@tripetto/runner/lib/modes";
    import { IBookmark } from "@tripetto/runner/lib/storyline/bookmark";
    import { ISlide } from "@tripetto/runner/lib/storyline/slide";
    export interface IStory<T extends NodeBlock> {
        /** Storyline instance. */
        readonly storyline: Storyline<T>;
        /** Storyline direction. */
        direction?: "forward" | "backward";
        /** Storyline checksum. */
        checksum?: string;
    }
    export interface IStoryline<T extends NodeBlock = NodeBlock> {
        /** Retrieves the collection of moments. */
        readonly moments: Moment<T>[];
        /** Retrieves the collection of pages (only available in paginated mode). */
        readonly pages: IPage[];
        /** Contains the observable nodes of the active moments. */
        readonly nodes: IObservableNode<T>[];
        /** Contains the bookmarks. */
        readonly bookmarks: IBookmark<T>[];
        /** Retrieves the slides. */
        readonly slides: ISlide<T>[];
        /** Contains all nodes with their corresponding bookmark. */
        readonly all: (IObservableNode<T> & {
            readonly bookmark: IBookmark<T>;
        })[];
        /**
         * Contains the observable nodes of the active moments.
         * @deprecated
         */
        readonly activeNodes: IObservableNode<T>[];
        /**
         * Contains all the unique observable nodes of the active moments.
         * @deprecated
         */
        readonly uniqueNodes: IObservableNode<T>[];
        /** Retrieves the present moment. */
        readonly presentMoment: Moment<T> | undefined;
        /** Contains the section of the present moment. */
        readonly presentSection: Section | undefined;
        /** Contains the observable nodes of the present moment. */
        readonly presentNodes: IObservableNode<T>[];
        /** Retrieves if the storyline is evaluating. */
        readonly isEvaluating: boolean;
        /** Retrieves if the storyline is empty (has no observable nodes). */
        readonly isEmpty: boolean;
        /** Retrieves if the present moment is at the begin of the storyline. */
        readonly isAtStart: boolean;
        /** Retrieves if the present moment is at the head of the storyline. */
        readonly isAtHead: boolean;
        /** Retrieves if the present moment is at the finish of the storyline. */
        readonly isAtFinish: boolean;
        /** Retrieves if the storyline is finishable using the `finish()` method. */
        readonly isFinishable: boolean;
        /** Retrieves if the storyline is finishing. */
        readonly isFinishing: boolean;
        /** Retrieves if the storyline is finished. */
        readonly isFinished: boolean;
        /** Retrieves if the storyline is pausing. */
        readonly isPausing: boolean;
        /** Retrieves if the storyline is paused. */
        readonly isPaused: boolean;
        /** Retrieves if the storyline has any data collected. */
        readonly hasDataCollected: boolean;
        /** Retrieves if the validation of the storyline failed. */
        readonly isFailed: boolean;
        /** Retrieves if the validation of the storyline passed. */
        readonly isPassed: boolean;
        /** Retrieves the mode of operation. */
        readonly mode: TModes;
        /** Retrieves the most recent step direction of the storyline. */
        readonly direction: "forward" | "backward";
        /** Total number of observable nodes in the storyline. */
        readonly count: number;
        /** Total number of observable nodes that have an enumerator value. */
        readonly enumerators: number;
        /** Retrieves the progress percentage of the storyline. */
        readonly percentage: number;
        /** Maps moments to a certain type. */
        readonly map: <R>(fnMoment: (pMoment: Moment<T>, nIndex: number) => R) => R[];
        /** Step forward in the storyline. */
        readonly stepForward: () => boolean;
        /** Step backward in the storyline. */
        readonly stepBackward: () => boolean;
        /** Step to the start of the storyline. */
        readonly stepToStart: () => boolean;
        /** Step to the head of the storyline. */
        readonly stepToHead: () => boolean;
        /** Steps to a page. */
        readonly stepToPage: (nPage: number) => boolean;
        /** Finish the storyline when it is at the finish. */
        readonly finish: () => Promise<void> | false;
    }
}

declare module "@tripetto/runner/lib/storyline/moment" {
    import { Section } from "@tripetto/runner/lib/sections/section";
    import { IMoment } from "@tripetto/runner/module/vfsm";
    import { IObservableNode } from "@tripetto/runner/lib/storyline/observable";
    import { NodeBlock } from "@tripetto/runner/lib/nodes/blocks/block";
    export class Moment<T extends NodeBlock = NodeBlock> {
        /**
         * Creates a new moment.
         * @param pMoment Reference to the moment.
         * @param nEnumerator Specifies the enumerator value.
         */
        constructor(pMoment: IMoment, nEnumerator: number);
        /** Reference to the section. */
        get section(): Section;
        /** Collection of nodes. */
        get nodes(): IObservableNode<T>[];
        /** Retrieves the tense of the moment. */
        get tense(): "past" | "present" | "future";
        /** Retrieves if the moment is in the past. */
        get isPast(): boolean;
        /** Retrieves if the moment is the present moment. */
        get isPresent(): boolean;
        /** Retrieves if the moment is in the future. */
        get isFuture(): boolean;
        /** Retrieves if the moment is evaluating. */
        get isEvaluating(): boolean;
        /** Retrieves if the validation of the section failed. */
        get isFailed(): boolean;
        /** Retrieves if the validation of the section passed. */
        get isPassed(): boolean;
        /** Total number of nodes in the moment. */
        get count(): number;
        /** Total number of nodes that have an enumerator value. */
        get enumerators(): number;
        /** Retrieves the bookmark for the moment. */
        get bookmark():
            | {
                  readonly name: string;
                  readonly description: string;
                  readonly level: number;
              }
            | undefined;
        /** Restores the moment. */
        restore(): void;
    }
}

declare module "@tripetto/runner/lib/storyline/page" {
    export interface IPage {
        /** Contains the page number. */
        readonly number: number;
        /** Contains if the page is active. */
        readonly active: boolean;
        /** Activates the page. */
        readonly activate: () => void;
    }
}

declare module "@tripetto/runner/lib/data/import" {
    /** Dependencies */
    import { Context, IDataImport, Instance } from "@tripetto/runner/module/vfsm";
    import { TSerializeTypes } from "@tripetto/runner/module/serializer";
    export namespace Import {
        interface IDataValues {
            /** Data slot values. */
            readonly values: IDataImport;
        }
        /** Describes the values object. */
        interface IValues {
            readonly [slot: string]: IDataValues | undefined;
        }
        /** Describes an importable field value. */
        interface IFieldValue {
            /** Contains the data value. */
            readonly value: TSerializeTypes;
            /** Contains the data reference. */
            readonly reference?: string;
            /** Contains the display value. */
            readonly display?: string;
            /** Contains the UTC set time of the data. */
            readonly time?: number;
        }
        /** Describes an importable field by its key. */
        interface IFieldByKey extends IFieldValue {
            /** Key of the data field. */
            readonly key: string;
        }
        /** Describes an importable field by name. */
        interface IFieldByName extends IFieldValue {
            /** Contains the name. */
            readonly name: string;
        }
        /**
         * Import data values to the instance.
         * @param pInstanceOrContext Reference to the instance or context.
         * @param pValues Specifies the values to import.
         * @param pSelection Specifies the identifiers of the slots that should be imported.
         * @return Returns `true` if the import succeeded.
         */
        function values(pInstanceOrContext: Instance | Context, pValues: IValues, pSelection?: string[]): boolean;
        /**
         * Import data fields to the supplied form instance.
         * @param pInstanceOrContext Reference to the instance or context.
         * @param pFields Contains the fields to import. You can reference a field
         * by its key or field name.
         * @param sSeparator Specifies the string that is used to separate multiple
         * field names (defaults to ` / `).
         * @param pSelection Specifies the identifiers of the slots that should be imported.
         * @return Returns `true` if the import succeeded.
         */
        function fields(
            pInstanceOrContext: Instance | Context,
            pFields: (IFieldByKey | IFieldByName)[],
            pSelection?: string[],
            sSeparator?: string
        ): boolean;
        /**
         * Imports CSV data. The number of comma-separated fields and their order
         * should exactly match the number of fields and their order in the instance.
         * @param pInstanceOrContext Reference to the instance or context.
         * @param sRecord Specifies the CSV record to import.
         * @param pSelection Specifies the identifiers of the slots that should be imported.
         * @param sDelimiter Specifies the delimiter used in the CSV input (defaults to `,`).
         * @return Returns `true` if the import succeeded.
         */
        function CSV(pInstanceOrContext: Instance | Context, sRecord: string, pSelection?: string[], sDelimiter?: string): boolean;
    }
}

declare module "@tripetto/runner/lib/data/export" {
    /** Dependencies */
    import { Context, IDataValues, Instance } from "@tripetto/runner/module/vfsm";
    import { TSerializeTypes } from "@tripetto/runner/module/serializer";
    import { INode } from "@tripetto/runner/module/map";
    export namespace Export {
        /** Describes the values object. */
        interface IValues {
            readonly [slot: string]:
                | {
                      /** Unique fingerprint of the definition. */
                      readonly fingerprint: string;
                      /** Node */
                      readonly node: {
                          /** Node identifier. */
                          readonly id: string;
                          /** Friendly name of node. */
                          readonly name: string;
                      };
                      /** Block */
                      readonly block: {
                          /** Contains the block type identifier. */
                          readonly type: string;
                          /** Contains the block version. */
                          readonly version: string;
                      };
                      /** Slot. */
                      readonly slot: {
                          /** Slot identifier. */
                          readonly id: string;
                          /** Reference of slot. */
                          readonly reference: string;
                          /** Alias or name of slot. */
                          readonly name: string;
                          /** Slot label. */
                          readonly label: string;
                      };
                      /** Data slot values. */
                      readonly values: IDataValues;
                  }
                | undefined;
        }
        /** Describes the node of a field. */
        interface IExportableFieldNode {
            /** Contains the node identifier. */
            readonly id: string;
            /** Contains the key of the node within the context. */
            readonly key: string;
            /** Contains the context for the node. */
            readonly context: string;
            /** Retrieve a reference to the node props. */
            readonly props: () => INode;
        }
        /** Describes the nested form properties of a field. */
        interface IExportableFieldForm {
            /** Contains the nested form identifier. */
            readonly id: string;
            /** Name of the nested form. */
            readonly name: string | undefined;
            /** Reference of the nested form. */
            readonly reference: string | undefined;
            /** Version of the nested form. */
            readonly version: string | undefined;
            /** Alias of the nested form. */
            readonly alias: string | undefined;
        }
        /** Describes an exportable field. */
        interface IExportableField {
            /** Contains the index number of the field in the form. */
            readonly index: number;
            /** A unique key for the data field. */
            readonly key: string;
            /** Contains the name. */
            readonly name: string;
            /** Contains the block type identifier. */
            readonly type: string;
            /** Contains the block version. */
            readonly version: string;
            /** Contains the node. */
            readonly node: IExportableFieldNode;
            /** Contains the slot reference. */
            readonly slot: string;
            /** Contains the slot data type. */
            readonly datatype: string;
            /** Contains the data as a string. */
            readonly string: string;
            /** Contains the data value. */
            readonly value: TSerializeTypes;
            /** Contains if the data was modified. */
            readonly modified: boolean;
            /** Contains the data reference. */
            readonly reference: string | undefined;
            /** Contains the display value. */
            readonly display: string | undefined;
            /** Contains the UTC set time of the data. */
            readonly time: number | undefined;
            /** Specifies if the field is exportable. */
            readonly exportable: boolean;
            /** Specifies if the field is actionable. */
            readonly actionable: boolean;
            /** Contains the parent nested form that holds this field. */
            readonly form: IExportableFieldForm | undefined;
            /** Contains the tree of parent nested forms that hold this field. */
            readonly forms: IExportableFieldForm[];
        }
        /** Describes the exportable fields. */
        interface IExportables {
            /** Unique fingerprint of the definition. */
            readonly fingerprint: string;
            /** Contains the stencil for the exportable data. */
            readonly stencil: string;
            /** Contains the fields. */
            readonly fields: IExportableField[];
        }
        /** Describes a CSV export. */
        interface ICSV {
            /** Unique fingerprint of the definition. */
            readonly fingerprint: string;
            /** Contains the stencil for the exportable data. */
            readonly stencil: string;
            /** Contains the CSV fields. */
            readonly fields: string;
            /** Contains the CSV record. */
            readonly record: string;
        }
        /** Decribes the data of an actionable nide. */
        interface IActionableData {
            /** A unique key for the data field. */
            readonly key: string;
            /** Contains the name. */
            readonly name: string;
            /** Contains the slot reference. */
            readonly slot: string;
            /** Contains the slot data type. */
            readonly datatype: string;
            /** Contains the data as a string. */
            readonly string: string;
            /** Contains the data value. */
            readonly value: TSerializeTypes;
            /** Contains if the data was modified. */
            readonly modified: boolean;
            /** Contains the data reference. */
            readonly reference: string | undefined;
            /** Contains the display value. */
            readonly display: string | undefined;
            /** Contains the UTC set time of the data. */
            readonly time: number | undefined;
        }
        /** Describes a actionable node. */
        interface IActionableNode {
            /** Contains the node key. */
            readonly key: string;
            /** Contains the block type identifier. */
            readonly type: string;
            /** Contains the block version. */
            readonly version: string;
            /** Contains the node. */
            readonly node: IExportableFieldNode;
            /** Contains the data. */
            readonly data: IActionableData[];
        }
        /** Describes all the actionable nodes. */
        interface IActionables {
            /** Unique fingerprint of the definition. */
            readonly fingerprint: string;
            /** Contains the stencil for the actionable data. */
            readonly stencil: string;
            /** Contains the actionable nodes. */
            readonly nodes: IActionableNode[];
        }
        /** Describes the dataset object that holds a flat list of fields. */
        interface IDataset {
            readonly [key: string]: IExportableField | undefined;
        }
        /** Describes the typed dataset object. */
        interface ITypedDataset {
            readonly [key: string]: ITypedDataset | Partial<IExportableField> | undefined;
        }
        type TTypedDataset<T> = {
            readonly [P in keyof T]?: T[P] extends IExportableField ? IExportableField : TTypedDataset<T[P]>;
        };
        /**
         * Retrieves a collection of all valid values. The values are stored
         * per slot. The key of each value object is the identifier of the slot. The keys
         * for the contextual values are composed using the condition hashes of the
         * context. If the context is global, the key of that value is `*`. If the
         * context is defined by a single condition, the key is the computed
         * hash of the stringified condition data (where the `id` property is set to
         * an empty `string`). If the context is defined by 2 or more conditions, the
         * computed hashes of these conditions are used to calculate a new hash. The
         * computed condition hashes are concatenated in chronological order and then a
         * `SHA2_256` hash is generated for this concatenated string. This hash is
         * used as key.
         * @param pInstanceOrContext Reference to the instance or context.
         * @param pSelection Specifies the identifiers of the slots that should be exported.
         * @return Returns the values.
         */
        function values(pInstanceOrContext: Instance | Context, pSelection?: string[]): IValues;
        /**
         * Retrieves an `IExportables` object with all exportable fields. These are
         * all the fields in the form that are marked as exportable by the form
         * creator. Tripetto uses a slot system to store data. Each block in a form
         * generates one or more slots, and these slots are then filled with values
         * as the respondent fills out the form. This method exports all data slots
         * regardless of whether a value is set for a particular slot or not. If
         * you only want to retrieve the slots that have a value set, use the
         * `exportablesWithData` method.
         * @param pInstanceOrContext Reference to the instance or context.
         * @param pSelection Specifies the identifiers of the slots that should be included.
         * @param sSeparator Specifies the string that is used to separate subject
         * and field names for slots that are part of an iteration (defaults to ` / `).
         * @param bEscape Specifies if the field names needs to be escaped to prevent
         * the use of the separator in the field names. Escaping is only possible when
         * a single-character separator is used (defaults to `false`).
         * @returns Returns an `IExportables` object.
         */
        function exportables(
            pInstanceOrContext: Instance | Context,
            pSelection?: string[],
            sSeparator?: string,
            bEscape?: boolean
        ): IExportables;
        /**
         * Retrieves an `IExportables` object containing all exportable fields that
         * have a value set and therefore contain data. It is identical to the
         * `exportables` method, with the only difference that it only includes
         * fields that contain data (fields that are filled in by the form respondents).
         * @param pInstanceOrContext Reference to the instance or context.
         * @param pSelection Specifies the identifiers of the slots that should be included.
         * @param sSeparator Specifies the string that is used to separate subject
         * and field names for slots that are part of an iteration (defaults to ` / `).
         * @param bEscape Specifies if the field names needs to be escaped to prevent
         * the use of the separator in the field names. Escaping is only possible when
         * a single-character separator is used (defaults to `false`).
         * @returns Returns an `IExportables` object.
         */
        function exportablesWithData(
            pInstanceOrContext: Instance | Context,
            pSelection?: string[],
            sSeparator?: string,
            bEscape?: boolean
        ): IExportables;
        /**
         * Retrieves an `IExportables` object containing all exportable fields that
         * have changed during the lifecycle of the form. It is identical to the
         * `exportables` method, with the only difference that it only includes the
         * fields that are changed. This is useful, for example, if you have a form
         * that is prefilled with data and you are only interested in the fields
         * that have been changed by the form respondent.
         * @param pInstanceOrContext Reference to the instance or context.
         * @param pSelection Specifies the identifiers of the slots that should be included.
         * @param sSeparator Specifies the string that is used to separate subject
         * and field names for slots that are part of an iteration (defaults to ` / `).
         * @param bEscape Specifies if the field names needs to be escaped to prevent
         * the use of the separator in the field names. Escaping is only possible when
         * a single-character separator is used (defaults to `false`).
         * @returns Returns an `IExportables` object.
         */
        function exportablesDiff(
            pInstanceOrContext: Instance | Context,
            pSelection?: string[],
            sSeparator?: string,
            bEscape?: boolean
        ): IExportables;
        /**
         * Retrieves an `IExportables` object with all exportable fields. These are
         * all the fields in the form that are marked as exportable by the form
         * creator. Tripetto uses a slot system to store data. Each block in a form
         * generates one or more slots, and these slots are then filled with values
         * as the respondent fills out the form. This method exports all data slots
         * regardless of whether a value is set for a particular slot or not.
         * @param pInstanceOrContext Reference to the instance or context.
         * @param pSelection Specifies the identifiers of the slots that should be included.
         * @param sSeparator Specifies the string that is used to separate subject
         * and field names for slots that are part of an iteration (defaults to ` / `).
         * @param bEscape Specifies if the field names needs to be escaped to prevent
         * the use of the separator in the field names. Escaping is only possible when
         * a single-character separator is used (defaults to `false`).
         * @returns Returns an `IExportables` object.
         * @deprecated
         */
        function fields(
            pInstanceOrContext: Instance | Context,
            pSelection?: string[],
            sSeparator?: string,
            bEscape?: boolean
        ): IExportables;
        /**
         * Export the exportable fields as name-value pairs.
         * @param reference Reference to the instance, context or an exportables object.
         * @returns Returns an object with name-value pairs.
         */
        function NVPs(reference: Instance | Context | IExportables): {
            readonly [name: string]: string | boolean | number | undefined;
        };
        /**
         * Export the exportable fields as name-value pairs (where the value is a string).
         * @param reference Reference to the instance, context or an exportables object.
         * @param modifier Specifies the values should be casted to strings.
         * @returns Returns an object with name-value pairs (where the value is a string).
         */
        function NVPs(
            reference: Instance | Context | IExportables,
            modifier: "strings"
        ): {
            readonly [name: string]: string;
        };
        /**
         * Export the exportable fields as name-value pairs.
         * @param reference Reference to the instance, context or an exportables object.
         * @param modifier Invoked for each field so you can modify the returned value for each field.
         * @returns Returns an object with name-value pairs.
         */
        function NVPs(
            reference: Instance | Context | IExportables,
            modifier: (field: IExportableField) => string | boolean | number | undefined
        ): {
            readonly [name: string]: string | boolean | number | undefined;
        };
        /**
         * Retrieves the exportable fields in CSV format.
         * @param pInstanceOrContext Reference to the instance or context.
         * @param pSelection Specifies the identifiers of the slots that should be exported.
         * @param sSeparator Specifies the string that is used to separate multiple
         * field names (defaults to ` / `).
         * @param sDelimiter Specifies the delimiter to use in the CSV output (defaults to `,`).
         * @returns Returns a CSV object with the fields and the record.
         */
        function CSV(pInstanceOrContext: Instance | Context, pSelection?: string[], sSeparator?: string, sDelimiter?: string): ICSV;
        /**
         * Retrieves the exportable fields that contain data in CSV format.
         * @param pInstanceOrContext Reference to the instance or context.
         * @param pSelection Specifies the identifiers of the slots that should be exported.
         * @param sSeparator Specifies the string that is used to separate multiple
         * field names (defaults to ` / `).
         * @param sDelimiter Specifies the delimiter to use in the CSV output (defaults to `,`).
         * @returns Returns a CSV object with the fields and the record.
         */
        function CSVWithData(pInstanceOrContext: Instance | Context, pSelection?: string[], sSeparator?: string, sDelimiter?: string): ICSV;
        /**
         * Retrieves the diff data in CSV format. Only fields that have changed are
         * included.
         * @param pInstanceOrContext Reference to the instance or context.
         * @param pSelection Specifies the identifiers of the slots that should be exported.
         * @param sSeparator Specifies the string that is used to separate multiple
         * field names (defaults to ` / `).
         * @param sDelimiter Specifies the delimiter to use in the CSV output (defaults to `,`).
         * @returns Returns a CSV object with the fields and the record.
         */
        function CSVDiff(pInstanceOrContext: Instance | Context, pSelection?: string[], sSeparator?: string, sDelimiter?: string): ICSV;
        /**
         * Retrieves all actionable fields.
         * @param pInstanceOrContext Reference to the instance or context.
         * @returns Returns the actionable fields or `undefined` if there are none.
         */
        function actionables(pInstanceOrContext: Instance | Context): IActionables | undefined;
        /**
         * Exports all fields as a dataset object. A dataset is a flat list of all
         * the fields of a form, where the name (or alias) of each field is used as
         * key. When a field is part of a section or subform that has an alias set,
         * that alias is used to prefix the key of the field. Multiple aliases
         * are separated using the supplied separator.
         * @param pInstanceOrContext Reference to the instance or context.
         * @param sSeparator Specifies the string that is used to separate multiple
         * field names and aliases (defaults to ` / `).
         * @param bEscape Specifies if the field names needs to be escaped to prevent
         * the use of the separator in the field names. Escaping is only possible when
         * a single-character separator is used (defaults to `true`).
         * @returns Returns an `IDataset` object.
         */
        function dataset(pInstanceOrContext: Instance | Context, sSeparator?: string, bEscape?: boolean): IDataset;
        /**
         * Exports all fields to a statically typed recursive dataset object.
         * @param pInstanceOrContext Reference to the instance or context.
         * @returns Returns the statically typed dataset object. All the properties
         * in the returned dataset object are marked as optional and readonly.
         */
        function typedDataset<T extends ITypedDataset = {}>(pInstanceOrContext: Instance | Context): TTypedDataset<T>;
    }
}

declare module "@tripetto/runner/lib/epilogue" {
    import { IEpilogue } from "@tripetto/runner/module/map";
    import { Context } from "@tripetto/runner/module/vfsm";
    export interface IEpilogueContext extends IEpilogue {
        readonly branch?: string;
        readonly context?: Context;
        readonly getRedirect?: () => string | undefined;
    }
}

declare module "@tripetto/runner/lib/namespaces" {
    import { NodeBlocksNamespace } from "@tripetto/runner/lib/nodes/blocks/blocks";
    import { ConditionBlocksNamespace } from "@tripetto/runner/lib/conditions/blocks/blocks";
    export interface INamespace {
        readonly identifier: string;
        readonly nodeBlocks: NodeBlocksNamespace;
        readonly conditionBlocks: ConditionBlocksNamespace;
    }
    export class Namespaces {
        /**
         * Retrieves the namespace for the specified identifier (or the default
         * namespace if the identifier is undefined).
         * @param sIdentifier Specifies the namespace identifier.
         * @return Returns the `INamespace` object.
         */
        static get(sIdentifier?: string): INamespace;
        /**
         * Retrieves if a namespace exists for the specified identifier.
         * @param sIdentifier Specifies the namespace identifier.
         * @return Returns `true` when the namespace is available.
         */
        static isAvailable(sIdentifier: string): boolean;
        /**
         * Mounts (activates) a namespace context.
         * @param sIdentifier Specifies the namespace identifier.
         */
        static mount(sIdentifier: string): void;
        /** Unmounts (deactivates) the active namespace context. */
        static unmount(): void;
        /**
         * Loads a namespace using UMD code.
         * @param sUMD Specifies the UMD code that needs to be loaded.
         * @return Returns `true` if the loading was successful.
         */
        static loadUMD(sUMD: string): boolean;
        /**
         * Loads a namespace from an URL.
         * @param sURL Specifies the URL to load from.
         * @param fnCallback Invoked when the loading is done.
         */
        static loadURL(sURL: string, fnCallback?: (bSucceeded: boolean) => void): void;
        /**
         * Unloads the specified namespace.
         * @param sIdentifier Specifies the identifier of the namespace to unload.
         * @return Returns `true` when the namespace is unloaded.
         */
        static unload(sIdentifier: string): boolean;
    }
    /**
     * Mounts (activates) a namespace context.
     * @param sIdentifier Specifies the namespace identifier.
     */
    export function mountNamespace(sIdentifier: string): void;
    /** Unmounts (deactivates) the active namespace context. */
    export function unmountNamespace(): void;
}

declare module "@tripetto/runner/lib/fingerprint" {
    import { Slot } from "@tripetto/runner/module/slots";
    import { IDefinition } from "@tripetto/runner/module/map";
    import { Branch } from "@tripetto/runner/lib/branches/branch";
    import { Section } from "@tripetto/runner/lib/sections/section";
    import { Condition } from "@tripetto/runner/lib/conditions/condition";
    import { Node } from "@tripetto/runner/lib/nodes/node";
    /** Generates data for the fingerprint. */
    export const fingerprintGenerator: (pRef: Branch | Section | Node | Condition | Slot) => string;
    /** Validates nodes in the stencil. */
    export const stencilValidator: (pNode: Node) => boolean;
    /**
     * Calculates the fingerprint and stencil for the definition.
     * @param definition Specifies the definition.
     * @return Returns the fingerprint and stencil.
     */
    export function calculateFingerprintAndStencil(definition: IDefinition): {
        readonly fingerprint: string;
        readonly stencil: (type: "exportables" | "actionables") => string;
    };
    /**
     * Calculates the fingerprint for the given definition.
     * @param definition Specifies the definition.
     * @return Returns the fingerprint hash.
     */
    export function fingerprint(definition: IDefinition): string;
}

declare module "@tripetto/runner/lib/data/stencil" {
    import { IDefinition } from "@tripetto/runner/module/map";
    import { Context, Instance } from "@tripetto/runner/module/vfsm";
    import { Export } from "@tripetto/runner/lib/data/export";
    /**
     * Calculates the stencil for the given definition, instance, context, or exportables.
     * @param type Specifies the stencil type.
     * @param input Specifies the definition, instance, context or exportables.
     * @return Returns the stencil hash.
     */
    export function stencil(type: "exportables", input: IDefinition | Instance | Context | Export.IExportables): string;
    /**
     * Calculates the stencil for the given definition, instance, context, or actionables.
     * @param type Specifies the stencil type.
     * @param input Specifies the definition, instance, context or actionables.
     * @return Returns the stencil hash.
     */
    export function stencil(type: "actionables", input: IDefinition | Instance | Context | Export.IActionables): string;
}

declare module "@tripetto/runner/lib/data/checksum" {
    import { Context, Instance } from "@tripetto/runner/module/vfsm";
    import { Export } from "@tripetto/runner/lib/data/export";
    /**
     * Calculates the checksum of the data.
     * @param input Specifies the input to use for the checksum calculation.
     * @param trusted Specifies if the input is trusted. When the source is not
     * trusted some components of the checksum require additional calculation and
     * this consumes more resources.
     */
    export function checksum(
        input:
            | Instance
            | Context
            | {
                  exportables: Export.IExportables;
                  actionables: Export.IActionables | undefined;
              },
        trusted: boolean
    ): string;
}

declare module "@tripetto/runner/lib/data/pow" {
    import { Context, Instance } from "@tripetto/runner/module/vfsm";
    import { Export } from "@tripetto/runner/lib/data/export";
    /**
     * Finds a 64 bit nonce that solves the specified difficulty.
     * @param data Specifies the data to find the nonce for.
     * @param difficulty Specifies the difficulty.
     * @param id Optional identifier for the data.
     * @param length Specifies the nonce length (defaults to `16`).
     * @param timeout Specifies a timeout in milliseconds (disabled by default).
     * @param timestamp Specifies the timestamp to use (defaults to current time).
     * @param timestampResolution Specifies if the timestamp has seconds or milliseconds resolution.
     * @returns Returns the nonce.
     */
    export function powSolve(
        data:
            | Instance
            | Context
            | {
                  exportables: Export.IExportables;
                  actionables: Export.IActionables | undefined;
              },
        difficulty: number,
        id?: string,
        length?: 8 | 16 | 24 | 32,
        timeout?: number,
        timestamp?: number,
        timestampResolution?: "seconds" | "milliseconds"
    ): string;
    /**
     * Verifies the supplied nonce.
     * @param nonce Specifies the nonce to verify.
     * @param difficulty Specifies the nonce difficulty.
     * @param validity Specifies the maximum validity period in milliseconds (or `0` to disable).
     * @param data Specifies the data for the nonce.
     * @param id Optional identifier for the data.
     * @return Returns `true` when the nonce is valid.
     */
    export function powVerify(
        nonce: string,
        difficulty: number,
        validity: number,
        data:
            | Instance
            | Context
            | {
                  exportables: Export.IExportables;
                  actionables: Export.IActionables | undefined;
              },
        id?: string
    ): boolean;
    /** Returns the hash rate in kH/s (only available after a nonce is generated). */
    export function powHashRate(): number;
    /** Returns the total amount of milliseconds spent on work. */
    export function powSpentTime(): number;
    /** Returns the duration in milliseconds of the last work. */
    export function powDuration(): number;
}

declare module "@tripetto/runner/lib/licensing" {
    /**
     * Retrieves the licensee of a verified license.
     * @param pkg Specifies the package or packages to verify.
     * @param code Specifies the license code.
     * @param tier Specifies the required tier for the license.
     * @returns Returns the licensee or `undefined` if the license is invalid.
     */
    export function licensee(pkg: string | string[], code: string, tier?: string): string | undefined;
    /**
     * Verifies a license code.
     * @param pkg Specifies the package or packages to verify.
     * @param code Specifies the license code.
     * @param tier Specifies the required tier for the license.
     * @returns Returns `true` if the license is valid.
     */
    export function verify(pkg: string | string[], code: string, tier?: string): boolean;
}

declare module "@tripetto/runner/lib/decorators/tripetto" {
    import { IConditionBlockDecorator } from "@tripetto/runner/lib/conditions/blocks/decorator";
    import { IHeadlessBlockDecorator, INodeBlockDecorator } from "@tripetto/runner/lib/nodes/blocks/decorator";
    import { TConditionBlock } from "@tripetto/runner/lib/conditions/blocks/type";
    import { TNodeBlock } from "@tripetto/runner/lib/nodes/blocks/type";
    /**
     * Defines a node block.
     * @param pProperties Specifies the properties for the block.
     */
    export function tripetto(pProperties: INodeBlockDecorator | IHeadlessBlockDecorator): (pBlock: TNodeBlock) => void;
    /**
     * Defines a condition block.
     * @param pProperties Specifies the properties for the block.
     */
    export function tripetto(pProperties: IConditionBlockDecorator): (pBlock: TConditionBlock) => void;
}

declare module "@tripetto/runner/lib/decorators/condition" {
    /** Dependencies */
    import { Callback } from "@tripetto/runner/module/callback";
    import { ConditionBlock } from "@tripetto/runner/lib/conditions/blocks/block";
    import { NodeBlock } from "@tripetto/runner/lib/nodes/blocks/block";
    export interface IConditionHandler {
        /**
         * Reference to the callback pointer. Pass this pointer as return value of
         * your condition function to enable asynchronous condition callback.
         */
        callback: Callback<boolean>;
    }
    export type ConditionResult = boolean | Callback<boolean>;
    /**
     * Marks the condition function that is invoked when the block is evaluated.
     * The function receives a `IConditionHandler` object.
     * The function should return a value of `ConditionResult`.
     */
    export function condition<T extends NodeBlock | ConditionBlock>(pTarget: T, sFunction: keyof T, pDescriptor?: PropertyDescriptor): void;
}

declare module "@tripetto/runner/lib/decorators/validate" {
    /** Dependencies */
    import { Callback } from "@tripetto/runner/module/callback";
    import { NodeBlock } from "@tripetto/runner/lib/nodes/blocks/block";
    export interface IValidatorHandler {
        /**
         * Reference to the callback instance. Pass this reference as return value
         * to enable the asynchronous validation callback.
         */
        callback: Callback<boolean>;
        /** Contains the current validation state. */
        current: "unknown" | "fail" | "pass";
    }
    export type ValidatorResult = boolean | Callback<boolean>;
    /**
     * Marks the validation function that is invoked when the block is validated.
     * The function receives a `IValidatorHandler` object.
     * The function should return a value of type `ValidatorResult`.
     */
    export function validator<T extends NodeBlock>(pTarget: T, sFunction: keyof T, pDescriptor?: PropertyDescriptor): void;
}

declare module "@tripetto/runner/lib/decorators/destroy" {
    import { NodeBlock } from "@tripetto/runner/lib/nodes/blocks/block";
    export interface IDestroyHandler {
        /** Specifies the reason for the destroy. */
        type: "left" | "canceled";
    }
    /**
     * Marks the destroy function that is invoked when the block is destroyed.
     * The function receives a `IDestroyHandler` object.
     */
    export function destroy<T extends NodeBlock>(pTarget: T, sFunction: keyof T, pDescriptor?: PropertyDescriptor): void;
}

declare module "@tripetto/runner/lib/storyline/orchestrator" {
    /** Dependencies */
    import { Instance } from "@tripetto/runner/module/vfsm";
    import { IPrologue } from "@tripetto/runner/module/map";
    import { IEpilogueContext } from "@tripetto/runner/lib/epilogue";
    import { TModes } from "@tripetto/runner/lib/modes";
    export interface IStorylineOrchestrator {
        /** Instance of the storyline. */
        readonly instance: Instance;
        /** Contains the mode of operation. */
        readonly mode: TModes;
        /** Contains the bookmarks mode. */
        readonly bookmarks: "default" | "group";
        /** Retrieves the checksum. */
        readonly checksum: string | undefined;
        /** Retrieves the direction. */
        readonly direction: "forward" | "backward";
        /** Retrieves the prologue (if any). */
        readonly prologue: IPrologue | undefined;
        /** Retrieves the epilogue (if any). */
        readonly epilogue: IEpilogueContext;
    }
}

declare module "@tripetto/runner/lib/conditions/blocks/decorator" {
    export interface IConditionBlockDecorator {
        /** Specifies to register a condition block. */
        readonly type: "condition";
        /** Specifies the unique type identifier for the block. */
        readonly identifier: string;
        /** Specifies optional type aliases (alternative type identifiers for the block). */
        readonly alias?: string | string[];
        /** Specifies the block namespace(s). */
        readonly namespace?: string | string[];
        /**
         * Specifies that this is a Tripetto legacy block. These blocks were previously
         * registered with the identifier `tripetto-block-<name>`. Later we moved the
         * blocks to the organization scope `@tripetto`. When this property is specified,
         * Tripetto will automatically create an alias for blocks that are in the Tripetto
         * organization scope so their old identifier still works.
         */
        readonly legacyBlock?: true;
    }
}

declare module "@tripetto/runner/lib/nodes/blocks/decorator" {
    export interface INodeBlockDecorator {
        /** Specifies to register a node block. */
        readonly type: "node";
        /** Specifies the unique type identifier for the block */
        readonly identifier: string;
        /** Specifies optional type aliases (alternative type identifiers for the block). */
        readonly alias?: string | string[];
        /** Specifies the block namespace(s). */
        readonly namespace?: string | string[];
        /** Specifies if the block needs to be rerendered upon value store (disabled by default). */
        readonly autoRender?: boolean;
        /** Specifies if the block checks if all required slots contain a value (enabled by default). */
        readonly autoValidate?: boolean;
        /** Optional reference to pass static date to the block. */
        readonly ref?: {};
        /**
         * Specifies that this is a Tripetto legacy block. These blocks were previously
         * registered with the identifier `tripetto-block-<name>`. Later we moved the
         * blocks to the organization scope `@tripetto`. When this property is specified,
         * Tripetto will automatically create an alias for blocks that are in the Tripetto
         * organization scope so their old identifier still works.
         */
        readonly legacyBlock?: true;
    }
    export interface IHeadlessBlockDecorator {
        /** Specifies to register a headless block. */
        readonly type: "headless";
        /** Specifies the unique type identifier for the block. */
        readonly identifier: string;
        /** Specifies optional type aliases (alternative type identifiers for the block). */
        readonly alias?: string | string[];
        /** Specifies the block namespace(s). */
        readonly namespace?: string | string[];
        /**
         * Specifies that this is a Tripetto legacy block. These blocks were previously
         * registered with the identifier `tripetto-block-<name>`. Later we moved the
         * blocks to the organization scope `@tripetto`. When this property is specified,
         * Tripetto will automatically create an alias for blocks that are in the Tripetto
         * organization scope so their old identifier still works.
         */
        readonly legacyBlock?: true;
    }
}

declare module "@tripetto/runner/module/aes" {
    /**
     * Encrypt string data using AES encryption in counter mode and returns the
     * enrypted data as a string in Base64-encoded ASCII format.
     * @param data Specifies the data to encrypt.
     * @param password Specifies the password used to generate the encryption key.
     * @param bits Specifies the number of bits for the key.
     * @param btoa Specifies the function used to generate the Base64-encoded ASCII string with the encrypted data.
     * @returns Returns the encrypted data as a string in Base64-encoded ASCII format.
     */
    export function encrypt(data: string, password: string, bits: 128 | 192 | 256, btoa: (input: string) => string): string;
    /**
     * Decrypts Base64-encoded data using AES in counter mode.
     * @param data Specifies the data to decrypt.
     * @param password Specifies the password used to generate the encryption key.
     * @param bits Specifies the number of bits for the key.
     * @param atob Specifies the function used to decode the Base64-encoded input data.
     * @returns Returns the decrypted data.
     */
    export function decrypt(data: string, password: string, bits: 128 | 192 | 256, atob: (input: string) => string): string;
}

declare module "@tripetto/runner/module/callback" {
    /**
     * Type alias for the callback await function.
     * @param TCallbackAwait.pCallback Reference to the callback.
     */
    export type TCallbackAwait<T> = (pCallback: Callback<T>) => T | Callback<T>;
    /**
     * Type alias for the promise function.
     * @param TPromise.pPromise Contains the promise details.
     */
    export type TPromise<T> = ((pPromise: ICallbackPromise<T>) => void) | undefined;
    /** Defines the promise interface. */
    export interface ICallbackPromise<T> {
        /** Specifies if the await was asynchronous. */
        readonly isAsynchronous: boolean;
        /** Specifies if the await was canceled. */
        readonly isCanceled: boolean;
        /** Specifies the payload which is returned. */
        readonly payload: T | undefined;
    }
    /** Defines the callback properties interface. */
    export interface ICallbackProperties<T> {
        /** Specifies the await function. */
        readonly await: TCallbackAwait<T>;
        /** Specifies the promise function. */
        readonly promise: TPromise<T>;
        /**
         * Specifies if the callback is conditional. In this case the callback
         * condition must be set to true before a callback is accepted. The callback
         * condition can only be used for asynchronous callbacks.
         */
        readonly conditional?: boolean;
        /**
         * Specifies if the callback should be continuous. The callback property
         * `Payload` or function `done()` can be called multiple times.
         */
        readonly continuous?: boolean;
    }
    export class Callback<T> {
        /**
         * Callback template of specified type.
         * @param pProperties Specifies the callback properties.
         * @return Returns a reference to the callback.
         */
        static of<Type>(pProperties: ICallbackProperties<Type>): Callback<Type>;
        /**
         * Creates a new callback.
         * @param pProperties Specifies the callback properties.
         */
        constructor(pProperties: ICallbackProperties<T>);
        /** Retrieves the callback condition state. */
        get condition(): boolean;
        /** Sets the callback condition state. */
        set condition(bCondition: boolean);
        /** Verifies if the callback pointer is alive and still usable. */
        get isAlive(): boolean;
        /** Retrieves the promise invoke count. */
        get promiseCount(): number;
        /**
         * Terminates the callback.
         * @return Returns `true` if the callback loop is terminated.
         */
        protected terminate(): boolean;
        /**
         * Cancels the callback loop.
         * @return Returns `true` if the callback loop is terminated.
         */
        cancel(): boolean;
        /** Sets the return payload of the callback function. */
        return(pPayload: T | undefined): T | undefined;
    }
    /**
     * Type alias for the await function.
     * @param TAwait.pAwait Reference to the await.
     */
    export type TAwait = (pAwait: Await) => void | Await;
    /** Defines the promise interface. */
    export interface IAwaitPromise extends ICallbackPromise<void> {}
    /** Defines the callback properties interface. */
    export interface IAwaitProperties {
        /** Specifies the await function. */
        readonly await: TAwait;
        /** Specifies the promise function. */
        readonly promise: TPromise<void>;
        /**
         * Specifies if the callback is conditional. In this case the callback
         * condition must be set to true before a callback is accepted. The callback
         * condition can only be used for asynchronous callbacks.
         */
        readonly conditional?: boolean;
        /**
         * Specifies if the callback should be continuous. The callback function
         * `done()` can be called multiple times.
         */
        readonly continuous?: boolean;
    }
    export class Await extends Callback<void> {
        /**
         * Await for.
         * @param pProperties Specifies the await properties.
         * @return Returns a reference to the await.
         */
        static for(pProperties: IAwaitProperties): Await;
        /**
         * Creates a new await.
         * @param pProperties Specifies the await properties.
         */
        constructor(pProperties: IAwaitProperties);
        /**
         * Terminates the await.
         * @return Returns `true` if the await loop is terminated.
         */
        done(): boolean;
    }
}

declare module "@tripetto/runner/module/functional" {
    export type TAny = any;
    export type TArguments = TAny[];
    /** Describes an object. */
    export interface IObject {
        [name: string]: TAny;
    }
    /** Describes a collection. */
    export interface ICollection<T> {
        /** Contains the number of items in the collection. */
        length: number;
        /** Retrieves the item at the specified index. */
        item(nIndex: number): T;
    }
    /** Describes an enumerable object. */
    export interface IEnumerable<T> {
        [name: string]: T;
    }
    /** Type definition for lists (arrays, collections or enumerable objects). */
    export type TList<T> = T[] | ICollection<T> | IEnumerable<T>;
    /** Does nothing. */
    export function noop(): void;
    /**
     * Validates if the supplied variable is undefined.
     *
     * #### Example
     * ```typescript
     * isUndefined(1); // Returns `false`
     * isUndefined(); // Returns `true`
     * ```
     *
     * @param pVariable Variable to validate.
     * @return Returns `true` if the variable is undefined.
     */
    export function isUndefined(pVariable: TAny): pVariable is undefined;
    /**
     * Validates if the supplied variable is defined.
     *
     * #### Example
     * ```typescript
     * isDefined(1); // Returns `true`
     * isDefined(); // Returns `false`
     * ```
     *
     * @param pVariable Variable to validate.
     * @return Returns `true` if the variable is defined.
     */
    export function isDefined(pVariable: TAny): boolean;
    /**
     * Validates if the supplied variable is `null`. Please consider the use of
     * `null`. TypeScript has two bottom types: `null` and `undefined`. They are
     * intented to mean different things:
     * - Something hasn't been initialized: `undefined`
     * - Something is current unavailable: `null`
     * Most other languages only have one (commonly called `null`). Since by default
     * JavaScript will evaluate an uninitialized variable/parameter/property to
     * `undefined` (you don't get a choice) we recommend you just use that for your
     * own unavailable status and don't bother with `null`.
     *
     * #### Example
     * ```typescript
     * isNull(null); // Returns `true`
     * isNull(undefined); // Returns `true`
     * isNull({}); // Returns `false`
     * ```
     *
     * @param pVariable Variable to validate.
     * @return Returns `true` if the variable is `null`.
     */
    export function isNull(pVariable: TAny): pVariable is null;
    /**
     * Validates if the supplied variable is an object and is available (not `null`
     * or `undefined`).
     *
     * #### Example
     * ```typescript
     * isObject({}); // Returns `true`
     * isObject([]); // Returns `false`
     * isObject(null); // Returns `false`
     * isObject(undefined); // Returns `false`
     * ```
     *
     * @param pObject Variable to validate.
     * @return Returns `true` if the variable is an object.
     */
    export function isObject(pObject: TAny): pObject is {
        [property: string]: TAny;
    };
    /**
     * Validates if the supplied variable is a function.
     *
     * #### Example
     * ```typescript
     * isFunction(() => {}); // Returns `true`
     * ```
     *
     * @param pFunction Variable to validate.
     * @return Returns `true` if the variable is a function.
     */
    export function isFunction(pFunction: TAny): pFunction is (...pArguments: TAny[]) => void | TAny;
    /**
     * Validates if the supplied variable is a string.
     *
     * #### Example
     * ```typescript
     * isString("1"); // Returns `true`
     * isString(1); // Returns `false`
     * ```
     *
     * @param pString Variable to validate.
     * @return Returns `true` if the variable is a string.
     */
    export function isString(pString: TAny): pString is string;
    /**
     * Returns the length of the supplied string.
     *
     * #### Example
     * ```typescript
     * stringLength("ABC"); // Returns `3`
     * stringLength(1); // Returns `0`
     * ```
     *
     * @param pString Specifies the string.
     * @return Returns the length of the string or `0` if the supplied variable is not a valid string or an empty string.
     */
    export function stringLength(pString: TAny): number;
    /**
     * Validates if the supplied variable is a string which is not empty.
     *
     * #### Example
     * ```typescript
     * isFilledString("ABC"); // Returns `true`
     * isFilledString(""); // Returns `false`
     * isFilledString(1); // Returns `false`
     * ```
     *
     * @param pString Variable to validate.
     * @return Returns `true` if the variable is a string with content.
     */
    export function isFilledString(pString: TAny): pString is string;
    /**
     * Validates if the supplied variable is a number (finite or infinite). To make sure the supplied number is a valid finite number, use
     * `isNumberFinite`.
     *
     * #### Example
     * ```typescript
     * isNumber(1); // Returns `true`
     * isNumber(Infinity); // Returns `true`
     * isNumber(NaN); // Returns `false`
     * isNumber("1"); // Returns `false`
     * ```
     *
     * @param pNumber Variable to validate.
     * @return Returns `true` if the variable is a number.
     */
    export function isNumber(pNumber: TAny): pNumber is number;
    /**
     * Validates if the supplied variable is a finite number and optionally checks if the number is within the specified range.
     *
     * #### Example
     * ```typescript
     * isNumberFinite(1); // Returns `true`
     * isNumberFinite(Infinity); // Returns `false`
     * isNumberFinite(NaN); // Returns `false`
     * isNumberFinite("1"); // Returns `false`
     * ```
     *
     * @param pNumber Variable to validate.
     * @param nRangeLower Optional parameter which specifies the lower range.
     * @param nRangeUpper Optional parameter which specifies the upper range.
     * @return Returns `true` if the variable is a number.
     */
    export function isNumberFinite(pNumber: TAny, nRangeLower?: number, nRangeUpper?: number): pNumber is number;
    /**
     * Validates if the supplied variable is a floating point number and optionally checks if the number is within the specified range.
     *
     * #### Example
     * ```typescript
     * isFloat(1.01); // Returns `true`
     * isFloat(1); // Returns `false`
     * isFloat(Infinity); // Returns `false`
     * isFloat(NaN); // Returns `false`
     * isFloat("1"); // Returns `false`
     * ```
     *
     * @param pFloat Variable to validate.
     * @param fRangeLower Optional parameter which specifies the lower range.
     * @param fRangeUpper Optional parameter which specifies the upper range.
     * @return Returns `true` if the variable is a floating point number.
     */
    export function isFloat(pFloat: TAny, fRangeLower?: number, fRangeUpper?: number): pFloat is number;
    /**
     * Validates if the supplied variable is a boolean.
     *
     * #### Example
     * ```typescript
     * isBoolean(false); // Returns `true`
     * isBoolean(1); // Returns `false`
     * ```
     *
     * @param pBool Variable to validate.
     * @return Returns `true` if the variable is a boolean.
     */
    export function isBoolean(pBool: TAny): pBool is boolean;
    /**
     * Validates if the supplied variable is an array.
     *
     * #### Example
     * ```typescript
     * isArray([]); // Returns `true`
     * isArray([1]); // Returns `true`
     * isArray(new Array()); // Returns `true`
     * isArray({}); // Returns `false`
     * ```
     *
     * @param pArray Variable to validate.
     * @return Returns `true` if the variable is an array.
     */
    export function isArray<T>(pArray: TAny): pArray is T[];
    /**
     * Validates if the supplied variable is a collection. A collection is a list
     * which is enumerable using a `length` property and an `item` function.
     * @param pCollection Variable to validate.
     * @return Returns `true` if the variable is a collection.
     */
    export function isCollection(pCollection: TAny): boolean;
    /**
     * Validates if the supplied variable is an array or a collection.
     * @param pArray Variable to validate.
     * @return Returns `true` if the variable is an array or collection.
     */
    export function isArrayOrCollection(pArray: TAny): boolean;
    /**
     * Returns the array size for the supplied array or the number of items in the object.
     *
     * #### Example
     * ```typescript
     * arraySize([]); // Returns `0`
     * arraySize([1, 2, 3]); // Returns `3`
     * ```
     *
     * @param pArray Specifies the array.
     * @return Returns the size of the array/object as a number.
     */
    export function arraySize(pArray: TAny): number;
    /**
     * Returns the item at the specified index in the array, collection or
     * enumerable object.
     *
     * #### Example
     * ```typescript
     * arrayItem<number>([1, 2, 3], 2); // Returns `3`
     * arrayItem<number>([1, 2, 3], 3); // Returns `undefined`
     * arrayItem<number>([1, 2, 3], 3, 0); // Returns `0`
     * ```
     *
     * @param T Specifies the item type.
     * @param pArray Specifies the array, collection or enumerable object.
     * @param nIndex Specifies the zero based item index.
     * @param pDefault Optional parameter which specifies the default value if the
     * supplied index is invalid.
     * @return Returns the item at the specified index.
     */
    export function arrayItem<T>(pArray: TList<T> | undefined, nIndex: number, pDefault?: T): T | undefined;
    /**
     * Returns the first item in the array, collection or enumerable object.
     *
     * #### Example
     * ```typescript
     * firstArrayItem<number>([1, 2, 3]); // Returns `1`
     * ```
     *
     * @param T Specifies the item type.
     * @param pArray Specifies the array, collection or enumerable object.
     * @param pDefault Optional parameter which specifies the default value if there
     * is no first item.
     * @return Returns the last item.
     */
    export function firstArrayItem<T>(pArray: TList<T> | undefined, pDefault?: T): T | undefined;
    /**
     * Returns the last item in the array, collection or enumerable object.
     *
     * #### Example
     * ```typescript
     * lastArrayItem<number>([1, 2, 3]); // Returns `3`
     * ```
     *
     * @param T Specifies the item type.
     * @param pArray Specifies the array, collection or enumerable object.
     * @param pDefault Optional parameter which specifies the default value if there
     * is no last item.
     * @return Returns the last item.
     */
    export function lastArrayItem<T>(pArray: TList<T> | undefined, pDefault?: T): T | undefined;
    /**
     * Validates if the supplied variable is a date.
     *
     * #### Example
     * ```typescript
     * isDate(new Date()); // Returns `true`
     * ```
     *
     * @param pDate Variable to validate.
     * @return Returns `true` if the variable is a date.
     */
    export function isDate(pDate: TAny): pDate is Date;
    /**
     * Validates if the supplied variable is a regular expression.
     *
     * #### Example
     * ```typescript
     * isRegEx(/[a-z]+/); // Returns `true`
     * ```
     *
     * @param pRegEx Variable to validate.
     * @return Returns `true` if the variable is a regular expression.
     */
    export function isRegEx(pRegEx: TAny): pRegEx is RegExp;
    /**
     * Validates if the supplied variable is an error object.
     *
     * #### Example
     * ```typescript
     * isError(new Error("Test message")); // Returns `true`
     * ```
     *
     * @param pError Variable to validate.
     * @return Returns `true` if the variable is an error object.
     */
    export function isError(pError: TAny): pError is Error;
    /**
     * Validates if the supplied variable is a promise.
     *
     * #### Example
     * ```typescript
     * isPromise(new Promise(() => {})); // Returns `true`
     * ```
     *
     * @param pPromise Variable to validate.
     * @return Returns `true` if the variable is a promise instance.
     */
    export function isPromise<T>(pPromise: TAny): pPromise is Promise<T>;
    /**
     * Verifies if the supplied value is defined. If not, an error is thrown.
     * @param pAssert Specifies the value to assert.
     * @param sError Specifies the optional error message that is thrown.
     * @return Returns the value.
     */
    export function assert<T>(pAssert: T | undefined, sError?: string): T;
    /**
     * Cast variable to the desired type without type checking.
     * @param pSource Specifies the source.
     * @return Returns the desired type.
     */
    export function cast<To>(pSource: TAny): To;
    /**
     * Cast a variable to a string.
     *
     * #### Example
     * ```typescript
     * castToString(1); // Returns `1`
     * castToString(1.2); // Returns `1.2`
     * castToString(undefined); // Returns ``
     * ```
     *
     * @param pValue Source variable.
     * @param sDefault Optional parameter which specifies the default string if the supplied source variable cannot be casted.
     * @return Returns the string value.
     */
    export function castToString(pValue: TAny, sDefault?: string): string;
    /**
     * Cast a variable to a rounded number.
     *
     * #### Example
     * ```typescript
     * castToNumber("1"); // Returns `1`
     * castToNumber("1.5"); // Returns `2`
     * castToNumber(undefined); // Returns `0`
     * ```
     *
     * @param pValue Source variable.
     * @param nDefault Optional parameter which specifies the default number if the supplied source variable cannot be casted.
     * @return Returns the number value.
     */
    export function castToNumber(pValue: TAny, nDefault?: number): number;
    /**
     * Cast a variable to a floating point number.
     *
     * #### Example
     * ```typescript
     * castToFloat("1"); // Returns `1`
     * castToFloat("1.5"); // Returns `1.5`
     * castToFloat(undefined); // Returns `0`
     * ```
     *
     * @param pValue Source variable.
     * @param fDefault Optional parameter which specifies the default floating point number if the supplied source variable cannot be casted.
     * @return Returns the floating point number value.
     */
    export function castToFloat(pValue: TAny, fDefault?: number): number;
    /**
     * Cast a variable to a boolean value.
     *
     * #### Example
     * ```typescript
     * castToBoolean(1); // Returns `true`
     * castToBoolean("true"); // Returns `true`
     * castToBoolean("false"); // Returns `false`
     * ```
     *
     * @param pValue Source variable.
     * @param bDefault Optional parameter which specifies the default boolean value if the supplied source variable cannot be casted.
     * @return Returns the boolean value.
     */
    export function castToBoolean(pValue: TAny, bDefault?: boolean): boolean;
    /**
     * Clones an object.
     *
     * #### Example
     * ```typescript
     * clone({ a: 1, b: 2 }); // Returns `{ a: 1, b: 2 }`
     * ```
     *
     * @param pObject Specifies the object to clone.
     * @return Returns a clone of the object which is no reference to the original object.
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create
     */
    export function clone<T extends IObject>(pObject: T): T;
    /**
     * Extend an object by appending all of the properties from each supplied
     * object. When there are identical properties, the right-most property takes
     * precedence. This function returns a mutable object reference which is the
     * supplied `pObject` (the first function argument).
     *
     * #### Example
     * ```typescript
     * extend({ a: 1, b: 2 }, { b: 3, d: 4 }, { d: 5 }); // Returns `{ a: 1, b: 3, d: 5 }`
     * ```
     *
     * @param pObject Specifies the object to extend.
     * @param pObjects Specifies the objects to extend with.
     * @return Returns the extended mutable object which is a reference to `pObject`.
     */
    export function extend<T extends IObject>(pObject: Partial<T>, ...pObjects: (Partial<T> | undefined)[]): T;
    /**
     * Extend an object by appending all of the properties from each supplied
     * object. When there are identical properties, the right-most property takes
     * precedence. This function returns a immutable object reference which is
     * basically a new combined copy of the supplied objects.
     *
     * #### Example
     * ```typescript
     * extendImmutable({ a: 1, b: 2, c }, { b: 3, d: 4 }, { d: 5 }); // Returns `{ a: 1, b: 3, d: 5 }`
     * ```
     *
     * @param pObjects Specifies the objects to extend the immutable object with.
     * @return Returns the extended immutable object.
     */
    export function extendImmutable<T extends IObject>(...pObjects: (Partial<T> | undefined)[]): T;
    /**
     * Does a type or value comparison of two variables or a structure.
     *
     * #### Example
     * ```typescript
     * compare({ a: 1, b: 2 }, { a: 1, b: 3 }, false); // Returns `true`
     * compare({ a: 1, b: 2 }, { a: 1, c: 3 }, false); // Returns `false`
     * compare({ a: 1, b: 2 }, { a: 1, b: 3 }, true); // Returns `false`
     * compare({ a: 1, b: 2 }, { a: 1, b: 2 }, true); // Returns `true`
     * ```
     *
     * @param pA Specifies the first variable.
     * @param pB Specifies the second variable.
     * @param bCompareValues Specifies if the values or just the structure needs to be compared.
     * @return Returns `true` if the objects are identical.
     */
    export function compare(pA: TAny, pB: TAny, bCompareValues: boolean): boolean;
    /**
     * Iterates through an array, collection or enumerable object and invokes the
     * supplied function for each element.
     *
     * #### Example
     * ```typescript
     * let nResult = 0;
     * each([1, 2, 3], (nItem: number) => nResult += nItem);
     * // The value of `nResult` is `6`
     * ```
     *
     * @param T Specifies the item type.
     * @param pList Specifies the array, collection or enumerable object to iterate
     * through.
     * @param fnCallee Specifies the function to be invoked for each element. The
     * element value will be exposed to the function as the first argument of the
     * argument list. Additional arguments can be specified and will be pushed to
     * the function.
     * @param fnCallee.pItem Contains the item.
     * @param fnCallee.pArguments Optional additional arguments. These are the
     * additional arguments which are passed to the main function.
     * @param pOptions Specifies the options.
     * @return Returns a reference to the list.
     */
    export function each<T>(
        pList: TList<T> | undefined,
        fnCallee: (pItem: T, ...pArguments: TArguments) => T | void,
        pOptions?: {
            /**
             * Specifies if each value in the array should be overwritten
             * with the return value of its executed function.
             */
            replace?: boolean;
            /**
             * Specifies if the item key should be passed as first argument in the
             * argument list of the function.
             */
            keys?: boolean;
            /**
             * Optional additional arguments which will be passed to the callee.
             */
            arguments?: TArguments;
        }
    ): TList<T> | undefined;
    /**
     * Iterates through an array, collection or enumerable object in reverse and
     * invokes the supplied function for each element.
     *
     * #### Example
     * ```typescript
     * let sResult = "";
     * eachReverse([1, 2, 3], (nItem: number) => nResult += CastToString(nItem));
     * // The value of `sResult` is `321`
     * ```
     *
     * @param T Specifies the item type.
     * @param pList Specifies the array, collection or enumerable object to iterate
     * through.
     * @param fnCallee Specifies the function to be invoked for each element. The
     * element value will be exposed to the function as the first argument of the
     * argument list. Additional arguments can be specified and will be pushed to
     * the function.
     * @param fnCallee.pItem Contains the item.
     * @param fnCallee.pArguments Optional additional arguments. These are the
     * additional arguments which are passed to the main function.
     * @param pOptions Specifies the options.
     * @return Returns a reference to the list.
     */
    export function eachReverse<T>(
        pList: TList<T> | undefined,
        fnCallee: (pItem: T, ...pArguments: TArguments) => T | void,
        pOptions?: {
            /**
             * Specifies if each value in the array should be overwritten
             * with the return value of its executed function.
             */
            replace?: boolean;
            /**
             * Specifies if the item key should be passed as first argument in the
             * argument list of the function.
             */
            keys?: boolean;
            /**
             * Optional additional arguments which will be passed to the callee.
             */
            arguments?: TArguments;
        }
    ): TList<T> | undefined;
    /**
     * Produces a new array of values by mapping each value in the supplied array,
     * collection or enumerable object through a transformation function.
     *
     * #### Example
     * ```typescript
     * map<number, number>([1, 2, 3], (nItem: number) => nItem * nItem); // Returns `[1, 4, 9]`
     * map<number, number>([1, 2, 3], (nItem: number, nMultiplier: number) => nItem * nMultiplier, 2); // Returns `[2, 4, 6]`
     * ```
     *
     * @param T Specifies the item type.
     * @param R Specifies the return type.
     * @param pList Specifies the array, collection or enumerable object to iterate
     * through.
     * @param fnTransformation Specifies the function to be invoked for each
     * element. The element value will be exposed to the function as the first
     * argument of the argument list. Additional arguments can be specified and will
     * be pushed to the function.
     * @param fnTransformation.pItem Contains the item.
     * @param fnTransformation.pArguments Optional additional arguments. These are
     * the additional arguments which are passed to the main function.
     * @param pArguments Optional additional arguments which will be passed to the
     * callee.
     * @return Returns an array with mapped values.
     */
    export function map<T, R>(
        pList: TList<T> | undefined,
        fnTransformation: (pItem: T, ...pArguments: TArguments) => R,
        ...pArguments: TArguments
    ): R[];
    /**
     * Reduce boils down an array, collection or enumerable object into a
     * single value of type `R`.
     *
     * #### Example
     * ```typescript
     * reduce<number, number>([1, 2, 3], (nValue: number, nItem: number) => nValue + nItem, 2); // Returns `8`
     * ```
     *
     * @param T Specifies the item type.
     * @param R Specifies the reduce type.
     * @param pList Specifies the array, collection or enumerable object to iterate
     * through.
     * @param fnReduce Specifies the reduce function to be invoked for each
     * element. The return value of each reduce function will be the current
     * reduced value.
     * @param fnReduce.pValue Contains the current reduce value. If `pInitial` is
     * specified, this value is `pInitial` upon the first call otherwise this value
     * is `undefined`.
     * @param fnReduce.pItem Contains the item.
     * @param fnReduce.pArguments Optional additional arguments. These are the
     * additional arguments which are passed to the main function.
     * @param pInitial Optional initial value for the reduce value.
     * @param pArguments Optional additional arguments which will be passed to the
     * callee.
     * @return Returns the reduced value.
     */
    export function reduce<T, R>(
        pList: TList<T> | undefined,
        fnReduce: (pValue: R, pItem: T, ...pArguments: TArguments) => R,
        pInitial?: R,
        ...pArguments: TArguments
    ): R | undefined;
    /**
     * Verifies an array, collection or enumerable object by iterating through the
     * items and verify them against the supplied truth function.
     *
     * #### Example
     * ```typescript
     * has<number>([1, 2, 3], (nItem: number) => nItem > 0); // Returns `true`
     * has<number>([1, 2, 3], (nItem: number) => nItem > 1); // Returns `false`
     * has<number>([1, 2, 3], (nItem: number) => nItem > 1, true); // Returns `true`
     * ```
     *
     * @param T Specifies the item type.
     * @param pList Specifies the array, collection or enumerable object to
     * iterate through.
     * @param fnTruth Specifies the truth function. Each item is supplied to the
     * function, passing the item as argument. The function should return a boolean
     * value with the individual verification result.
     * @param fnTruth.pItem Contains the item.
     * @param bOneOrMore Optional parameter which specifies if one or more items
     * should pass the verification. By default (`false`) all items should
     * pass (equals `HasOnly`).
     * @return Returns `true` in case of a verification pass.
     */
    export function has<T>(pList: TList<T> | undefined, fnTruth: (pItem: T) => boolean, bOneOrMore?: boolean): boolean;
    /**
     * Verifies all items of an array, collection or enumerable object against the
     * truth function.
     *
     * #### Example
     * ```typescript
     * hasOnly<number>([1, 2, 3], (nItem: number) => nItem > 0); // Returns `true`
     * hasOnly<number>([1, 2, 3], (nItem: number) => nItem > 1); // Returns `false`
     * ```
     *
     * @param T Specifies the item type.
     * @param pList Specifies the array, collection or enumerable object to iterate
     * through.
     * @param fnTruth Specifies the truth function. Each item is supplied to the
     * function, passing the item as argument. The function should return a boolean
     * value with the individual verification result.
     * @param fnTruth.pItem Contains the item.
     * @return Returns `true` when all items pass the verification test.
     */
    export function hasOnly<T>(pList: TList<T> | undefined, fnTruth: (pItem: T) => boolean): boolean;
    /**
     * Verifies some items of an array, collection or enumerable object against the
     * truth function.
     *
     * #### Example
     * ```typescript
     * hasOneOrMore<number>([1, 2, 3], (nItem: number) => nItem > 2); // Returns `true`
     * hasOneOrMore<number>([1, 2, 3], (nItem: number) => nItem > 3); // Returns `false`
     * ```
     *
     * @param T Specifies the item type.
     * @param pList Specifies the array, collection or enumerable object to iterate
     * through.
     * @param fnTruth Specifies the truth function. Each item is supplied to the
     * function, passing the item as argument. The function should return a boolean
     * value with the individual verification result.
     * @param fnTruth.pItem Contains the item.
     * @return Returns `true` when one or more items pass the verification test.
     */
    export function hasOneOrMore<T>(pList: TList<T> | undefined, fnTruth: (pItem: T) => boolean): boolean;
    /**
     * Counts the number of items in the supplied array, collection or
     * enumerable object.
     *
     * #### Example
     * ```typescript
     * count<number>([1, 2, 3], (nItem: number) => nItem > 1); // Returns `2`
     * ```
     *
     * @param T Specifies the item type.
     * @param pList Specifies the array, collection or enumerable object to iterate
     * through.
     * @param fnTruth Specifies the optional truth function. Only items that pass
     * the truth test are included in the count. The function should return a
     * boolean value whether the item should be counted. If omitted all items are
     * counted.
     * @param fnTruth.pItem Contains the item.
     * @return Returns the number of items that pass.
     */
    export function count<T>(pList: TList<T> | undefined, fnTruth?: (pItem: T) => boolean): number;
    /**
     * Selects items from an array, collection or enumerable object using a truth
     * test and optionally invokes a function for each item.
     *
     * #### Example
     * ```typescript
     * forEach<number>([1, 2, 3], (nItem: number) => nItem > 1); // Returns `[2, 3]`
     * forEach<number>([1, 2, 3], (nItem: number) => nItem > 1, {
     *   do: (nItem: number) => nItem + 1,
     *   replace: true
     * }); // Returns `[3, 4]`
     * ```
     *
     * @param T Specifies the item type.
     * @param pList Specifies the array, collection or enumerable object to iterate
     * through.
     * @param fnTruth Specifies the selector function. Each item is
     * supplied to the function, passing the item as argument. The function should
     * return a boolean value whether to include the item in the selection.
     * @param fnTruth.pItem Contains the item.
     * @param pOptions Contains the options.
     * @return Returns an array with the selected items or just the selected item if
     * the single mode is enabled.
     */
    export function forEach<T>(
        pList: TList<T> | undefined,
        fnTruth: (pItem: T) => boolean,
        pOptions?: {
            /**
             * Specifies an optional function to be invoked for each element that
             * passed the truth test. The element value will be exposed to the function
             * as the first argument of the argument list. Additional arguments can be
             * specified and will be pushed to the function.
             * @param pItem Contains the item.
             * @param pArguments Optional additional arguments. These are the
             * additional arguments which are passed to the main function.
             */
            do?: (pItem: T, ...pArguments: TArguments) => T | void;
            /**
             * Specifies if each value in the array should be overwritten  with the
             * return value of its executed function.
             */
            replace?: boolean;
            /**
             * Specifies if the function should return items. The default setting
             * is `matches` which returns all items which passed the truth test.
             */
            return?: "none" | "matches" | "first" | "last";
            /** Optional arguments which will be passed to the optional call function. */
            arguments?: TArguments;
        }
    ): T[] | T | undefined;
    /**
     * Selects all items from an array, collection or enumerable object that match
     * the truth function.
     *
     * #### Example
     * ```typescript
     * filter<number>([1, 2, 3], (nItem: number) => nItem > 1); // Returns `[2, 3]`
     * ```
     *
     * @param T Specifies the item type.
     * @param pList Specifies the array, collection or enumerable object to iterate
     * through.
     * @param fnTruth Specifies the truth function. Each item is supplied
     * to the function, passing the item as argument. The function should return a
     * boolean value whether to include the item in the selection.
     * @param fnTruth.pItem Contains the item.
     * @return Returns an array with the selected items.
     */
    export function filter<T>(pList: TList<T> | undefined, fnTruth: (pItem: T) => boolean): T[];
    /**
     * Selects the first item from an array, collection or enumerable object that
     * matches the truth function.
     *
     * #### Example
     * ```typescript
     * findFirst<number>([1, 2, 3], (nItem: number) => nItem > 1); // Returns `2`
     * ```
     *
     * @param T Specifies the item type.
     * @param pList Specifies the array, collection or enumerable object to iterate
     * through.
     * @param fnTruth Specifies the truth function. Each item is supplied
     * to the function, passing the item as argument. The function should return a
     * boolean value whether to include the item in the selection.
     * @param fnTruth.pItem Contains the item.
     * @return Returns the item or `undefined` if no item is found.
     */
    export function findFirst<T>(pList: TList<T> | undefined, fnTruth: (pItem: T) => boolean): T | undefined;
    /**
     * Selects the last item from an array, collection or enumerable object that
     * matches the truth function.
     *
     * #### Example
     * ```typescript
     * findLast<number>([1, 2, 3], (nItem: number) => nItem > 1); // Returns `3`
     * ```
     *
     * @param T Specifies the item type.
     * @param pList Specifies the array, collection or enumerable object to iterate
     * through.
     * @param fnTruth Specifies the truth function. Each item is supplied
     * to the function, passing the item as argument. The function should return a
     * boolean value whether to include the item in the selection.
     * @param fnTruth.pItem Contains the item.
     * @return Returns the item or `undefined` if no item is found.
     */
    export function findLast<T>(pList: TList<T> | undefined, fnTruth: (pItem: T) => boolean): T | undefined;
    /**
     * Finds the first item from an array, collection or enumerable object that
     * matches the truth function and returns its key.
     *
     * #### Example
     * ```typescript
     * find<number>([1, 2, 3], (nItem: number) => nItem > 1); // Returns `1`
     * find<Object>({a: 1, b: 2, c: 3}, (nItem: number) => nItem > 1); // Returns `b`
     * ```
     *
     * @param T Specifies the item type.
     * @param pList Specifies the array, collection or enumerable object to iterate
     * through.
     * @param fnTruth Specifies the truth function. Each item is supplied
     * to the function, passing the item as argument. The function should return a
     * boolean value whether to include the item in the selection.
     * @param fnTruth.pItem Contains the item.
     * @return Returns the item key or `undefined` if no item is found.
     */
    export function find<T>(pList: TList<T> | undefined, fnTruth: (pItem: T) => boolean): string | number | undefined;
    /**
     * Calls the supplied function.
     * @param T Specifies the return type of the call.
     * @param fnCallee Specifies the function to execute.
     * @param pArguments Optional additional arguments which will be passed to the callee.
     * @return Returns `undefined` if the call fails or the return value of the function which is executed if the call succeeds.
     */
    export function call<T>(fnCallee: ((...pArguments: TArguments) => T | void) | undefined, ...pArguments: TArguments): T | undefined;
    /**
     * Calls the supplied function asynchronous. Tries the following schedulers in
     * this order: `FUNCTION_TICK`, `FUNCTION_TIMEOUT`. The call cannot be canceled.
     * @param fnCallee Specifies the function to execute.
     * @param pArguments Optional additional arguments which will be passed to the callee.
     */
    export function callAsync(fnCallee: ((...pArguments: TArguments) => void) | undefined, ...pArguments: TArguments): void;
    /**
     * Calls the supplied function using promise. Tries the following schedulers in
     * this order: `FUNCTION_PROMISE`, `FUNCTION_TICK`, `FUNCTION_TIMEOUT`. The call cannot be canceled.
     * @param fnCallee Specifies the function to execute.
     * @param pArguments Optional additional arguments which will be passed to the callee.
     */
    export function callPromise(fnCallee: ((...pArguments: TArguments) => void) | undefined, ...pArguments: TArguments): void;
    /**
     * Calls the supplied function synchronous or asynchronous.
     * @param fnCallee Specifies the function to execute.
     * @param bSynchronous Specifies if the functio should be executed synchronously.
     * @param pArguments Optional additional arguments which will be passed to the callee.
     * @return Returns the call handle for asynchronous calls or `0` for synchronous calls.
     */
    export function callEx(
        fnCallee: ((...pArguments: TArguments) => void) | undefined,
        bSynchronous: boolean,
        ...pArguments: TArguments
    ): void;
    /**
     * Calls the supplied function and binds the specified context.
     * @param T Specifies the return type of the call.
     * @param fnCallee Specifies the function to execute.
     * @param pContext Context to bind to.
     * @param pArguments Optional additional arguments which will be passed to the callee.
     * @return Returns `undefined` if the call fails or the return value of the function which is executed if the call succeeds.
     */
    export function callBind<T>(
        fnCallee: ((...pArguments: TArguments) => T | void) | undefined,
        pContext: {},
        ...pArguments: TArguments
    ): T | undefined;
    /**
     * Calls the supplied function.
     * @param fnCallee Specifies the function to execute.
     * @param pArguments Optional additional arguments which will be passed to the callee.
     * @return Returns `undefined` if the call fails or the return value of the function which is executed if the call succeeds.
     */
    export function callFunction(fnCallee: TAny, ...pArguments: TArguments): TAny;
    /**
     * Calls the supplied function asynchronous on the next tick.
     * @param fnCallee Specifies the function to execute.
     * @param pArguments Optional additional arguments which will be passed to the callee.
     * @return Returns the call handle.
     */
    export function scheduleTick(fnCallee: ((...pArguments: TArguments) => void) | undefined, ...pArguments: TArguments): number;
    /**
     * Calls the supplied function asynchronous on the next tick and cancels a pending call.
     * @param fnCallee Specifies the function to execute.
     * @param nHandle Specifies the handle of the call to cancel.
     * @param pArguments Optional additional arguments which will be passed to the callee.
     * @return Returns the call handle.
     */
    export function scheduleAndCancelTick(
        fnCallee: ((...pArguments: TArguments) => void) | undefined,
        nHandle: number,
        ...pArguments: TArguments
    ): number;
    /**
     * Cancels a pending asynchronous tick call.
     * @param nHandle Contains the handle of the call.
     * @return Always returns 0.
     */
    export function cancelTick(nHandle: number): number;
    /**
     * Calls the supplied function as a promise.
     * @param fnCallee Specifies the function to execute.
     * @param pArguments Optional additional arguments which will be passed to the callee.
     * @return Returns the call handle.
     */
    export function schedulePromise(fnCallee: ((...pArguments: TArguments) => void) | undefined, ...pArguments: TArguments): number;
    /**
     * Calls the supplied function as a promise and cancels a pending promise.
     * @param fnCallee Specifies the function to execute.
     * @param nHandle Specifies the handle of the call to cancel.
     * @param pArguments Optional additional arguments which will be passed to the callee.
     * @return Returns the call handle.
     */
    export function scheduleAndCancelPromise(
        fnCallee: ((...pArguments: TArguments) => void) | undefined,
        nHandle: number,
        ...pArguments: TArguments
    ): number;
    /**
     * Cancels a pending promise.
     * @param nHandle Contains the handle of the call.
     * @return Always returns 0.
     */
    export function cancelPromise(nHandle: number): number;
    /**
     * Calls the supplied function asynchronous on the next frame.
     * @param fnCallee Specifies the function to execute.
     * @param pArguments Optional additional arguments which will be passed to the callee.
     * @return Returns the call handle.
     */
    export function scheduleFrame(fnCallee: ((...pArguments: TArguments) => void) | undefined, ...pArguments: TArguments): number;
    /**
     * Calls the supplied function asynchronous on the next frame.
     * @param fnCallee Specifies the function to execute.
     * @param nHandle Specifies the handle of the call to cancel.
     * @param pArguments Optional additional arguments which will be passed to the callee.
     * @return Returns the call handle.
     */
    export function scheduleAndCancelFrame(
        fnCallee: ((...pArguments: TArguments) => void) | undefined,
        nHandle: number,
        ...pArguments: TArguments
    ): number;
    /**
     * Cancels a pending asynchronous frame call.
     * @param nHandle Contains the handle of the call.
     * @return Always returns 0.
     */
    export function cancelFrame(nHandle: number): number;
    /**
     * Schedules the supplied function and invokes it on the specified timeout (using `setTimeout`).
     * @param fnCallee Specifies the function to execute.
     * @param nTimeout Specifies the timeout in milliseconds.
     * @param pArguments Optional additional arguments which will be passed to the callee.
     * @return Returns the call handle.
     */
    export function scheduleTimeout(fnCallee: (...pArguments: TArguments) => void, nTimeout: number, ...pArguments: TArguments): number;
    /**
     * Cancels a pending asynchronous call.
     * @param nHandle Contains the handle of the asynchronous timeout call.
     * @return Always returns 0.
     */
    export function cancelTimeout(nHandle: number): number;
    /**
     * Schedules the supplied function and invokes it on the specified timeout
     * (using `requestAnimationFrame`) which is optimal for UI related timers.
     * @param fnCallee Specifies the function to execute.
     * @param nTimeout Specifies the timeout in milliseconds.
     * @param pArguments Optional additional arguments which will be passed to the callee.
     * @return Returns the call handle.
     * @see https://bugs.chromium.org/p/chromium/issues/detail?id=574343
     */
    export function scheduleUITimeout(fnCallee: (...pArguments: TArguments) => void, nTimeout: number, ...pArguments: TArguments): number;
    /**
     * Cancels a pending UI timeout call.
     * @param nHandle Contains the handle of the asynchronous timeout call.
     * @return Always returns 0.
     */
    export function cancelUITimeout(nHandle: number): number;
    /**
     * Schedules the supplied function and invokes it on the specified interval (using `setInterval`).
     * @param fnCallee Specifies the function to execute.
     * @param nInterval Specifies the interval in milliseconds.
     * @param pArguments Optional additional arguments which will be passed to the callee.
     * @return Returns the call handle.
     */
    export function scheduleInterval(fnCallee: (...pArguments: TArguments) => void, nInterval: number, ...pArguments: TArguments): number;
    /**
     * Cancels an interval call.
     * @param nHandle Contains the handle of the asynchronous interval call.
     * @return Always returns 0.
     */
    export function cancelInterval(nHandle: number): number;
    /**
     * Schedules the supplied function and invokes it on the specified interval
     * (using `requestAnimationFrame`) which is optimal for UI related timers.
     * @param fnCallee Specifies the function to execute.
     * @param nInterval Specifies the interval in milliseconds.
     * @param pArguments Optional additional arguments which will be passed to the callee.
     * @return Returns the call handle.
     * @see https://bugs.chromium.org/p/chromium/issues/detail?id=574343
     */
    export function scheduleUIInterval(fnCallee: (...pArguments: TArguments) => void, nInterval: number, ...pArguments: TArguments): number;
    /**
     * Cancels a pending UI interval call.
     * @param nHandle Contains the handle of the asynchronous interval call.
     * @return Always returns 0.
     */
    export function cancelUIInterval(nHandle: number): number;
    /**
     * Calls the supplied function at a specific number of frames.
     * @param fnAnimation Specifies the function to execute.
     * @param fnAnimation.pArguments Optional additional arguments. These are the additional arguments which are passed to the main function.
     * @param nFrames Specifies the number of frames.
     * @param pArguments Optional additional arguments which will be passed to the callee.
     */
    export function scheduleNumberOfFrames(
        fnAnimation: ((...pArguments: TArguments) => void) | undefined,
        nFrames: number,
        ...pArguments: TArguments
    ): void;
    /**
     * Calls the supplied animation function using a double animation frame request. Use this function if you need to be sure all pending
     * DOM reads and writes are performed.
     * @param fnAnimation Specifies the function to execute.
     * @param fnAnimation.pArguments Optional additional arguments. These are the additional arguments which are passed to the main function.
     * @param pArguments Optional additional arguments which will be passed to the callee.
     */
    export function scheduleAnimation(fnAnimation: ((...pArguments: TArguments) => void) | undefined, ...pArguments: TArguments): void;
    /**
     * Calls the supplied event function (after 2 animation frames).
     * @param fnEvent Specifies the function to execute.
     * @param fnEvent.pArguments Optional additional arguments. These are the additional arguments which are passed to the main function.
     * @param pArguments Optional additional arguments which will be passed to the callee.
     */
    export function scheduleEvent(fnEvent: ((...pArguments: TArguments) => void) | undefined, ...pArguments: TArguments): void;
    /**
     * Calls the supplied function as part of an action in a waiting loop (after 5 animation frames).
     * @param fnAction Specifies the function to execute.
     * @param fnAction.pArguments Optional additional arguments. These are the additional arguments which are passed to the main function.
     * @param pArguments Optional additional arguments which will be passed to the callee.
     */
    export function scheduleAction(fnAction: ((...pArguments: TArguments) => void) | undefined, ...pArguments: TArguments): void;
    /**
     * Sets the value of the specified variable in the object using its index type.
     * @param pObject Reference to the object.
     * @param sName Name of the variable.
     * @param pValue Value for the variable.
     * @return Returns a reference to the value on the object.
     */
    export function set<T, K extends keyof T>(pObject: T, sName: K, pValue: T[K]): T[K];
    /**
     * Sets the value of the specified variable in the object array.
     * @param T Specifies the type of the variable which is set.
     * @param pObject Reference to the object.
     * @param sName Name of the variable.
     * @param pValue Value for the variable.
     * @return Returns a reference to the value on the object.
     */
    export function setAny<T>(pObject: TAny, sName: string, pValue: T): T;
    /**
     * Retrieves the value of the specified variable in the object using its index type.
     * @param pObject Reference to the object.
     * @param sName Name of the variable.
     * @return Returns the value of the variable.
     */
    export function get<T, K extends keyof T>(pObject: T, sName: K): T[K];
    /**
     * Retrieves the value of the specified variable in the object array.
     * @param T Specifies the type of the returned variable.
     * @param pObject Reference to the object.
     * @param sName Name of the variable.
     * @return Returns the value of the variable.
     */
    export function getAny<T>(pObject: IObject | undefined, sName: string): T | undefined;
    /**
     * Retrieves a boolean value of the specified variable in the object array.
     * @param pObject Reference to the object.
     * @param sName Name of the variable.
     * @param bDefault Specifies the default value.
     * @return Returns the value of the variable.
     */
    export function getBoolean(pObject: IObject | undefined, sName: string, bDefault?: boolean): boolean;
    /**
     * Retrieves a string value of the specified variable in the object array.
     * @param pObject Reference to the object.
     * @param sName Name of the variable.
     * @param sDefault Specifies the default value.
     * @return Returns the value of the variable.
     */
    export function getString(pObject: IObject | undefined, sName: string, sDefault?: string): string;
    /**
     * Retrieves a numeric value of the specified variable in the object array.
     * @param pObject Reference to the object.
     * @param sName Name of the variable.
     * @param nDefault Specifies the default value.
     * @return Returns the value of the variable.
     */
    export function getNumber(pObject: IObject | undefined, sName: string, nDefault?: number): number;
    /**
     * Retrieves a floating value of the specified variable in the object array.
     * @param pObject Reference to the object.
     * @param sName Name of the variable.
     * @param fDefault Specifies the default value.
     * @return Returns the value of the variable.
     */
    export function getFloat(pObject: IObject | undefined, sName: string, fDefault?: number): number;
    /**
     * Destroys the specified variable in the object array.
     * @param pObject Reference to the object.
     * @param sName Name of the variable.
     * @return Returns `true` if the variable is deleted.
     */
    export function destroy(pObject: IObject | undefined, sName: string): boolean;
    /**
     * Creates a new class instance with the supplied constructor and arguments
     * array.
     *
     * #### Example
     * ```typescript
     * class Example {
     *     constructor(public a: string, public b: number) {}
     * }
     *
     * let pExample = createInstanceOf(Example, "Hello", 1);
     * ```
     *
     * @param T Specifies the instance type.
     * @param pConstructor Specifies the constructor.
     * @param pArguments Optional array with arguments which will be passed to the constructor.
     * @return Returns the instance.
     */
    export function createInstanceOf<T>(
        pConstructor: {
            new (...pArguments: TArguments): T;
        },
        ...pArguments: TArguments
    ): T;
    export namespace Console {
        /**
         * Returns a log string with a time stamp.
         * @return Returns the time stamp log string.
         */
        function time(): string;
        /**
         * Returns a log string for a module name.
         * @param sName Specifies the name of the module.
         * @return Returns the log string.
         */
        function module(sName: string): string;
        /**
         * Returns a complete log string.
         * @param sName Specifies the name of the module.
         * @param sMessage Specifies the message to log.
         * @return Returns the log string.
         */
        function log(sName: string, sMessage: string): string;
    }
    export namespace Environment {
        /** Contains if the environment is a browser. */
        const isBrowser: boolean;
        /** Contains if the environment is Node. */
        const isNode: boolean;
        /** Contains if the environment is a web worker. */
        const isWebWorker: boolean;
    }
    export namespace Num {
        /**
         * Round a floating point number to the nearest integer.
         *
         * #### Example
         * ```typescript
         * round(1.49); // Returns `1`
         * round(1.5); // Returns `2`
         * ```
         *
         * @param fValue Input number.
         * @return Returns the rounded number.
         */
        function round(fValue: number): number;
        /**
         * Round a floating point number downward to its nearest integer.
         *
         * #### Example
         * ```typescript
         * floor(1.6); // Returns `1`
         * ```
         *
         * @param fValue Input number.
         * @return Returns the floored number.
         */
        function floor(fValue: number): number;
        /**
         * Round a floating point number upward to its nearest integer.
         *
         * #### Example
         * ```typescript
         * ceil(1.6); // Returns `2`
         * ```
         *
         * @param fValue Input number.
         * @return Returns the ceiled number.
         */
        function ceil(fValue: number): number;
        /**
         * Conforms the supplied number to the specified precision.
         *
         * #### Example
         * ```typescript
         * conform(1.1235, 3); // Returns `1.124`
         * conform(1.1235, 2); // Returns `1.12`
         * ```
         *
         * @param fValue Input value.
         * @param nPrecision Specifies the number of decimals.
         * @return Returns the conformed number.
         */
        function conform(fValue: number, nPrecision: number): number;
        /**
         * Checks if the supplied number is positive and returns this positive value or `0` if the value is negative.
         *
         * #### Example
         * ```typescript
         * positive(1); // Returns `1`
         * positive(-1); // Returns `0`
         * ```
         *
         * @param nValue Input number.
         * @return Returns nValue if the value is positive otherwise `0`.
         */
        function positive(nValue: number): number;
        /**
         * Checks if the supplied number is negative and returns this negative value or `0` if the value is positive.
         *
         * #### Example
         * ```typescript
         * negative(1); // Returns `0`
         * negative(-1); // Returns `-1`
         * ```
         *
         * @param nValue Input number.
         * @return Returns nValue if the value is negative otherwise `0`.
         */
        function negative(nValue: number): number;
        /**
         * Compares two numbers and returns the highest value.
         *
         * #### Example
         * ```typescript
         * max(1, 2); // Returns `2`
         * ```
         *
         * @param nA Input number A.
         * @param nB Input number B.
         * @return Returns the number with the highest value.
         */
        function max(nA: number, nB: number): number;
        /**
         * Compares the supplied arguments returns the highest value.
         *
         * #### Example
         * ```typescript
         * maxL(1, 2, 5, 3); // Returns `5`
         * ```
         *
         * @param pArguments Arguments to compare.
         * @return Returns the number with the highest value.
         */
        function maxL(...pArguments: number[]): number;
        /**
         * Compares two numbers and returns the lowest value.
         *
         * #### Example
         * ```typescript
         * min(1, 2); // Returns `1`
         * ```
         *
         * @param nA Input number A.
         * @param nB Input number B.
         * @return Returns the number with the lowest value.
         */
        function min(nA: number, nB: number): number;
        /**
         * Compares the supplied arguments returns the lowest value.
         *
         * #### Example
         * ```typescript
         * minL(1, 2, 5, 3); // Returns `1`
         * ```
         *
         * @param pArguments Arguments to compare.
         * @return Returns the number with the lowest value.
         */
        function minL(...pArguments: number[]): number;
        /**
         * Adjusts a number so it is in range between the specifies minimum and maximum.
         *
         * #### Example
         * ```typescript
         * range(20, 5, 10); // Returns `10`
         * range(0, 5, 10); // Returns `5`
         * ```
         *
         * @param nValue Input number.
         * @param nMin Specifies the minimum value.
         * @param nMax Specifies the maximum value.
         * @return Returns the ranged number.
         */
        function range(nValue: number, nMin: number, nMax?: number): number;
        /**
         * Checks if the given value is within the specified range.
         *
         * #### Example
         * ```typescript
         * inRange(5, 5, 10); // Returns `true`
         * inRange(0, 5, 10); // Returns `false`
         * ```
         *
         * @param nValue Input number.
         * @param nMin Specifies the minimum value.
         * @param nMax Specifies the maximum value.
         * @param bEdgeMin Specifies if the edge of the min value is allowed (enabled by default).
         * @param bEdgeMax Specifies if the edge of the max value is allowed (disabled by default).
         * @return Returns `true` if the value is in range.
         */
        function inRange(nValue: number, nMin: number, nMax: number, bEdgeMin?: boolean, bEdgeMax?: boolean): boolean;
        /**
         * Formats a number by inserting thousands and decimal separators while taking rounding into account.
         *
         * #### Example
         * ```typescript
         * format("1000.235", 2); // Returns `1,000.24`
         * ```
         *
         * @param nValue Input value as a number or string.
         * @param nPrecision Specifies the precision (set it to `auto` to allow
         * floating point numbers with automatic precision detection).
         * @param sSeparator Separator sign.
         * @param sDecimal Decimal sign.
         * @param sMinus Minus sign.
         * @return Returns the formatted number as a string.
         */
        function format(
            nValue: number | string,
            nPrecision?: number | "auto",
            sSeparator?: string,
            sDecimal?: string,
            sMinus?: string
        ): string;
    }
    export namespace Str {
        /**
         * Converts a string to lowercase.
         *
         * #### Example
         * ```typescript
         * lowercase("HELLO"); // Returns `hello`
         * ```
         *
         * @param sValue Source string.
         * @return Returns the converted string.
         */
        function lowercase(sValue: string): string;
        /**
         * Converts a string to uppercase.
         *
         * #### Example
         * ```typescript
         * uppercase("Hello"); // Returns `HELLO`
         * ```
         *
         * @param sValue Source string.
         * @return Returns the converted string.
         */
        function uppercase(sValue: string): string;
        /**
         * Capitalizes the first character of a string or the first character of each word.
         *
         * #### Example
         * ```typescript
         * capitalize("lorem ipsum. dolor"); // Returns `Lorem ipsum. dolor`
         * capitalize("lorem ipsum. dolor", "each-word"); // Returns `Lorem Ipsum. Dolor`
         * capitalize("lorem ipsum. dolor", "each-sentence"); // Returns `Lorem ipsum. Dolor`
         * ```
         *
         * @param sValue Source string.
         * @param sMode Specifies the mode: `first-character` (default), `each-word` or `each-sentence`.
         * @param bLowercase Converts the string to lowercase before capitalizing it.
         * @return Returns the capitalized string.
         */
        function capitalize(sValue: string, sMode?: "first-character" | "each-word" | "each-sentence", bLowercase?: boolean): string;
        /**
         * Trims a string by removing all leading and trailing whitespaces (`_ab__cd_` -> `ab__cd`).
         *
         * #### Example
         * ```typescript
         * trim(" ab  cd "); // Returns `ab  cd`
         * ```
         *
         * @param sValue Source string.
         * @return Returns the trimmed string.
         */
        function trim(sValue: string): string;
        /**
         * Trims a string at the left side by removing all leading whitespaces (`_ab__cd_` -> `ab__cd_`).
         *
         * #### Example
         * ```typescript
         * trimLeft(" ab  cd "); // Returns `ab  cd `
         * ```
         *
         * @param sValue Source string.
         * @return Returns the trimmed string.
         */
        function trimLeft(sValue: string): string;
        /**
         * Trims a string at the right by removing all trailing whitespaces (`_ab__cd_` -> `_ab__cd`).
         *
         * #### Example
         * ```typescript
         * trimRight(" ab  cd "); // Returns ` ab  cd`
         * ```
         *
         * @param sValue Source string.
         * @return Returns the trimmed string.
         */
        function trimRight(sValue: string): string;
        /**
         * Trims a string by removing all multiple whitespaces (`_ab__cd_` -> `_ab_cd_`).
         *
         * #### Example
         * ```typescript
         * trimMultiple(" ab  cd "); // Returns ` ab cd `
         * ```
         *
         * @param sValue Source string.
         * @return Returns the trimmed string.
         */
        function trimMultiple(sValue: string): string;
        /**
         * Sanitize a string by removing all leading, trailing and multiple whitespaces (`_ab__cd_` -> `ab_cd`).
         *
         * #### Example
         * ```typescript
         * sanitize(" ab  cd "); // Returns `ab cd`
         * ```
         *
         * @param sValue Source string.
         * @return Returns the sanitized string.
         */
        function sanitize(sValue: string): string;
        /**
         * Removes all white spaces from the specified string (`_ab__cd_` -> `abcd`).
         *
         * #### Example
         * ```typescript
         * removeWhitespaces(" ab  cd "); // Returns `abcd`
         * ```
         *
         * @param sValue Source string.
         * @return Returns the sanitized string.
         */
        function removeWhitespaces(sValue: string): string;
        /**
         * Limits a string which is greater than the specified number of characters and appends an optional string. If an append string is
         * specified any trailing spaces in the trimmed string are removed.
         *
         * #### Example
         * ```typescript
         * limit("Lorem ipsum", 5, "..."); // Returns `Lorem...`
         * limit("Lorem ipsum", 6, "..."); // Returns `Lorem...`
         * limit("Lorem ipsum", 6); // Returns `Lorem `
         * ```
         *
         * @param sValue Specifies the input string (variable will be casted to a string if necessary).
         * @param nMax Maximum string length.
         * @param sAppend Optional string which is appended to a limited string.
         * @return Returns the limited string.
         */
        function limit(sValue: string, nMax: number, sAppend?: string): string;
        /**
         * Replaces all occurrences of `sWhat` with `sWith` in the specified string.
         *
         * #### Example
         * ```typescript
         * replace("Hello", "l", "-"); // Returns `He--o`
         * ```
         *
         * @param sValue Specifies the input string (variable will be casted to a string if necessary).
         * @param sWhat Specifies the string to search for.
         * @param sWith Specifies the replace string. If omitted an empty string will be used.
         * @param bIgnoreCase Specifies if the string replace should be case insensitive.
         * @return Returns the replaced string.
         */
        function replace(sValue: string, sWhat: string, sWith?: string, bIgnoreCase?: boolean): string;
        /**
         * Replaces all occurrences of strings in `pWhat` with `sWith` in the specified string.
         *
         * #### Example
         * ```typescript
         * replaceMultiple("Hello", ["ll", "o"], "-"); // Returns `He---`
         * ```
         *
         * @param sValue Specifies the input string (variable will be casted to a string if necessary).
         * @param pWhat Specifies the strings to search for.
         * @param sWith Specifies the replace string. If omitted an empty string will be used.
         * @param bIgnoreCase Specifies if the string replace should be case insensitive.
         * @return Returns the replaced string.
         */
        function replaceMultiple(sValue: string, pWhat: string[], sWith?: string, bIgnoreCase?: boolean): string;
        /**
         * Converts HTML brackets to HTML entities so it is safe to display without HTML parsing. *Careful, only the brackets (`<` and `>`)
         * are converted to HTML entities.*
         *
         * #### Example
         * ```typescript
         * makeHTMLSafe("<b>Hello</b>"); // Returns `&lt;b&gt;Hello&lt;b&gt;`
         * ```
         *
         * @param sValue Specifies the string to be converted (variable will be casted to a string if necessary).
         * @return Returns the converted string.
         */
        function makeHTMLSafe(sValue: string): string;
        /**
         * Converts carriage returns and/or newlines to HTML breaks.
         *
         * #### Example
         * ```typescript
         * CRLFToHTML("Row 1\r\nRow 2"); // Returns `Row 1<br />Row 2`
         * ```
         *
         * @param sValue Specifies the string to be converted (variable will be casted to a string if necessary).
         * @return Returns the converted string.
         */
        function CRLFToHTML(sValue: string): string;
        /**
         * Converts an array or object list to a concatenated string.
         *
         * #### Example
         * ```typescript
         * iterateToString(["a", "b", "c"]); // Returns `abc`
         * iterateToString(["a", "b", "c"], "-"); // Returns `a-b-c`
         * iterateToString(["a", "b", "c"], "/", (sValue: string) => sValue + sValue); // Returns `aa/bb/cc`
         * ```
         *
         * @param T Specifies the item type.
         * @param pList Specifies the array, collection or enumerable object to
         * iterate through.
         * @param sSeparator Optional parameter which specifies the separator string or char.
         * @param fnCast Optional function to be invoked for each element instead of automatic casting to strings. The element value will be
         * exposed to the function as the first argument of the argument list. Additional arguments can be specified and will be pushed to
         * the function.
         * @param fnCast.pItem Contains the item which should be casted to a string.
         * @param fnCast.pArguments Optional additional arguments for the casting function. These are the additional arguments which are
         * passed to the main function.
         * @param pArguments Optional additional arguments which will be passed to the callee.
         * @return Returns the concatenated string.
         */
        function iterateToString<T>(
            pList: TList<T>,
            sSeparator?: string,
            fnCast?: (pItem: T, ...pArguments: TArguments) => string,
            ...pArguments: TArguments
        ): string;
        /**
         * Extracts the part of the string between the first occurrence of `left` and the optional occurrence of `right`.
         *
         * #### Example
         * ```typescript
         * extract("Lorem ipsum dolor", { left: "Lo", right: "m" }); // Returns `re`
         * extract("Lorem ipsum dolor", { left: "Lo", right: "m", fromEnd: true }); // Returns `rem ipsu`
         * ```
         *
         * @param sValue Specifies the input string (variable will be casted to a string if necessary).
         * @param pOptions Specifies the extract options.
         * @return Returns the string between `left` and `right` or an empty string if an error occurs.
         */
        function extract(
            sValue: string,
            pOptions: {
                /** Left string selector. */
                left: string;
                /** Right string selector. */
                right?: string;
                /**
                 * Specifies the search direction of the right string selector. If
                 * `false` is specified, the function searches for the first
                 * occurrence of `Right` directly after the position of `Left`.
                 */
                fromEnd?: boolean;
                /** Specifies if a case insensitive check should be performed. */
                ignoreCase?: boolean;
            }
        ): string;
        /**
         * Fills a string for the specified times with the specified string or characters.
         *
         * #### Example
         * ```typescript
         * fill("A", 5); // Returns `AAAAA`
         * ```
         *
         * @param sFill Specifies the fill string.
         * @param nCount Specifies the number of copies to insert.
         * @return Returns the filled string.
         */
        function fill(sFill: string, nCount: number): string;
        /**
         * Converts source variable to a string and pads the string on the left with the supplied number of characters.
         *
         * #### Example
         * ```typescript
         * padLeft("ABC", "A", 5); // Returns `AAABC`
         * ```
         *
         * @param pValue Specifies the input string or number.
         * @param sFill Contains the string which will be used as fill string.
         * @param nLength Specifies the desired string length.
         * @param bCrop Optional boolean value which enables string cropping if the source string length is larger than the desired string
         * length.
         * @param bTreatAsNumber Optional boolean value which specifies the input string should be treated as a number.
         * @return Returns the padded string.
         */
        function padLeft(pValue: string | number, sFill: string, nLength: number, bCrop?: boolean, bTreatAsNumber?: boolean): string;
        /**
         * Converts source variable to a string and pads the string on the right with the supplied number of characters.
         *
         * #### Example
         * ```typescript
         * padRight("ABC", "A", 5); // Returns `ABCAA`
         * ```
         *
         * @param pValue Specifies the input string or number.
         * @param sFill Contains the string which will be used as fill string.
         * @param nLength Specifies the desired string length.
         * @param bCrop Optional boolean value which enables string cropping if the source string length is larger than the desired string
         * length.
         * @return Returns the padded string.
         */
        function padRight(pValue: string | number, sFill: string, nLength: number, bCrop?: boolean): string;
        /**
         * Creates a simple hash for the supplied string using the djb2-algorithm
         * written by Dan Bernstein. This hash function is similar to a linear
         * congruential generator and is absolutely not collision resistant.
         *
         * #### Example
         * ```typescript
         * djb2Hash("Abc"); // Returns `ABCAA`
         * djb2Hash("Abc", "prefix-"); // Returns `prefix-ABCAA`
         * ```
         *
         * @param sValue Specifies the input string.
         * @param sPrefix Specifies a prefix for the hash result.
         * @return Returns the hash string.
         * @see http://www.cse.yorku.ca/~oz/hash.html
         * @see https://en.wikipedia.org/wiki/Linear_congruential_generator
         */
        function djb2Hash(sValue: string, sPrefix?: string): string;
    }
    export class DateTime {
        /** Returns the current time and date as number of milliseconds. */
        static get now(): number;
        /** Returns a high precision time stamp with up to microsecond precision. */
        static get precise(): number;
        /** Returns the current local time as if it is that time in UTC as number of milliseconds. */
        static get UTC(): number;
        /** Returns today 0:00 as number of milliseconds. */
        static get today(): number;
        /** Returns today 0:00 as if it is that date in UTC as number of milliseconds. */
        static get UTCToday(): number;
        /**
         * Checks if the specified date/time is in the future.
         * @param nTime Specifies the date/time to check.
         * @return Returns `true` if the supplied date/time is in the future.
         */
        static isFuture(nTime: number): boolean;
        /**
         * Checks if the specified date/time is in the past.
         * @param nTime Specifies the date/time to check.
         * @return Returns `true` if the supplied date/time is in the past.
         */
        static isPast(nTime: number): boolean;
        /**
         * Returns the number of elapsed milliseconds between the current time and the supplied time.
         * @param nTime Specifies the date/time to subtract.
         * @param bPrecise Specifies if the precise or normal time should be used.
         * @return Returns the number of elapsed milliseconds between the current time and the supplied time.
         */
        static elapsed(nTime: number, bPrecise?: boolean): number;
        /**
         * Resets the high precision timer and returns the old value.
         * @return Returns the previous timer value.
         */
        static timerReset(): number;
        /** Returns the number of milliseconds elapsed since the last timer update. On each call the timer is restarted. */
        static get timerElapsed(): number;
        /** Returns a timer stamp with the number of milliseconds elapsed since the last timer update. */
        static get timerStamp(): string;
        /**
         * Formats a date/time string.
         * @param sFormat Specifies the format to use, using the CLDR date/time formatting style. The following variables are available:
         * - `y` / `yyyy`: Specifies the full 4-digit year;
         * - `yy`: Specifies the 2-digit year;
         * - `M`: Specifies the month number;
         * - `MM`: Specifies the month number with a minimum of 2 digits;
         * - `MMM`: Specifies the month as an abbreviated string which should be supplied through the `monthFormattedAbbreviated`
         * parameter (e.g. `Jan`);
         * - `MMMM`: Specifies the month as a full string which should be supplied through the `monthFormattedWide`
         * parameter (e.g. `January`);
         * - `MMMMM`: Specifies the month as a narrow string which should be supplied through the `monthFormattedNarrow`
         * parameter (e.g. `J`);
         * - `LLL`: Specifies the month as an abbreviated nominative string which should be supplied through
         * the `monthNominativeAbbreviated` parameter (e.g. `Jan`);
         * - `LLLL`: Specifies the month as a full nominative string which should be supplied through
         * the `monthNominativeWide` parameter (e.g. `January`);
         * - `LLLLL`: Specifies the month as a narrow nominative string which should be supplied through
         * the `monthNominativeNarrow` parameter (e.g. `J`);
         * - `d`: Specifies the day of the month;
         * - `dd`: Specifies the day of the month with a minimum of 2 digits;
         * - `E`: Specifies the day of the week;
         * - `EE`: Specifies the day of the week as a string which should be supplied through the `weekdaysFormattedShort`
         * parameter (e.g. `Su`);
         * - `EEE`: Specifies the day of the week as an abbreviated string which should be supplied through
         * the `weekdaysFormattedAbbreviated` parameter (e.g. `Sun`);
         * - `EEEE`: Specifies the day of the week as a full string which should be supplied through the `weekdaysFormattedWide`
         * parameter (e.g. `Sunday`);
         * - `EEEEE`: Specifies the day of the week as a narrow string which should be supplied through the `weekdaysFormattedNarrow`
         * parameter (e.g. `S`);
         * - `cc`: Specifies the day of the week as a nominative string which should be supplied through the `weekdaysNominativeShort`
         * parameter (e.g. `Su`);
         * - `ccc`: Specifies the day of the week as an abbreviated nominative string which should be supplied through
         * the `weekdaysNominativeAbbreviated` parameter (e.g. `Sun`);
         * - `cccc`: Specifies the day of the week as a full nominative string which should be supplied through
         * the `weekdaysNominativeWide` parameter (e.g. `Sunday`);
         * - `ccccc`: Specifies the day of the week as a narrow nominative string which should be supplied through
         * the `weekdaysNominativeNarrow` parameter (e.g. `S`);
         * - `H`: Specifies the number of hours in 24-hour format;
         * - `HH`: Specifies the number of hours in 24-hour format  with a minimum of 2 digits;
         * - `h`: Specifies the number of hours in 12-hour format;
         * - `hh`: Specifies the number of hours in 12-hour format  with a minimum of 2 digits;
         * - `a`: Specifies the `AM` or `PM` hour suffix;
         * - `m`: Specifies the number of minutes;
         * - `mm`: Specifies the number of minutes with a minimum of 2 digits;
         * - `s`: Specifies the number of seconds;
         * - `ss`: Specifies the number of seconds with a minimum of 2 digits;
         * - `S`: Specifies the number of milliseconds;
         * - `SSS`: Specifies the number of milliseconds with a minimum of 3 digits;
         * @param nTime Specifies the date/time to format. If this value is not specified `Now` will be used.
         * @param bUTC Specifies if the UTC time needs to be used.
         * @param pLocales Contains the date/time locales.
         * @return Returns the formatted date string.
         * @see http://cldr.unicode.org/translation/date-time
         */
        static format(
            sFormat?: string,
            nTime?: number,
            bUTC?: boolean,
            pLocales?: {
                /** Specifies an array with 12 formatted abbreviated month labels, starting with january. */
                monthsFormattedAbbreviated?: string[];
                /** Specifies an array with 12 formatted narrow month labels, starting with january. */
                monthsFormattedNarrow?: string[];
                /** Specifies an array with 12 formatted wide month labels, starting with january. */
                monthsFormattedWide?: string[];
                /** Specifies an array with 12 nominative abbreviated month labels, starting with january. */
                monthsNominativeAbbreviated?: string[];
                /** Specifies an array with 12 nominative narrow month labels, starting with january. */
                monthsNominativeNarrow?: string[];
                /** Specifies an array with 12 nominative wide month labels, starting with january. */
                monthsNominativeWide?: string[];
                /** Specifies an array with 7 formatted abbreviated day labels, starting with sunday. */
                weekdaysFormattedAbbreviated?: string[];
                /** Specifies an array with 7 formatted narrow day labels, starting with sunday. */
                weekdaysFormattedNarrow?: string[];
                /** Specifies an array with 7 formatted short day labels, starting with sunday. */
                weekdaysFormattedShort?: string[];
                /** Specifies an array with 7 formatted wide day labels, starting with sunday. */
                weekdaysFormattedWide?: string[];
                /** Specifies an array with 7 nominative abbreviated day labels, starting with sunday. */
                weekdaysNominativeAbbreviated?: string[];
                /** Specifies an array with 7 nominative narrow day labels, starting with sunday. */
                weekdaysNominativeNarrow?: string[];
                /** Specifies an array with 7 nominative short day labels, starting with sunday. */
                weekdaysNominativeShort?: string[];
                /** Specifies an array with 7 nominative wide day labels, starting with sunday. */
                weekdaysNominativeWide?: string[];
                /** Specifies the `AM` suffix. */
                AM?: string;
                /** Specifies the `PM` suffix. */
                PM?: string;
            }
        ): string;
        /**
         * Formats an elapsed time as a string. Uses the CLDR date/time formatting style.
         * @param sFormat Specifies the format to use. The following variables are available:
         * - `H`: Specifies the number of hours;
         * - `HH`: Specifies the number of hours with a minimum of 2 digits;
         * - `m`: Specifies the number of minutes;
         * - `mm`: Specifies the number of minutes with a minimum of 2 digits;
         * - `s`: Specifies the number of seconds;
         * - `ss`: Specifies the number of seconds with a minimum of 2 digits;
         * - `S`: Specifies the number of milliseconds;
         * - `SSS`: Specifies the number of milliseconds with a minimum of 3 digits;
         * - `u`: Specifies the number of microseconds;
         * - `uuu`: Specifies the number of microseconds with a minimum of 3 digits;
         * @param nElapsed Specifies the elapsed time. If this value is not specified, the current `timerElapsed` value will be used.
         * @param sAM Specifies the `AM` suffix.
         * @param sPM Specifies the `PM` suffix.
         * @return Returns the formatted elapsed time string.
         * @see http://cldr.unicode.org/translation/date-time
         */
        static formatElapsed(sFormat?: string, nElapsed?: number, sAM?: string, sPM?: string): string;
        /** Returns a preformatted log string. */
        static get log(): string;
        /** Returns a preformatted time log string. */
        static get logTime(): string;
        /**
         * Constructs a new date object.
         * @param Specifies the date/time.
         */
        constructor(pDate?: DateTime | Date | number);
        /** Retrieves the date object. */
        get date(): Date;
        /** Retrieves the unix time stamp. */
        get time(): number;
        /** Sets the unix time stamp. */
        set time(nTime: number);
    }
    export class Flags {
        /** Creates a new flag identifier. */
        get flag(): number;
        /**
         * Converts the supplied boolean values to a flag identifier.
         * @param pFlags Array with boolean attributes.
         * @return Returns the flag number.
         */
        static convert(...pFlags: boolean[]): number;
        /**
         * Checks if the supplied flags value has the specified flag index enabled.
         * @param nFlags Specifies the flags value.
         * @param nIndex Specifies the flag index (the first flag is `1`).
         * @return Returns `true` if the flag is enabled.
         */
        static has(nFlags: number, nIndex: number): boolean;
    }
    export class Enumerator {
        /** Retrieves the next global enumerator. */
        static get n(): number;
        /** Retrieves the next instance enumerator. */
        get n(): number;
        /** Sets the enumerator offset. */
        set n(nEnumerator: number);
        /** Recycles the global enumerator. */
        static recycle(): void;
        /** Recycles the instance enumerator. */
        recycle(): void;
    }
    type TType = "throttle" | "throttle-delay" | "debounce";
    export type TCallback = (...pArguments: TArguments) => void;
    export class Limiter {
        /**
         * Creates a new limiter.
         * @param sType Specifies the limiter type.
         * @param fnCallback Specifies the callback function.
         * @param nTimeout Specifies the timeout. Can be a number that specifies
         * the number of milliseconds or can be one of the following values:
         * - `tick`: Use a single tick;
         * - `frame`: Use a single animation frame;
         * - `double-frame`: Use a double animation frame;
         * - `promise`: Debounce using promise;
         * - `tick`: Debounce on next tick.
         */
        constructor(sType: TType, fnCallback: TCallback, nTimeout: number | "tick" | "promise" | "frame" | "double-frame");

        /**
         * Invokes the callback with the supplied arguments.
         * @param pArguments Specifies the arguments to pass to the callback.
         */
        invoke(...pArguments: TArguments): void;
        /** Cancels any pending callbacks. */
        cancel(): void;
        /** Flushes any pending callbacks by executing them immediately (even when a callback is hold). */
        flush(): void;
        /** Hold any pending callbacks. */
        hold(): void;
        /**
         * Release any pending callbacks.
         * @param bImmediately Specifies if the release should be instantly.
         */
        release(bImmediately?: boolean): void;
    }
    export class Throttle extends Limiter {
        /**
         * Creates a new throttle.
         * @param fnCallback Specifies the callback function.
         * @param nTimeout Specifies the throttle timeout. Can be a number that
         * specifies the number of milliseconds or can be one of the following values:
         * - `frame`: Use a single animation frame (default);
         * - `double-frame`: Use a double animation frame;
         * - `promise`: Debounce using promise;
         * - `tick`: Debounce on next tick.
         * @param bDelay Specifies if the first call should be delayed until the
         * timeout. If the delay is disabled (`false`), all calls until the next
         * timeout are ignored.
         */
        constructor(fnCallback: TCallback, nTimeout?: number | "tick" | "promise" | "frame" | "double-frame", bDelay?: boolean);
    }
    export class Debounce extends Limiter {
        /**
         * Creates a new debouncer.
         * @param fnCallback Specifies the callback function.
         * @param nTimeout Specifies the debounce timeout. Can be a number that
         * specifies the number of milliseconds or can be one of the following values:
         * - `frame`: Use a single animation frame (default);
         * - `double-frame`: Use a double animation frame;
         * - `promise`: Debounce using promise;
         * - `tick`: Debounce on next tick.
         */
        constructor(fnCallback: TCallback, nTimeout?: number | "tick" | "promise" | "frame" | "double-frame");
    }
    export class Stack {
        /** Adds a call to the buffer. */
        add(fnCall: () => void): void;
        /** Executes all calls in the stack. */
        flush(): void;
        /** Clears the stack. */
        clear(): void;
        /** Flushes and clears the stack. */
        flushAndClear(): void;
    }
    /** Indicates if debugging is enabled. */
    export let DEBUG: boolean;
    /** Enable debugging. */
    export function enableDebugging(): void;
    /** Disable debugging. */
    export function disableDebugging(): void;

    export { TType as TLimiterType };
}

declare module "@tripetto/runner/module/grid" {
    import { Stack, TAny } from "@tripetto/runner/module/functional";
    import { IHookPayload, THooks } from "@tripetto/runner/module/hookup";
    import {
        ICountChangeEvent,
        IDimensionChangeEvent,
        IItemChangeEvent,
        IItemPopEvent,
        IItemPushEvent,
        Item,
        Matrix,
        Orientations,
        Types,
    } from "@tripetto/runner/module/matrix";
    import { Coordinate, IPoint, Rectangle, Rectangles } from "@tripetto/runner/module/metrics";
    import { ISerialize } from "@tripetto/runner/module/serializer";

    export interface IGridResource extends ISerialize {
        /** Contains the identifier for the serialized resource. */
        readonly id: string;
    }
    /** Specifies the rectangles type. */
    export type TGridRectangles = Rectangles<"self" | "children">;
    export type TGridStructure = Structure<Item<THooks>, TDispatcherFactory, TDispatcherFactory, THooks>;
    abstract class Structure<
        Ancestor extends Item<THooks>,
        Dispatcher extends TDispatcherFactory,
        Children extends TDispatcherFactory,
        Hooks extends THooks,
    > extends Item<Hooks> {
        /**
         * Constructs a new structure instance.
         * @param pDispatcher Reference to the dispatcher.
         * @param fnChildren Creates and returns the child structure.
         * @param pRenderer Reference to the renderer.
         * @param bRender Specifies if the structure needs to be rendered.
         */
        constructor(
            pDispatcher: Dispatcher | undefined,
            fnChildren: ((pParent: Structure<Ancestor, Dispatcher, Children, Hooks>) => Children) | undefined,
            pRenderer: GridRenderer<TGrid> | undefined
        );
        /** Retrieves the parent dispatcher. */
        get parent(): Dispatcher | undefined;
        /** Retrieves the ancestor. */
        get ancestor(): Ancestor | undefined;
        /** Retrieves the children of the structure. */
        get children(): Children | undefined;
        /** Retrieves the grid. */
        get grid(): TGrid | undefined;
        /** Retrieves the branch. */
        get origin(): TGrid | TGridBranch<TGridNode> | undefined;
        /** Retrieves the zoom factor. */
        get zoom(): number;
        /** Sets the zoom factor. */
        set zoom(nZoom: number);
        /** Retrieves the layout. */
        get layout(): GridLayout<TGrid, Structure<Ancestor, Dispatcher, Children, Hooks>> | undefined;
        /** Retrieves the renderer. */
        get renderer(): GridRenderer<TGrid> | undefined;
        /** Sets the renderer. */
        set renderer(pRenderer: GridRenderer<TGrid> | undefined);
        /** Specifies if the structure is rendered. */
        get isRendered(): boolean;
        /** Retrieves the rectangles of the structure. */
        get rectangles(): TGridRectangles;
        /** Retrieves the rectangle of the structure. */
        get rectangle(): Rectangle;
        /** Retrieves the left position of the structure. */
        get left(): number;
        /** Retrieves the top position of the structure. */
        get top(): number;
        /** Retrieves the right position of the structure. */
        get right(): number;
        /** Retrieves the bottom position of the structure. */
        get bottom(): number;
        /** Retrieves the width of the structure. */
        get width(): number;
        /** Retrieves the height of the structure. */
        get height(): number;
        /** Retrieves the horizontal mean of the structure. */
        get meanHorizontal(): number;
        /** Retrieves the vertical mean of the structure. */
        get meanVertical(): number;
        /** Invalidates the rendering. */
        protected renderInvalidate(): void;
        /**
         * Applies the position.
         * @param sType Specifies the change type.
         * @return Returns `true` if the structure position is changed.
         */
        protected applyPosition(sType?: "redraw" | "zoom"): boolean;
        /**
         * Applies a resize.
         * @param sType Specifies the resize type.
         * @param bPropagate Specifies to propagate the resize event.
         * @return Returns `true` if the structure is resized.
         */
        applyResize(sType?: "redraw" | "zoom", bPropagate?: boolean): boolean;
        /**
         * Changes the dimensions of the structure.
         * @param nWidth Specifies the width of the structure.
         * @param nHeight Specifies the height of the structure.
         * @return Returns `true` if the structure is resized.
         */
        resize(nWidth?: number, nHeight?: number): boolean;
        /**
         * Iterate through each descendant of the structure.
         * @param fnStructure Specifies the structure function.
         * @param fnStructure.pStructure Contains a reference to the structure.
         * @return Returns `true` if the iteration is stopped (break).
         */
        abstract forEachDescendant(fnStructure: (pStructure: TGridStructure) => boolean | void): boolean;
        /**
         * Iterate recursively through each descendant of the structure. For each
         * structure (including the structure from which the iteration originates)
         * a function will be invoked. This function should return `true` if the
         * structure needs to be iterated or `false` if the iteration should
         * continue with the next sibling structure.
         * @param fnStructure Specifies the structure function.
         * @param fnStructure.pStructure Contains a reference to the structure.
         * @return Returns the result of the structure function.
         */
        abstract forEachDescendantRecursive(fnStructure: (pStructure: TGridStructure) => boolean | void): boolean;
        /**
         * Renders the structure.
         * @param bRecursive Specifies if the underlying structures needs to be
         * rendered.
         */
        render(bRecursive: boolean): void;
        /**
         * Invokes the layout renderer.
         * @param sType Specifies the rerender type. Can be one of the following values:
         * - `refresh`: Refresh the rendering;
         * - `update`: Update the rendering.
         */
        rerender(sType: "refresh" | "update"): void;
        /**
         * Invoked when the structure is rendered. Can be used to bind events.
         * @event
         */
        onRender(): void;
        /** Resets a structure. */
        reset(): void;
        /** Destroys a structure. */
        destroy(): void;
    }
    export interface ILayout<Grid extends TGrid, Parent extends TGridStructure> {
        /**
         * Specifies the constructor function.
         * @param pParent Specifies a reference to the parent.
         * @param pArguments Specifies additional constructor arguments.
         */
        new (pRenderer: GridRenderer<Grid>, pParent: Parent, ...pArguments: TAny[]): GridLayout<Grid, Parent>;
    }
    export abstract class GridLayout<Grid extends TGrid, Parent extends TGridStructure> {
        /**
         * Constructs a new layout.
         * @param pRenderer Reference to the renderer.
         * @param pParent Reference to the layout parent.
         */
        constructor(pRenderer: GridRenderer<Grid>, pParent: Parent);
        /** Returns the layout configuration. */
        abstract get configuration(): TGridRectangles;
        /** Retrieves a reference to the renderer. */
        get renderer(): GridRenderer<Grid>;
        /** Retrieves a reference to the layout parent. */
        get parent(): Parent;
        /** Retrieves the horizontal offset for the layout. */
        get x(): number;
        /** Retrieves the vertical offset for the layout. */
        get y(): number;
        /**
         * Invooked when the layout is about to resize.
         * @param pRectangles Contains the layout rectangles.
         */
        beforeResize(pRectangles: TGridRectangles): void;
        /**
         * Fired when the z-index is changed.
         * @param nZ Specifies the z-index.
         * @event
         */
        zIndex(nZ: number): void;
        /**
         * Fired when the layout should be elevated.
         * @param bElevate Specifies if the layout is elevated.
         * @event
         */
        onElevate(bElevate: boolean): void;
        /**
         * Fired when an item becomes part of a dispatcher.
         * @event
         */
        onPush(): void;
        /**
         * Fired when an item becomes the first item.
         * @event
         */
        onFirst(): void;
        /**
         * Fired when an item becomes the last item.
         * @event
         */
        onLast(): void;
        /**
         * Specifies the expansion coordinates for the move detection. These
         * coordinates are applied to the rectangle detection. Use it to
         * expand or contract the rectangle.
         * @param nX Specifies the horizontal mouse coordinate.
         * @param nY Specifies the vertical mouse coordinate.
         * @param pTarget Specifies the target resource.
         * @return Returns the expansion coordinates.
         * @event
         */
        onMoveExpansion(nX: number, nY: number, pTarget: TGridResource): Coordinate;
        /**
         * Fired when the system wants to know if the supplied mouse coordinates
         * are within the resource.
         * @param nX Specifies the horizontal mouse coordinate.
         * @param nY Specifies the vertical mouse coordinate.
         * @param pTarget Specifies the target resource.
         * @return Returns `true` if the mouse is within the resource.
         * @event
         */
        onIsMoveIn(nX: number, nY: number, pTarget: TGridResource): boolean;
        /**
         * Specifies the function which is invoked when the move is initialized.
         * @param nDelay Specifies the delay in milliseconds before the movement starts.
         * @param pOffset Contains the touch/click offset relative to the resource.
         * @return Return `true` if the move should be continued.
         * @event
         */
        onMoveInit(nDelay: number, pOffset: IPoint): boolean;
        /**
         * Specifies the function which is invoked when the move starts.
         * @param pOffset Contains the touch/click offset relative to the resource.
         * @return Return `true` if the move should be continued.
         * @event
         */
        onMoveStart(pOffset: IPoint): boolean;
        /**
         * Specifies the function which is invoked when a movement occurs.
         * @param nMouseX Specifies the horizontal mouse coordinate.
         * @param nMouseY Specifies the vertical mouse coordinate.
         * @param bPopped Specifies if the resource is popped. In that case the
         * resource is not inside a parent which can host the resource.
         * @param pOffset Contains the touch/click offset relative to the resource.
         * @return Return `true` if the movement is valid. If you return `false`
         * the item will be popped.
         * @event
         */
        onMove(nMouseX: number, nMouseY: number, bPopped: boolean, pOffset: IPoint): boolean;
        /**
         * Specifies the function which is invoked when the move ends.
         * @param bDragging Specifies if the `MoveStart` event is fired and the
         * resource was in dragging mode.
         * @event
         */
        onMoveEnd(bDragging: boolean): void;
        /**
         * Invoked when the guides of a rendering are changed.
         * @param bVisible Indicates if the guides should be visible.
         * @param nLeft Specifies the left coordinate of the guides.
         * @param nTop Specifies the top coordinate of the guides.
         * @param nWidth Specifies the width of the guides.
         * @param nHeight Specifies the height of the guides.
         * @param nZoom Specifies the zoom factor of the guides.
         * @event
         */
        onGuidesChange(bVisible: boolean, nLeft: number, nTop: number, nWidth: number, nHeight: number, nZoom: number): void;
        /**
         * Renders the layout.
         * @param sType Specifies the render type. Can be one of the following values:
         * - `render`: Do a complete render;
         * - `refresh`: Refresh the rendering;
         * - `update`: Update the rendering.
         */
        abstract render(sType: "render" | "refresh" | "update"): void;
        /**
         * Sets the position of the layout element.
         * @param nLeft Specifies the horizontal position.
         * @param nTop Specifies the vertical position.
         * @param nZoom Contains the zoom factor.
         * @param sReason Specifies the reason for the position change.
         */
        abstract position(nLeft: number, nTop: number, nZoom: number, sReason: "redraw" | "zoom"): void;
        /**
         * Sets the dimensions of the layout element.
         * @param nWidth Specifies the width.
         * @param nHeight Specifies the height.
         * @param nZoom Contains the zoom factor.
         * @param sReason Specifies the reason for the resize.
         */
        abstract resize(nWidth: number, nHeight: number, nZoom: number, sReason: "redraw" | "width" | "height" | "zoom"): void;
        /** Destroys the layout. */
        abstract destroy(): void;
    }
    export interface IType<T extends TGridStructure> {
        /**
         * Specifies the constructor function.
         * @param pArguments Specifies additional constructor arguments.
         */
        new (...pArguments: TAny[]): T;
    }
    export interface IGridLayout<Grid extends TGrid, Type extends TGridStructure> {
        /** Specifies the type constructor. */
        type: IType<Type>;
        /** Specifies the layout. */
        layout: ILayout<Grid, Type>;
    }
    export abstract class GridRenderer<Grid extends TGrid, Types extends TGridStructure = TGridStructure> {
        /**
         * Constructs a new renderer.
         * @param pLayouts Specifies an array of layouts which are rendered.
         */
        constructor(...pLayouts: IGridLayout<Grid, Types>[]);
        /** Retrieves the origin of the rendering. */
        get origin(): Grid | TGridBranch<TGridNode> | undefined;
        /**
         * Provides the layout constructor for the specified parent type.
         * @param pType Reference to the parent type.
         * @return Returns the layout provider.
         */
        protected provider<Type extends TGridStructure>(pType: Type): IGridLayout<Grid, Type>;
        /**
         * Initializes a renderer by supplying an origin to it.
         * @param pOrigin Specifies the origin to attach.
         * @returns Returns a reference to the renderer instance.
         */
        init(pOrigin: Grid | TGridBranch<TGridNode> | undefined): this;
        /**
         * Retrieves a new layout instance for the specified type.
         * @param pType Reference to the parent type.
         * @return Returns the layout instance.
         */
        abstract layout(pType: Types): GridLayout<Grid, Types>;
        /**
         * Fired when the renderer is initialized.
         * @event
         */
        onInit(): void;
        /**
         * Fired when the dimensions of the rendering are changed.
         * @param nWidth Specifies the width.
         * @param nHeight Specifies the height.
         * @param nZoom Contains the zoom factor.
         * @param sReason Specifies the reason for the resize.
         * @event
         */
        onResize(nWidth: number, nHeight: number, nZoom: number, sReason: "redraw" | "width" | "height" | "zoom"): void;
        /**
         * Fired when a move starts.
         * @event
         */
        onMoveStart(): void;
        /**
         * Fired when something is moving.
         * @event
         */
        onMove(): void;
        /**
         * Fired when the moving ends.
         * @event
         */
        onMoveEnd(): void;
    }
    export type TGridResource = Resource<TGridStructure, TDispatcherFactory, TDispatcherFactory, THooks>;
    abstract class Resource<
        Ancestor extends TGridStructure,
        Dispatcher extends TDispatcherFactory,
        Children extends TDispatcherFactory,
        Hooks extends THooks,
    > extends Structure<Ancestor, Dispatcher, Children, Hooks> {
        /**
         * Constructs a new resource instance.
         * @param pDispatcher Reference to the dispatcher.
         * @param fnChildren Creates and returns the child resource.
         * @param pRenderer Reference to the renderer.
         */
        constructor(
            pDispatcher: Dispatcher | undefined,
            fnChildren?: (pParent: Resource<Ancestor, Dispatcher, Children, Hooks>) => Children,
            pRenderer?: GridRenderer<TGrid>
        );
        /** Retrieves if this is the grid. */
        protected get isGrid(): boolean;
        /** Retrieves the grid. */
        get grid(): TGrid | undefined;
        /** Retrieves the origin. */
        get origin(): TGrid | TGridBranch<TGridNode> | undefined;
        /** Returns the z-index. */
        get z(): number;
        /** Contains if the resource is being moved. */
        get isMoving(): boolean;

        /**
         * Fired when a new resource is pushed to the dispatcher. This new resource
         * should be positioned, sized and drawn on the screen.
         * @param pEvent Specifies the event payload.
         * @event
         */
        protected onPush(pEvent: IItemPushEvent<this>): void;
        /**
         * Fired when a resource is changed.
         * @param pEvent Specifies the event payload.
         * @event
         */
        protected onChange(pEvent: IItemChangeEvent<this>): void;
        /**
         * Fired when a resource is popped.
         * @param pEvent Specifies the event payload.
         * @event
         */
        protected onPop(pEvent: IItemPopEvent<this>): void;
        /** Validates the resource. */
        protected onValidate(): void;
        /**
         * Iterate through each descendant of the resource.
         * @param fnResource Specifies the resource function.
         * @param fnResource.pResource Contains a reference to the resource.
         * @return Returns `true` if the iteration is stopped (break).
         */
        forEachDescendant(fnResource: (pResource: TGridResource) => boolean | void): boolean;
        /**
         * Iterate recursively through each descendant of the resource. For each
         * resource (including the resource from which the iteration originates)
         * a function will be invoked. This function should return `true` if the
         * resource needs to be iterated or `false` if the iteration should
         * continue with the next sibling resource.
         * @param fnResource Specifies the resource function.
         * @param fnResource.pResource Contains a reference to the resource.
         * @return Returns the result of the resource function.
         */
        forEachDescendantRecursive(fnResource: (pResource: TGridResource) => boolean | void): boolean;
        /**
         * Calculates the z-index of the resource.
         * @param nZ Specifies the minimum z-index.
         * @return Returns `true` if the z-index is changed.
         */
        zIndex(nZ?: number): boolean;
        /**
         * Calculates the position of the resource.
         * @param nLeft Specifies the left coordinate.
         * @param nTop Specifies the top coordinate.
         * @return Returns `true` if the position is changed.
         */
        position(nLeft?: number, nTop?: number): boolean;
        /**
         * Shifts the position of the resource.
         * @param nHorizontal Specifies the horizontal shift.
         * @param nVertical Specifies the vertical shift.
         */
        shift(nHorizontal: number, nVertical: number): void;
        /**
         * Calculates the dimensions of the resource.
         * @param nWidth Specifies the width of the resource.
         * @param nHeight Specifies the height of the resource.
         * @return Returns `true` if the resource is resized.
         */
        resize(nWidth?: number, nHeight?: number): boolean;
        /**
         * Moves the resource and returns the coordinates with the supplied offset
         * applied.
         * @param nLeft Specifies the left movement.
         * @param nTop Specifies the top movement.
         * @param pOffset Specifies the offset of the touch point in the element.
         * @return Returns the coordinates with the supplied offset.
         */
        move(nLeft?: number, nTop?: number, pOffset?: IPoint): IPoint;
        /** Requests a guides update and invokes the guides layout. */
        guides(): void;
        /** Fired when there is a child pushed or popped. */
        onPushOrPop(): void;
        /**
         * Fired when a resource move is initialized.
         * @param nDelay Specifies the delay before the move occurs.
         * @param pOffset Specifies the offset of the touch point.
         * @return Returns `true` if the move operation is initialized.
         * @event
         */
        onMoveInit(nDelay: number, pOffset: IPoint): boolean;
        /**
         * Fired when a resource move starts.
         * @param pOffset Specifies the offset of the touch point.
         * @return Returns `true` if the move operation is started.
         * @event
         */
        onMoveStart(pOffset: IPoint): boolean;
        /**
         * Fired when a resource move occurs.
         * @param nMoveX Specifies the horizontal movement.
         * @param nMoveY Specifies the vertical movement.
         * @param pOffset Specifies the offset of the touch point.
         * @param sDispatcher Specifies the name of the child dispatcher.
         * @event
         */
        onMove(nMoveX: number, nMoveY: number, pOffset: IPoint, sDispatcher?: string): void;
        /**
         * Specifies the function which is invoked when a movement is validated.
         * @param pDispatcher Reference to the dispatcher.
         * @param nIndex Specifies the desired index for the resource.
         * @param bIsChild Specifies if the resource is already a child of the dispatcher.
         * @return Return `true` if the movement is validated.
         * @event
         */
        onMoveValidate(pDispatcher: TDispatcher, nIndex: number, bIsChild: boolean): boolean;
        /**
         * Fired when a resource move ends.
         * @param bDragging Specifies if the `onMoveStart` event is fired.
         * @event
         */
        onMoveEnd(bDragging: boolean): void;
        /**
         * Generates a serialized representation of a resource.
         * @param sChildren Specified the data name for the child array.
         * @return Returns a reference to the serialized resource.
         */
        serialize(sChildren?: string): IGridResource;
        /**
         * Deserializes to a resource.
         * @param pResource Contains the serialized resource.
         * @param pAfterwards Stack with calls which are invoked after the
         * structural deserialization is done.
         * @param sChildren Specifies the data name for the child array.
         * @param sChildrenFallback Specifies a fallback data name for the child array.
         * @return Returns a reference to the instance.
         */
        deserialize(pResource: IGridResource, pAfterwards: Stack, sChildren?: string, sChildrenFallback?: string): this;
        /** Resets the resource. */
        reset(): void;
        /** Destroys the resource and all of its children. */
        destroy(): void;
    }
    export type TDispatcher = Dispatcher<TGridResource, TGridResource, THooks>;
    export type TDispatcherFactory = Dispatcher<TAny, TAny, THooks>;
    export type TDispatcherEvents<Hooks extends THooks> = Hooks | "OnResize";
    /** Dispatcher constructor template. */
    export interface IDispatcherConstructor<Parent extends TGridResource, T extends TGridResource, Hooks extends THooks> {
        new (pDispatcher: Dispatcher<Parent, T, Hooks>, ...pArguments: TAny[]): T;
    }
    abstract class Dispatcher<Parent extends TGridResource, T extends TGridResource, Hooks extends THooks> extends Matrix<
        T,
        TDispatcherEvents<Hooks>
    > {
        /**
         * Constructs a new dispatcher.
         * @param pType Reference to the dispatcher type.
         * @param pParent Reference to the parent (this is the ancestor of an item).
         * @param nType Specifies the direction.
         * @param nOrientation Specifies the orientation.
         * @param nSize Specifies the size.
         */
        constructor(
            pType: IDispatcherConstructor<Parent, T, Hooks>,
            pParent: Parent,
            nType: Types,
            nOrientation: Orientations,
            nSize: number
        );
        /** Retrieves the grid. */
        get grid(): TGrid | undefined;
        /** Retrieves the dispatcher type. */
        get dispatcher(): IDispatcherConstructor<Parent, T, Hooks>;
        /** Returns a reference to the parent. */
        get parent(): Parent;
        /**
         * Appends an item to the end.
         * @param pItem Reference to the item.
         * @return Returns a reference to the item.
         */
        protected appendItem(pItem: T): T;
        /**
         * Inserts an item at the begin.
         * @param pItem Reference to the item.
         * @return Returns a reference to the item.
         */
        protected insertItem(pItem: T): T;
        /**
         * Inserts an item at the specified index.
         * @param pItem Reference to the item.
         * @param nIndex Specifies the index position.
         * @return Returns a reference to the item.
         */
        protected insertItemAtIndex(pItem: T, nIndex: number): T;
        /**
         * Fired when the dimensions of the dispatcher are changed.
         * @param pEvent Specifies the event payload.
         * @event
         */
        protected onDimensionChange(pEvent: IDimensionChangeEvent<this>): void;
        protected onCountChange(pEvent: ICountChangeEvent<this>): void;
        /**
         * Invoked when the dispatcher dimensions are changed.
         * @event
         */
        onDimensions(): void;
        /**
         * Deserializes the supplied resources to the dispatcher.
         * @param pAfterwards Stack with calls which are invoked after the
         * structural deserialization is done.
         * @param pResources Reference to the resources.
         */
        deserialize(pAfterwards: Stack, ...pResources: IGridResource[]): void;
        /** Resets a dispatcher. */
        reset(): void;
        /** Destroys a dispatcher. */
        destroy(): void;
    }
    /** Nodes constructor template. */
    export interface INodesConstructor<T extends TGridNode> {
        new (
            pNodeConstructor: INodeConstructor<T>,
            pParent: TGridBranch<T> | TGridSection<T>,
            nDimensions?: number,
            sOrientation?: "vertical" | "horizontal"
        ): GridNodes<T, THooks>;
    }
    export abstract class GridNodes<T extends TGridNode, Hooks extends THooks = void> extends Dispatcher<
        TGridBranch<TGridNode> | TGridSection<TGridNode>,
        T,
        Hooks
    > {
        /**
         * Constructs a new `Node` dispatcher.
         * @param pNodeConstructor Reference to the `Node` constructor.
         * @param pParent Specifies the parent `Branch` or `Section`.
         * @param nDimensions Specifies the number of columns for vertical grids
         * or the number of rows for horizontal grids.
         * @param sOrientation Specifies the orientation of the grid.
         */
        constructor(
            pNodeConstructor: INodeConstructor<T>,
            pParent: TGridBranch<TGridNode> | TGridSection<TGridNode>,
            nDimensions?: number,
            sOrientation?: "vertical" | "horizontal"
        );
    }
    /** Node template. */
    export type TGridNode = GridNode<THooks>;
    /** Node constructor template. */
    export interface INodeConstructor<T extends TGridNode> {
        new (pNodes: GridNodes<T, THooks>): T;
    }
    export abstract class GridNode<Hooks extends THooks = void> extends Resource<
        TGridSection<GridNode<Hooks>> | TGridBranch<GridNode<Hooks>>,
        GridNodes<GridNode<Hooks>, THooks>,
        TDispatcher,
        Hooks
    > {
        /**
         * Constructs a new `Node` instance.
         * @param pNodes Reference to the parent `Nodes`.
         */
        constructor(pNodes: GridNodes<GridNode<Hooks>, THooks>);
    }
    /** Sections template. */
    export type TSections<T extends TGridNode> = GridSections<TGridSection<T>, T, THooks>;
    /** Sections constructor template. */
    export interface ISectionsConstructor<T extends TGridNode> {
        new (
            pSectionConstructor: ISectionConstructor<T, TGridSection<T>>,
            pBranch: TGridBranch<T>,
            sOrientation?: "vertical" | "horizontal"
        ): TSections<T>;
    }
    export abstract class GridSections<
        Children extends TGridSection<T>,
        T extends TGridNode,
        Hooks extends THooks = void,
    > extends Dispatcher<GridBranch<TSections<T>, T, THooks>, Children, Hooks> {
        /**
         * Constructs a new `Section` dispatcher.
         * @param pSectionConstructor Reference to the `Section` constructor.
         * @param pBranch Specifies the parent `Branch`.
         * @param sOrientation Specifies the orientation of the grid.
         */
        constructor(
            pSectionConstructor: ISectionConstructor<T, Children>,
            pBranch: GridBranch<TSections<T>, T, THooks>,
            sOrientation?: "vertical" | "horizontal"
        );
    }
    /** Section template. */
    export type TGridSection<T extends TGridNode> = GridSection<GridNodes<T, THooks>, T, THooks>;
    /** Section constructor template. */
    export interface ISectionConstructor<T extends TGridNode, C extends TGridSection<T>> {
        new (pSections: TSections<T>): C;
    }
    export abstract class GridSection<
        Children extends GridNodes<T, THooks>,
        T extends TGridNode,
        Hooks extends THooks = void,
    > extends Resource<GridBranch<TSections<T>, T, THooks>, TSections<T>, Children, Hooks> {
        /**
         * Constructs a new `Section` instance.
         * @param pSections Reference to the parent `Sections`.
         * @param pNodesConstructor Reference to the `Nodes` constructor.
         * @param pNodeConstructor Reference to the `Node` constructor.
         */
        constructor(pSections: TSections<T>, pNodesConstructor: INodesConstructor<T>, pNodeConstructor: INodeConstructor<T>);
    }
    /** Branches template. */
    export type TBranches<T extends TGridNode> = GridBranches<TGridBranch<T>, T, THooks>;
    export abstract class GridBranches<
        Children extends TGridBranch<T>,
        T extends TGridNode,
        Hooks extends THooks = void,
    > extends Dispatcher<TGridSection<T>, Children, Hooks> {
        /**
         * Constructs a new `Branch` dispatcher.
         * @param pBranchConstructor Reference to the `Branch` constructor.
         * @param pSection Specifies the parent `Section`.
         */
        constructor(pBranchConstructor: IBranchConstructor<T, Children>, pSection: TGridSection<T>);
    }
    /** Branch template. */
    export type TGridBranch<T extends TGridNode> = GridBranch<TSections<T>, T, THooks>;
    /** Branch constructor template. */
    export interface IBranchConstructor<T extends TGridNode, B extends TGridBranch<T>> {
        new (
            pBranches: TBranches<T>,
            pSectionsConstructor: ISectionsConstructor<T>,
            pSectionConstructor: ISectionConstructor<T, TGridSection<T>>,
            pRenderer?: GridRenderer<TGrid>
        ): B;
    }
    export abstract class GridBranch<Children extends TSections<T>, T extends TGridNode, Hooks extends THooks = void> extends Resource<
        TGridSection<T>,
        TBranches<T>,
        Children,
        Hooks
    > {
        /**
         * Constructs a new `Branch` instance.
         * @param pBranches Reference to the parent `Branches`.
         * @param pSectionsConstructor Reference to the `Sections` constructor.
         * @param pSectionConstructor Reference to the `Section` constructor.
         * @param pRenderer Reference to a renderer.
         */
        constructor(
            pBranches: TBranches<T> | undefined,
            pSectionsConstructor: ISectionsConstructor<T>,
            pSectionConstructor: ISectionConstructor<T, TGridSection<T>>,
            pRenderer?: GridRenderer<TGrid>
        );
    }
    export type TGrid = Grid<TSections<TGridNode>, TGridNode, THooks>;
    export abstract class Grid<Children extends TSections<T>, T extends TGridNode, Hooks extends THooks = void> extends GridBranch<
        Children,
        T,
        Hooks
    > {
        /**
         * Constructs a new `Grid` instance.
         * @param pSectionsConstructor Reference to the `Sections` constructor.
         * @param pSectionConstructor Reference to the `Section` constructor.
         * @param pRenderer Reference to a renderer.
         */
        constructor(
            pSectionsConstructor: ISectionsConstructor<T>,
            pSectionConstructor: ISectionConstructor<T, TGridSection<T>>,
            pRenderer?: GridRenderer<TGrid>
        );
        /** Retrieves the grid. */
        get grid(): TGrid | undefined;
        /** Retrieves the branch. */
        get origin(): TGrid | TGridBranch<TGridNode> | undefined;
        /** Retrieves the overflow threshold for the grid. */
        get threshold(): number;
        /** Sets the overflow threshold for the grid. */
        set threshold(nThreshold: number);
        /**
         * Deserializes to a grid.
         * @param pGrid Contains the serialized grid.
         * @param pAfterwards Stack with calls which are invoked after the
         * structural deserialization is done.
         * @param sChildren Specified the data name for the child array.
         * @param sChildrenFallback Specifies a fallback data name for the child array.
         * @return Returns a reference to the instance.
         */
        deserialize(pGrid: IGridResource, pAfterwards: Stack, sChildren: string, sChildrenFallback?: string): this;
    }
    export interface IGridResizeEvent extends IHookPayload<"OnResize"> {
        /** Reference to the dispatcher. */
        readonly dispatcher: TDispatcher;
    }
}

declare module "@tripetto/runner/module/hookup" {
    import { TAny } from "@tripetto/runner/module/functional";

    export interface IHookPayload<Name extends THooks> {
        hook: {
            name: Name;
            type: TType;
        };
    }
    export type THooks = string | void;
    export type HookProps<T extends IHookPayload<THooks>> = Pick<T, Exclude<keyof T, "hook">>;
    export type THookContext = Function | {};
    export type TType = "synchronous" | "asynchronous" | "framed";
    export type TFunc<Names extends THooks, Hook extends Names, Payload extends IHookPayload<Hook> = IHookPayload<Hook>> = (
        pPayload: Payload
    ) => void;
    /**
     * Implements the hooks class.
     * @param Names Specifies the available hooks (specify using string literals).
     */
    export class Hooks<Names extends THooks> {
        /** Retrieves if the hooks buffer is enabled. */
        get isHookBufferEnabled(): boolean;

        /**
         * Register a hook.
         * @param sHook Specifies the hook name.
         * @param sType Specifies the hook type.
         * @param fnHook Specifies the hook function.
         * @param pContext Specifies the hook context.
         * @return Returns `this` to allow chaining.
         */
        hook<Hook extends Names, Payload extends IHookPayload<Hook>>(
            sHook: Hook,
            sType: TType,
            fnHook: TFunc<Names, Hook, Payload>,
            pContext?: THookContext
        ): this;
        /**
         * Register a grouped hook.
         * @param sHook Specifies the hook name.
         * @param sType Specifies the hook type.
         * @param fnHook Specifies the hook function.
         * @param pContext Specifies the hook context.
         * @return Returns `this` to allow chaining.
         */
        groupedHook<Hook extends Names, Payload extends IHookPayload<Hook>>(
            sHook: Hook,
            sType: TType,
            fnHook: TFunc<Names, Hook, Payload>,
            pContext?: THookContext
        ): this;
        /**
         * Emits a hook.
         * @param sHook Specifies the hook name.
         * @param pPayload Specifies the payload.
         * @param sMode Specifies the mode. Can be `fifo` or `lifo` (default is `fifo`).
         * @return Returns `true` if the hook is emitted.
         */
        emitHook<Hook extends Names, Payload extends IHookPayload<Hook>>(
            sHook: Hook,
            pPayload: HookProps<Payload>,
            sMode?: "fifo" | "lifo"
        ): boolean;
        /** Enables the hooks buffer. */
        bufferHooks(): void;
        /** Flushes the hooks buffer. */
        flushHooks(): void;
        /**
         * Removes a hook.
         * @param sHook Specifies the hook name.
         * @param pContextOrFunction Specifies the hook context or function to detach.
         * @return Returns `true` if the hook was found and removed.
         */
        unhook<Hook extends Names>(sHook: Hook, pContextOrFunction?: TFunc<Names, Hook> | THookContext): boolean;
        /**
         * Unhooks all hooks from the specifies context.
         * @param pContext Specifies the context.
         * @return Returns `true` if one or more hooks were found and removed for
         * the specifies context.
         */
        unhookContext(pContext: THookContext): boolean;
        /** destroys the hooks (any pending hook emits are flushed synchronous). */
        destroy(): void;
    }
    export interface IHookProperty<Name extends THooks, T extends {}, K extends keyof T> extends IHookPayload<Name> {
        /** Name of the property. */
        property: K;
        /** Value of the property. */
        value: T[K];
    }
    /**
     * Binds a hook to a property.
     * @param sHook Specifies the hook to attach.
     */
    export function hookup<T extends Hooks<TAny>, Hook extends THooks>(
        sHook: Hook
    ): (pTarget: T, sProperty: string, pDescriptor?: PropertyDescriptor) => void;
}

declare module "@tripetto/runner/module/l10n" {
    export interface IDomain {
        /** Specifies the locale (language[_territory]). */
        readonly locale: string;
        /** Specifies the language in english. */
        readonly language: string;
        /** Specifies the language in the native language. */
        readonly native: string;
    }
    export type TTranslation = {
        "": {
            readonly language?: string;
            readonly "plural-forms"?: string;
            readonly "plural-family"?: string;
        };
    } & {
        [id: string]: [null | string, ...string[]] | [null | string, [string]];
    };
    export class Translation {
        /**
         * Constructs a new domain.
         * @param pTranslation Reference to the translation data.
         */
        constructor(pTranslation: TTranslation);
        /** Retrieves the number of plurals. */
        get plurals(): number;
        /**
         * Enriches the domains with more translations.
         * @param pTranslation Reference to the translation.
         * @param bOverwrite Specifies if translations should be overwritten.
         */
        enrich(pTranslation: TTranslation, bOverwrite: boolean): void;
        /**
         * Retrieves the plural index for the supplied count.
         * @param nCount Specifies the count.
         * @return Returns the plural index.
         */
        plural(nCount: number): number;
        /**
         * Retrieves the translation for the specified message identifier or string.
         * @param sId Specifies the message identifier or string to retrieve.
         * @return Returns an array with translation strings.
         */
        translation(sId: string): [null | string, ...string[]] | [null | string, [string]] | undefined;
    }
    export const CONTEXT_SEPARATOR = "\u0004";
    export class Translations {
        /** Retrieves a list of loaded domains. */
        static get domains(): string[];
        /** Retrieves the default language. */
        static get default(): string;
        /** Sets the default domain. */
        static set default(sDomain: string);
        /** Retrieves the current domain. */
        static get current(): string;
        /** Sets the current domain. */
        static set current(sDomain: string);
        /**
         * Loads translation domains.
         * @param pTranslation Specifies the translation domains.
         * @param bMakeCurrent Specifies if the translation domain should be selected as current domain.
         * @param sMode Specifies if the translation domain needs to be enriched, overwritten or completely replaced.
         * @return Returns `true` if the domain is loaded.
         */
        static load(
            pTranslation: TTranslation | TTranslation[],
            bMakeCurrent?: boolean | "only-when-no-domain",
            sMode?: "enrich" | "overwrite" | "replace"
        ): boolean;
        /**
         * Unloads translations.
         * @param sDomain Specifies the domain to unload. If omitted all domains are unloaded.
         */
        static unload(sDomain?: string): void;
        /**
         * Verifies if the specified domain is loaded.
         * @param sDomain Specifies the language domain identifier.
         */
        static isLoaded(sDomain: string): boolean;
        /**
         * Resets all translations and activate the default domain.
         * @param sCurrent Specifies the language to reset the current domain to.
         */
        static reset(sCurrent?: string): void;
        /**
         * Translates the specified message.
         * @param sDomain Specifies the language domain identifier.
         * @param sContext Specifies the context of the message.
         * @param sId Specifies the message identifier or string to translate.
         * @param nCount Specifies the count for the plural.
         * @param bPlural Specifies if the message is a plural string.
         * @param sPluralId Specifies the plural message identifier or string to translate.
         * @param pArguments Specifies an array with string arguments which can be referenced in the context string using the percent sign
         * followed by the argument index `%n`. The first argument is referenced with `%1`.
         * @return Returns the formatted string.
         */
        static translate(
            sDomain: string,
            sContext: string,
            sId: string,
            bPlural?: boolean,
            sPluralId?: string,
            nCount?: number,
            ...pArguments: string[]
        ): string;

        /** Retrieves a list of loaded domains. */
        get domains(): string[];
        /** Retrieves the default language. */
        get default(): string;
        /** Sets the default domain. */
        set default(sDomain: string);
        /** Retrieves the current domain. */
        get current(): string;
        /** Sets the current domain. */
        set current(sDomain: string);
        /**
         * Loads translation domains.
         * @param pTranslation Specifies the translation domains.
         * @param bMakeCurrent Specifies if the translation domain should be selected as current domain.
         * @param sMode Specifies if the translation domain needs to be enriched, overwritten or completely replaced.
         * @return Returns `true` if the domain is loaded.
         */
        load(
            pTranslation: TTranslation | TTranslation[],
            bMakeCurrent: boolean | "only-when-no-domain",
            sMode: "enrich" | "overwrite" | "replace"
        ): boolean;
        /**
         * Unloads translations.
         * @param sDomain Specifies the domain to unload. If omitted all domains are unloaded.
         */
        unload(sDomain?: string): void;
        /**
         * Verifies if the specified domain is loaded.
         * @param sDomain Specifies the language domain identifier.
         */
        isLoaded(sDomain: string): boolean;
        /**
         * Resets all translations and activate the default domain.
         * @param sCurrent Specifies the language to reset the current domain to.
         */
        reset(sCurrent?: string): void;
        /**
         * Translates the specified message.
         * @param sDomain Specifies the language domain identifier.
         * @param sContext Specifies the context of the message.
         * @param sId Specifies the message identifier or string to translate.
         * @param nCount Specifies the count for the plural.
         * @param bPlural Specifies if the message is a plural string.
         * @param sPluralId Specifies the plural message identifier or string to translate.
         * @param pArguments Specifies an array with string arguments which can be referenced in the context string using the percent sign
         * followed by the argument index `%n`. The first argument is referenced with `%1`.
         * @return Returns the formatted string.
         */
        translate(
            sDomain: string,
            sContext: string,
            sId: string,
            bPlural: boolean,
            sPluralId: string,
            nCount: number,
            ...pArguments: string[]
        ): string;
    }
    /** Describes a locale string. */
    export interface ILocaleString {
        readonly full: string;
        readonly long: string;
        readonly medium: string;
        readonly short: string;
    }
    /**
     * Describes the locale formats.
     * @param T Specifies the formatting type.
     */
    export interface ILocaleFormatting<T> {
        readonly formatted: T;
        readonly nominative: T;
    }
    /** Describes a locale number. */
    export interface ILocaleNumber {
        readonly decimals: string;
        readonly grouping: string;
        readonly minus: string;
    }
    /** Describes the locale months. */
    export interface ILocaleMonths {
        readonly abbreviated: string[];
        readonly narrow: string[];
        readonly wide: string[];
    }
    /** Describes the locale days. */
    export interface ILocaleDays {
        readonly abbreviated: string[];
        readonly narrow: string[];
        readonly short: string[];
        readonly wide: string[];
    }
    /** Describes the locale time. */
    export interface ILocaleTime {
        readonly AM: string;
        readonly PM: string;
    }
    /** Describes the locale translations. */
    export interface ILocaleTranslations {
        readonly months: ILocaleFormatting<ILocaleMonths>;
        readonly days: ILocaleFormatting<ILocaleDays>;
        readonly time: ILocaleTime;
    }
    /**  Describes the locale formats. */
    export interface ILocaleFormats {
        readonly date: ILocaleString;
        readonly time: ILocaleString;
        readonly dateTime: ILocaleString;
        readonly numbers: ILocaleNumber;
    }
    /**  Describes a locale. */
    export interface ILocale {
        readonly locale: string;
        readonly domain: string;
        readonly direction: "ltr" | "rtl";
        readonly countryCode: string;
        readonly country: string;
        readonly countryNative: string;
        readonly language: string;
        readonly languageNative: string;
        readonly translations: ILocaleTranslations;
        readonly formats: ILocaleFormats;
    }
    const DEFAULTS: ILocale;
    export class Locales {
        /** Retrieves the locale information for the current locale. */
        static get locale(): ILocale;
        /** Retrieves the locale identifier string. */
        static get identifier(): string;
        /** Retrieves the domain for the current locale. */
        static get domain(): string;
        /** Retrieves the country code for the active locale. */
        static get countryCode(): string;
        /** Retrieves the country for the active locale. */
        static get country(): string;
        /** Retrieves the native country name for the active locale. */
        static get countryNative(): string;
        /** Retrieves the language for the active locale. */
        static get language(): string;
        /** Retrieves the language in the native language for the active locale. */
        static get languageNative(): string;
        /** Retrieves the text direction for the active locale. */
        static get direction(): "ltr" | "rtl";
        /** Retrieves a list of locales. */
        static get locales(): string[];
        /** Retrieves a list of domains. Each domain contains the locale, language and native language string. */
        static get domains(): IDomain[];
        /**
         * Verifies if the specified locale is loaded.
         * @param sLocale Specifies the locale identifier.
         * @return Returns `true` if the locale is loaded.
         */
        static isLoaded(sLocale: string): boolean;
        /**
         * Loads the specified locale profiles.
         * @param pLocale Specifies the locale profile (multiple profiles can be supplied).
         * @param bSelect Specifies if the locale needs to be selected as active
         * locale (default is `true`, but only when a single locale is supplied).
         * @return Returns `true` if the locale data is loaded.
         */
        static load(pLocale: ILocale | ILocale[], bSelect?: boolean): boolean;
        /**
         * Retrieves the specified locale (or the current locale if no locale identifier is specified).
         * @param sLocale Specifies the locale identifier.
         * @return Returns the locale.
         */
        static get(sLocale?: string): ILocale;
        /**
         * Sets the current locale.
         * @param sLocale Specifies the locale identifier.
         * @return Returns `true` if the locale is set.
         */
        static set(sLocale: string): boolean;
        /**
         * Tries to find the most significant domain (ignoring case).
         * @param sDomain Specifies the domain.
         * @return Returns the domain string.
         */
        static findDomain(sDomain: string | undefined): string;
        /**
         * Retrieves domain information for the specified locale (or the current locale if no locale identifier is specified).
         * @param sLocale Specifies the locale identifier.
         * @return Returns the locale.
         */
        static getDomain(sLocale?: string): IDomain;
        /**
         * Formats a number by inserting thousands and decimal separators while taking rounding into account.
         * @param nValue Input value as a number or string.
         * @param nPrecision Specifies the precision (set it to `auto` to allow floating point numbers with automatic precision detection).
         * @param bThousands Specifies if thousands separators should be inserted.
         * @param sLocale Specifies the locale to use.
         * @return Returns the formatted number as a string.
         */
        static number(nValue: number | string, nPrecision?: number | "auto", bThousands?: boolean, sLocale?: string): string;
        /**
         * Formats a date/time string.
         * @param sFormat Specifies the format to use, using the CLDR date/time formatting style. The following variables are available:
         * - `y` / `yyyy`: Specifies the full 4-digit year;
         * - `yy`: Specifies the 2-digit year;
         * - `M`: Specifies the month number;
         * - `MM`: Specifies the month number with a minimum of 2 digits;
         * - `MMM`: Specifies the month as an abbreviated string (e.g. `Jan`);
         * - `MMMM`: Specifies the month as a full string (e.g. `January`);
         * - `MMMMM`: Specifies the month as a narrow (e.g. `J`);
         * - `LLL`: Specifies the month as an abbreviated nominative string (e.g. `Jan`);
         * - `LLLL`: Specifies the month as a full nominative string (e.g. `January`);
         * - `LLLLL`: Specifies the month as a narrow nominative string (e.g. `J`);
         * - `d`: Specifies the day of the month;
         * - `dd`: Specifies the day of the month with a minimum of 2 digits;
         * - `E`: Specifies the day of the week;
         * - `EE`: Specifies the day of the week as a string (e.g. `Su`);
         * - `EEE`: Specifies the day of the week as an abbreviated string (e.g. `Sun`);
         * - `EEEE`: Specifies the day of the week as a full string (e.g. `Sunday`);
         * - `EEEEE`: Specifies the day of the week as a narrow string (e.g. `S`);
         * - `cc`: Specifies the day of the week as a nominative string (e.g. `Su`);
         * - `ccc`: Specifies the day of the week as an abbreviated nominative string  (e.g. `Sun`);
         * - `cccc`: Specifies the day of the week as a full nominative string (e.g. `Sunday`);
         * - `ccccc`: Specifies the day of the week as a narrow nominative string (e.g. `S`);
         * - `H`: Specifies the number of hours in 24-hour format;
         * - `HH`: Specifies the number of hours in 24-hour format  with a minimum of 2 digits;
         * - `h`: Specifies the number of hours in 12-hour format;
         * - `hh`: Specifies the number of hours in 12-hour format  with a minimum of 2 digits;
         * - `a`: Specifies the `AM` or `PM` hour suffix;
         * - `m`: Specifies the number of minutes;
         * - `mm`: Specifies the number of minutes with a minimum of 2 digits;
         * - `s`: Specifies the number of seconds;
         * - `ss`: Specifies the number of seconds with a minimum of 2 digits;
         * - `S`: Specifies the number of milliseconds;
         * - `SSS`: Specifies the number of milliseconds with a minimum of 3 digits.
         * @param nTime Specifies the date/time to format. If this value is not specified `Now` will be used.
         * @param bUTC Specifies if the UTC time needs to be used.
         * @param sLocale Specifies the locale to use.
         * @return Returns the formatted date string.
         * @see http://cldr.unicode.org/translation/date-time
         */
        static dateTime(sFormat: string, nTime?: number, bUTC?: boolean, sLocale?: string): string;
        /**
         * Formats a full date string.
         * @param nTime Specifies the date to format. If this value is not specified `Now` will be used.
         * @param bUTC Specifies if the UTC time needs to be used.
         * @param sLocale Specifies the locale to use.
         * @return Returns the formatted date string.
         */
        static dateFull(nTime?: number, bUTC?: boolean, sLocale?: string): string;
        /**
         * Formats a long date string.
         * @param nTime Specifies the date to format. If this value is not specified `Now` will be used.
         * @param bUTC Specifies if the UTC time needs to be used.
         * @param sLocale Specifies the locale to use.
         * @return Returns the formatted date string.
         */
        static dateLong(nTime?: number, bUTC?: boolean, sLocale?: string): string;
        /**
         * Formats a medium date string.
         * @param nTime Specifies the date to format. If this value is not specified `Now` will be used.
         * @param bUTC Specifies if the UTC time needs to be used.
         * @param sLocale Specifies the locale to use.
         * @return Returns the formatted date string.
         */
        static dateMedium(nTime?: number, bUTC?: boolean, sLocale?: string): string;
        /**
         * Formats a short date string.
         * @param nTime Specifies the date to format. If this value is not specified `Now` will be used.
         * @param bUTC Specifies if the UTC time needs to be used.
         * @param sLocale Specifies the locale to use.
         * @return Returns the formatted date string.
         */
        static dateShort(nTime?: number, bUTC?: boolean, sLocale?: string): string;
        /**
         * Formats a full time string.
         * @param nTime Specifies the time to format. If this value is not specified `Now` will be used.
         * @param bUTC Specifies if the UTC time needs to be used.
         * @param sLocale Specifies the locale to use.
         * @return Returns the formatted time string.
         */
        static timeFull(nTime?: number, bUTC?: boolean, sLocale?: string): string;
        /**
         * Formats a long time string.
         * @param nTime Specifies the time to format. If this value is not specified `Now` will be used.
         * @param bUTC Specifies if the UTC time needs to be used.
         * @param sLocale Specifies the locale to use.
         * @return Returns the formatted time string.
         */
        static timeLong(nTime?: number, bUTC?: boolean, sLocale?: string): string;
        /**
         * Formats a medium time string.
         * @param nTime Specifies the time to format. If this value is not specified `Now` will be used.
         * @param bUTC Specifies if the UTC time needs to be used.
         * @param sLocale Specifies the locale to use.
         * @return Returns the formatted time string.
         */
        static timeMedium(nTime?: number, bUTC?: boolean, sLocale?: string): string;
        /**
         * Formats a short time string.
         * @param nTime Specifies the time to format. If this value is not specified `Now` will be used.
         * @param bUTC Specifies if the UTC time needs to be used.
         * @param sLocale Specifies the locale to use.
         * @return Returns the formatted time string.
         */
        static timeShort(nTime?: number, bUTC?: boolean, sLocale?: string): string;
        /**
         * Formats a full date/time string.
         * @param nTime Specifies the date/time to format. If this value is not specified `Now` will be used.
         * @param bUTC Specifies if the UTC time needs to be used.
         * @param sLocale Specifies the locale to use.
         * @return Returns the formatted date/time string.
         */
        static dateTimeFull(nTime?: number, bUTC?: boolean, sLocale?: string): string;
        /**
         * Formats a long date/time string.
         * @param nTime Specifies the date/time to format. If this value is not specified `Now` will be used.
         * @param bUTC Specifies if the UTC time needs to be used.
         * @param sLocale Specifies the locale to use.
         * @return Returns the formatted date/time string.
         */
        static dateTimeLong(nTime?: number, bUTC?: boolean, sLocale?: string): string;
        /**
         * Formats a medium date/time string.
         * @param nTime Specifies the date/time to format. If this value is not specified `Now` will be used.
         * @param bUTC Specifies if the UTC time needs to be used.
         * @param sLocale Specifies the locale to use.
         * @return Returns the formatted date/time string.
         */
        static dateTimeMedium(nTime?: number, bUTC?: boolean, sLocale?: string): string;
        /**
         * Formats a short date/time string.
         * @param nTime Specifies the date/time to format. If this value is not specified `Now` will be used.
         * @param bUTC Specifies if the UTC time needs to be used.
         * @param sLocale Specifies the locale to use.
         * @return Returns the formatted date/time string.
         */
        static dateTimeShort(nTime?: number, bUTC?: boolean, sLocale?: string): string;
        /** Retrieves the locale information for the current locale. */
        get locale(): ILocale;
        /** Retrieves the locale identifier string. */
        get identifier(): string;
        /** Retrieves the domain for the current locale. */
        get domain(): string;
        /** Retrieves the country code for the active locale. */
        get countryCode(): string;
        /** Retrieves the country for the active locale. */
        get country(): string;
        /** Retrieves the native country name for the active locale. */
        get countryNative(): string;
        /** Retrieves the language for the active locale. */
        get language(): string;
        /** Retrieves the language in the native language for the active locale. */
        get languageNative(): string;
        /** Retrieves the text direction. */
        get direction(): "ltr" | "rtl";
        /**
         * Loads the specified locale profile and activates it.
         * @param pLocale Specifies the locale profile.
         * @return Returns `true` if the locale data is loaded.
         */
        load(pLocale: ILocale): boolean;
        /**
         * Sets the current locale.
         * @param sLocale Specifies the locale identifier.
         * @return Returns `true` if the locale is set.
         */
        set(sLocale: string): boolean;
        /**
         * Formats a number by inserting thousands and decimal separators while taking rounding into account.
         * @param nValue Input value as a number or string.
         * @param nPrecision Specifies the precision (set it to `auto` to allow floating point numbers with automatic precision detection).
         * @param bThousands Specifies if thousands separators should be inserted.
         * @return Returns the formatted number as a string.
         */
        number(nValue: number | string, nPrecision?: number | "auto", bThousands?: boolean): string;
        /**
         * Formats a date/time string.
         * @param sFormat Specifies the format to use, using the CLDR date/time formatting style. The following variables are available:
         * - `y` / `yyyy`: Specifies the full 4-digit year;
         * - `yy`: Specifies the 2-digit year;
         * - `M`: Specifies the month number;
         * - `MM`: Specifies the month number with a minimum of 2 digits;
         * - `MMM`: Specifies the month as an abbreviated string (e.g. `Jan`);
         * - `MMMM`: Specifies the month as a full string (e.g. `January`);
         * - `MMMMM`: Specifies the month as a narrow (e.g. `J`);
         * - `LLL`: Specifies the month as an abbreviated nominative string (e.g. `Jan`);
         * - `LLLL`: Specifies the month as a full nominative string (e.g. `January`);
         * - `LLLLL`: Specifies the month as a narrow nominative string (e.g. `J`);
         * - `d`: Specifies the day of the month;
         * - `dd`: Specifies the day of the month with a minimum of 2 digits;
         * - `E`: Specifies the day of the week;
         * - `EE`: Specifies the day of the week as a string (e.g. `Su`);
         * - `EEE`: Specifies the day of the week as an abbreviated string (e.g. `Sun`);
         * - `EEEE`: Specifies the day of the week as a full string (e.g. `Sunday`);
         * - `EEEEE`: Specifies the day of the week as a narrow string (e.g. `S`);
         * - `cc`: Specifies the day of the week as a nominative string (e.g. `Su`);
         * - `ccc`: Specifies the day of the week as an abbreviated nominative string  (e.g. `Sun`);
         * - `cccc`: Specifies the day of the week as a full nominative string (e.g. `Sunday`);
         * - `ccccc`: Specifies the day of the week as a narrow nominative string (e.g. `S`);
         * - `H`: Specifies the number of hours in 24-hour format;
         * - `HH`: Specifies the number of hours in 24-hour format  with a minimum of 2 digits;
         * - `h`: Specifies the number of hours in 12-hour format;
         * - `hh`: Specifies the number of hours in 12-hour format  with a minimum of 2 digits;
         * - `a`: Specifies the `AM` or `PM` hour suffix;
         * - `m`: Specifies the number of minutes;
         * - `mm`: Specifies the number of minutes with a minimum of 2 digits;
         * - `s`: Specifies the number of seconds;
         * - `ss`: Specifies the number of seconds with a minimum of 2 digits;
         * - `S`: Specifies the number of milliseconds;
         * - `SSS`: Specifies the number of milliseconds with a minimum of 3 digits.
         * @param nTime Specifies the date/time to format. If this value is not specified `Now` will be used.
         * @param bUTC Specifies if the UTC time needs to be used.
         * @return Returns the formatted date string.
         * @see http://cldr.unicode.org/translation/date-time
         */
        dateTime(sFormat: string, nTime?: number, bUTC?: boolean): string;
        /**
         * Formats a full date string.
         * @param nTime Specifies the date to format. If this value is not specified `Now` will be used.
         * @param bUTC Specifies if the UTC time needs to be used.
         * @return Returns the formatted date string.
         */
        dateFull(nTime?: number, bUTC?: boolean): string;
        /**
         * Formats a long date string.
         * @param nTime Specifies the date to format. If this value is not specified `Now` will be used.
         * @param bUTC Specifies if the UTC time needs to be used.
         * @param sLocale Specifies the locale to use.
         * @return Returns the formatted date string.
         */
        dateLong(nTime?: number, bUTC?: boolean): string;
        /**
         * Formats a medium date string.
         * @param nTime Specifies the date to format. If this value is not specified `Now` will be used.
         * @param bUTC Specifies if the UTC time needs to be used.
         * @param sLocale Specifies the locale to use.
         * @return Returns the formatted date string.
         */
        dateMedium(nTime?: number, bUTC?: boolean): string;
        /**
         * Formats a short date string.
         * @param nTime Specifies the date to format. If this value is not specified `Now` will be used.
         * @param bUTC Specifies if the UTC time needs to be used.
         * @param sLocale Specifies the locale to use.
         * @return Returns the formatted date string.
         */
        dateShort(nTime?: number, bUTC?: boolean): string;
        /**
         * Formats a full time string.
         * @param nTime Specifies the time to format. If this value is not specified `Now` will be used.
         * @param bUTC Specifies if the UTC time needs to be used.
         * @param sLocale Specifies the locale to use.
         * @return Returns the formatted time string.
         */
        timeFull(nTime?: number, bUTC?: boolean): string;
        /**
         * Formats a long time string.
         * @param nTime Specifies the time to format. If this value is not specified `Now` will be used.
         * @param bUTC Specifies if the UTC time needs to be used.
         * @param sLocale Specifies the locale to use.
         * @return Returns the formatted time string.
         */
        timeLong(nTime?: number, bUTC?: boolean): string;
        /**
         * Formats a medium time string.
         * @param nTime Specifies the time to format. If this value is not specified `Now` will be used.
         * @param bUTC Specifies if the UTC time needs to be used.
         * @param sLocale Specifies the locale to use.
         * @return Returns the formatted time string.
         */
        timeMedium(nTime?: number, bUTC?: boolean): string;
        /**
         * Formats a short time string.
         * @param nTime Specifies the time to format. If this value is not specified `Now` will be used.
         * @param bUTC Specifies if the UTC time needs to be used.
         * @param sLocale Specifies the locale to use.
         * @return Returns the formatted time string.
         */
        timeShort(nTime?: number, bUTC?: boolean): string;
        /**
         * Formats a full date/time string.
         * @param nTime Specifies the date/time to format. If this value is not specified `Now` will be used.
         * @param bUTC Specifies if the UTC time needs to be used.
         * @param sLocale Specifies the locale to use.
         * @return Returns the formatted date/time string.
         */
        dateTimeFull(nTime?: number, bUTC?: boolean): string;
        /**
         * Formats a long date/time string.
         * @param nTime Specifies the date/time to format. If this value is not specified `Now` will be used.
         * @param bUTC Specifies if the UTC time needs to be used.
         * @param sLocale Specifies the locale to use.
         * @return Returns the formatted date/time string.
         */
        dateTimeLong(nTime?: number, bUTC?: boolean): string;
        /**
         * Formats a medium date/time string.
         * @param nTime Specifies the date/time to format. If this value is not specified `Now` will be used.
         * @param bUTC Specifies if the UTC time needs to be used.
         * @param sLocale Specifies the locale to use.
         * @return Returns the formatted date/time string.
         */
        dateTimeMedium(nTime?: number, bUTC?: boolean): string;
        /**
         * Formats a short date/time string.
         * @param nTime Specifies the date/time to format. If this value is not specified `Now` will be used.
         * @param bUTC Specifies if the UTC time needs to be used.
         * @param sLocale Specifies the locale to use.
         * @return Returns the formatted date/time string.
         */
        dateTimeShort(nTime?: number, bUTC?: boolean): string;
    }
    /**
     * # L10n
     *
     * This module contains the localization functions. This is based on the GNU `gettext` approach (https://www.gnu.org/software/gettext/).
     *
     * ## Examples
     *
     * ```typescript
     * // Translate plain text
     * gettext('Lorem ipsum dolor sit amet');
     *
     * // Translate plain text with shorthand
     * _('Lorem ipsum dolor sit amet');
     *
     * // Translate text with arguments
     * gettext('Hello %1', 'there');
     * _('Hello %1', 'there');
     *
     * // Plural forms
     * ngettext('1 user', '%1 users', 2);
     * _n('1 user', '%1 users', 2);
     * ```
     */
    /**
     * Translates a string using the default language.
     * @param sId Specifies the message identifier or string to translate.
     * @param pArguments Optional string arguments which can be referenced in the translation string using the percent sign followed by
     * the argument index `%n`. The first argument is referenced with `%1`.
     * @return Returns the translated string.
     */
    export function gettext(sId: string, ...pArguments: string[]): string;
    /**
     * Translates a string using the specified language domain.
     * @param sDomain Specifies the language domain identifier.
     * @param sId Specifies the message identifier or string to translate.
     * @param pArguments Optional string arguments which can be referenced in the translation string using the percent sign followed by
     * the argument index `%n`. The first argument is referenced with `%1`.
     * @return Returns the translated string.
     */
    export function dgettext(sDomain: string, sId: string, ...pArguments: string[]): string;
    /**
     * Translates a plural string using the default language.
     * @param sId Specifies the message identifier or string to translate.
     * @param sPluralId Specifies the plural message identifier or string to translate.
     * @param nCount Specifies the count for the plural.
     * @param pArguments Optional string arguments which can be referenced in the translation string using the percent sign followed by
     * the argument index `%n`. The count value `nCount` is automatically included as the first argument (`%1`).
     * @return Returns the translated string.
     */
    export function ngettext(sId: string, sPluralId: string, nCount: number, ...pArguments: string[]): string;
    /**
     * Translates a plural string using the specified language domain.
     * @param sDomain Specifies the language domain identifier.
     * @param sId Specifies the message identifier or string to translate.
     * @param sPluralId Specifies the plural message identifier or string to translate.
     * @param nCount Specifies the count for the plural.
     * @param pArguments Optional string arguments which can be referenced in the translation string using the percent sign followed by
     * the argument index `%n`. The count value `nCount` is automatically included as the first argument (`%1`).
     * @return Returns the translated string.
     */
    export function dngettext(sDomain: string, sId: string, sPluralId: string, nCount: number, ...pArguments: string[]): string;
    /**
     * Translates a string from a specific context using the default language.
     * @param sContext Specifies the translation context.
     * @param sId Specifies the message identifier or string to translate.
     * @param pArguments Optional string arguments which can be referenced in the translation string using the percent sign followed by
     * the argument index `%n`. The first argument is referenced with `%1`.
     * @return Returns the translated string.
     */
    export function pgettext(sContext: string, sId: string, ...pArguments: string[]): string;
    /**
     * Translates a string from a specific context using the specified language domain.
     * @param sDomain Specifies the language domain identifier.
     * @param sContext Specifies the translation context.
     * @param sId Specifies the message identifier or string to translate.
     * @param pArguments Optional string arguments which can be referenced in the translation string using the percent sign followed by
     * the argument index `%n`. The first argument is referenced with `%1`.
     * @return Returns the translated string.
     */
    export function dpgettext(sDomain: string, sContext: string, sId: string, ...pArguments: string[]): string;
    /**
     * Translates a plural string using the default language.
     * @param sContext Specifies the translation context.
     * @param sId Specifies the message identifier or string to translate.
     * @param sPluralId Specifies the plural message identifier or string to translate.
     * @param nCount Specifies the count for the plural.
     * @param pArguments Optional string arguments which can be referenced in the translation string using the percent sign followed by
     * the argument index `%n`. The count value `nCount` is automatically included as the first argument (`%1`).
     * @return Returns the translated string.
     */
    export function npgettext(sContext: string, sId: string, sPluralId: string, nCount: number, ...pArguments: string[]): string;
    /**
     * Translates a plural string using the specified language domain.
     * @param sDomain Specifies the language domain identifier.
     * @param sContext Specifies the translation context.
     * @param sId Specifies the message identifier or string to translate.
     * @param sPluralId Specifies the plural message identifier or string to translate.
     * @param nCount Specifies the count for the plural.
     * @param pArguments Optional string arguments which can be referenced in the translation string using the percent sign followed by
     * the argument index `%n`. The count value `nCount` is automatically included as the first argument (`%1`).
     * @return Returns the translated string.
     */
    export function dnpgettext(
        sDomain: string,
        sContext: string,
        sId: string,
        sPluralId: string,
        nCount: number,
        ...pArguments: string[]
    ): string;
    /**
     * Translates a string using the default language (short version for `gettext`).
     * @param sId Specifies the message identifier or string to translate.
     * @param pArguments Optional string arguments which can be referenced in the translation string using the percent sign followed by
     * the argument index `%n`. The first argument is referenced with `%1`.
     * @return Returns the translated string.
     */
    export function _(sId: string, ...pArguments: string[]): string;
    /**
     * Translates a plural string using the default language (short version for `ngettext`).
     * @param sId Specifies the message identifier or string to translate.
     * @param sPluralId Specifies the plural message identifier or string to translate.
     * @param nCount Specifies the count for the plural.
     * @param pArguments Optional string arguments which can be referenced in the translation string using the percent sign followed
     * by the argument index `%n`. The count value `nCount` is automatically included as the first argument (`%1`).
     * @return Returns the translated string.
     */
    export function _n(sId: string, sPluralId: string, nCount: number, ...pArguments: string[]): string;
    export interface IPlural {
        readonly rules: string[];
        readonly expression: string;
        readonly locales: string[];
        readonly fn: (n: number) => number;
    }
    export interface IPluralRule extends IPlural {
        readonly family: string;
    }
    export class Plurals {
        /** Retrieves a list of plural rules. */
        static get rules(): IPluralRule[];
        /** Retrieves a list of locals with their plural rules. */
        static get locales(): {
            [locale: string]: IPluralRule | undefined;
        };
        /**
         * Retrieves the plural for the specified locale.
         * @param locale Specifies the local (if omitted the current locale will be used).
         * @return Returns the plural information or `undefined` if not found.
         */
        static getForLocale(locale?: string): IPluralRule | undefined;
        /**
         * Retrieves the plural for the specified family.
         * @param family Specifies the family.
         * @return Returns the plural information or `undefined` if not found.
         */
        static getForFamily(family: string): IPluralRule | undefined;
        static getForExpression(expression: string): IPluralRule | undefined;
    }
    export class Namespace {
        /** Retrieves the global namespace (using the global translation and locale). */
        static get global(): Namespace;
        /** Creates a namespace with the specified identifier. */
        static create(identifier: string): Namespace;
        /** Retrieves a translation namespace with a global locale. */
        static translation(identifier: string): Namespace;

        /** Retrieves a reference to the locale instance. */
        get locale(): typeof Locales | Locales;
        /** Retrieves the default translation domain. */
        get default(): string;
        /** Sets the default translation domain. */
        set default(d: string);
        /** Retrieves the current translation domain. */
        get current(): string;
        /** Sets the current translation domain. */
        set current(c: string);
        /** Retrieves a list of loaded domains. */
        get domains(): string[];
        /**
         * Loads translation domains.
         * @param pTranslation Specifies the translation domains.
         * @param bMakeCurrent Specifies if the translation domain should be selected as current domain.
         * @param sMode Specifies if the translation domain needs to be enriched, overwritten or completely replaced.
         * @return Returns `true` if the domain is loaded.
         */
        get load(): (
            pTranslation: TTranslation | TTranslation[],
            bMakeCurrent?: boolean | "only-when-no-domain",
            sMode?: "enrich" | "overwrite" | "replace"
        ) => boolean;
        /**
         * Unloads translations.
         * @param sDomain Specifies the domain to unload. If omitted all domains are unloaded.
         */
        get unload(): (sDomain?: string) => void;
        /**
         * Verifies if the specified domain is loaded.
         * @param sDomain Specifies the language domain identifier.
         */
        get isLoaded(): (sDomain: string) => boolean;
        /**
         * Resets all translations and activate the default domain.
         * @param sCurrent Specifies the language to reset the current domain to.
         */
        get reset(): (sCurrent?: string) => void;
        /**
         * Translates a string using the default language.
         * @param sId Specifies the message identifier or string to translate.
         * @param pArguments Optional string arguments which can be referenced in the translation string using the percent sign followed by
         * the argument index `%n`. The first argument is referenced with `%1`.
         * @return Returns the translated string.
         */
        get gettext(): (sId: string, ...pArguments: string[]) => string;
        /**
         * Translates a string using the specified language domain.
         * @param sDomain Specifies the language domain identifier.
         * @param sId Specifies the message identifier or string to translate.
         * @param pArguments Optional string arguments which can be referenced in the translation string using the percent sign followed by
         * the argument index `%n`. The first argument is referenced with `%1`.
         * @return Returns the translated string.
         */
        get dgettext(): (sDomain: string, sId: string, ...pArguments: string[]) => string;
        /**
         * Translates a plural string using the default language.
         * @param sId Specifies the message identifier or string to translate.
         * @param sPluralId Specifies the plural message identifier or string to translate.
         * @param nCount Specifies the count for the plural.
         * @param pArguments Optional string arguments which can be referenced in the translation string using the percent sign followed by
         * the argument index `%n`. The count value `nCount` is automatically included as the first argument (`%1`).
         * @return Returns the translated string.
         */
        get ngettext(): (sId: string, sPluralId: string, nCount: number, ...pArguments: string[]) => string;
        /**
         * Translates a plural string using the specified language domain.
         * @param sDomain Specifies the language domain identifier.
         * @param sId Specifies the message identifier or string to translate.
         * @param sPluralId Specifies the plural message identifier or string to translate.
         * @param nCount Specifies the count for the plural.
         * @param pArguments Optional string arguments which can be referenced in the translation string using the percent sign followed by
         * the argument index `%n`. The count value `nCount` is automatically included as the first argument (`%1`).
         * @return Returns the translated string.
         */
        get dngettext(): (sDomain: string, sId: string, sPluralId: string, nCount: number, ...pArguments: string[]) => string;
        /**
         * Translates a string from a specific context using the default language.
         * @param sContext Specifies the translation context.
         * @param sId Specifies the message identifier or string to translate.
         * @param pArguments Optional string arguments which can be referenced in the translation string using the percent sign followed by
         * the argument index `%n`. The first argument is referenced with `%1`.
         * @return Returns the translated string.
         */
        get pgettext(): (sContext: string, sId: string, ...pArguments: string[]) => string;
        /**
         * Translates a string from a specific context using the specified language domain.
         * @param sDomain Specifies the language domain identifier.
         * @param sContext Specifies the translation context.
         * @param sId Specifies the message identifier or string to translate.
         * @param pArguments Optional string arguments which can be referenced in the translation string using the percent sign followed by
         * the argument index `%n`. The first argument is referenced with `%1`.
         * @return Returns the translated string.
         */
        get dpgettext(): (sDomain: string, sContext: string, sId: string, ...pArguments: string[]) => string;
        /**
         * Translates a plural string using the default language.
         * @param sContext Specifies the translation context.
         * @param sId Specifies the message identifier or string to translate.
         * @param sPluralId Specifies the plural message identifier or string to translate.
         * @param nCount Specifies the count for the plural.
         * @param pArguments Optional string arguments which can be referenced in the translation string using the percent sign followed by
         * the argument index `%n`. The count value `nCount` is automatically included as the first argument (`%1`).
         * @return Returns the translated string.
         */
        get npgettext(): (sContext: string, sId: string, sPluralId: string, nCount: number, ...pArguments: string[]) => string;
        /**
         * Translates a plural string using the specified language domain.
         * @param sDomain Specifies the language domain identifier.
         * @param sContext Specifies the translation context.
         * @param sId Specifies the message identifier or string to translate.
         * @param sPluralId Specifies the plural message identifier or string to translate.
         * @param nCount Specifies the count for the plural.
         * @param pArguments Optional string arguments which can be referenced in the translation string using the percent sign followed by
         * the argument index `%n`. The count value `nCount` is automatically included as the first argument (`%1`).
         * @return Returns the translated string.
         */
        get dnpgettext(): (
            sDomain: string,
            sContext: string,
            sId: string,
            sPluralId: string,
            nCount: number,
            ...pArguments: string[]
        ) => string;
        /**
         * Translates a string using the default language (short version for `gettext`).
         * @param sId Specifies the message identifier or string to translate.
         * @param pArguments Optional string arguments which can be referenced in the translation string using the percent sign followed by
         * the argument index `%n`. The first argument is referenced with `%1`.
         * @return Returns the translated string.
         */
        get _(): (sId: string, ...pArguments: string[]) => string;
        /**
         * Translates a plural string using the default language (short version for `ngettext`).
         * @param sId Specifies the message identifier or string to translate.
         * @param sPluralId Specifies the plural message identifier or string to translate.
         * @param nCount Specifies the count for the plural.
         * @param pArguments Optional string arguments which can be referenced in the translation string using the percent sign followed
         * by the argument index `%n`. The count value `nCount` is automatically included as the first argument (`%1`).
         * @return Returns the translated string.
         */
        get _n(): (sId: string, sPluralId: string, nCount: number, ...pArguments: string[]) => string;
    }

    export { DEFAULTS as LOCALE_DEFAULTS, Translations as Domain };
}

declare module "@tripetto/runner/module/markdown" {
    export type MarkdownTypes =
        | "paragraph"
        | "break"
        | "bold"
        | "italic"
        | "bold+italic"
        | "underline"
        | "strikethrough"
        | "code"
        | "hyperlink"
        | "image"
        | "h1"
        | "h2"
        | "h3"
        | "h4"
        | "h5"
        | "h6"
        | "codeblock"
        | "codeline"
        | "quote"
        | "mention"
        | "reference";
    export enum MarkdownFeatures {
        /** Disable all features. */
        None = 0,
        /** Allow basic formatting like bold, italic, underline and strikethrough. */
        Formatting = 1,
        /** Allow the use of paragraphs (necessary for the `Headings`, `Quotes` or `Code` features). */
        Paragraphs = 2,
        /** Allow inline breaks. */
        Breaks = 4,
        /** Allow hyperlinks. */
        Hyperlinks = 8,
        /** Allow headings. */
        Headings = 16,
        /** Allow block quotes. */
        Blockquotes = 32,
        /** Allow code blocks. */
        Code = 64,
        /** Allows inline code. */
        InlineCode = 128,
        /** Allow embedding of images. */
        Images = 256,
        /** All features. */
        All = 511,
    }
    export interface IMarkdownRef<T> {
        ref: T;
        string: string;
    }
    export interface IMarkdownBufferParser<T> {
        /**
         * The parser function.
         * @param sBuffer Contains the buffer.
         * @param nIndex Specifies the index of the buffer.
         * @return Should return an object with the following properties:
         * - `shift`: Specifies the number of characters to shift the input buffer;
         * - `markdown`: Specifies the markdown string that is pushed to the AST (optional);
         * - `text`: Specifies the text string that is pused to the AST when no
         * markdown string is supplied (optional);
         * - `value`: Specifies the value that is pushed to the AST (optional).
         * Or return `undefined` to skip the parser.
         */
        parser: (
            sBuffer: string,
            nIndex: number
        ) =>
            | {
                  shift: number;
                  markdown?: string;
                  text?: string;
                  value?: T | IMarkdownRef<T>;
              }
            | undefined;
        /**
         * Requested number of chars from the buffer. If you omit this property,
         * the complete buffer is supplied to the parser function.
         */
        numberOfChars?: number;
    }
    export interface IMarkdownOptions<T> {
        /** Specifies the parser features. */
        features?: MarkdownFeatures;
        /** Specifies a `@`-mention parser. */
        mentions?: IMarkdownBufferParser<T>;
        /** Specifies a `#`-reference parser. */
        references?: IMarkdownBufferParser<T>;
        /** Specifies a stop word for the parser. Parsing stops when the word is found. */
        stopWord?: string;
    }
    export interface IMarkdown<T> {
        content: string | IMarkdownNode<T> | IMarkdownNode<T>[];
        type?: MarkdownTypes;
        value?: string | T | IMarkdownRef<T>;
    }
    export interface IMarkdownNode<T> extends IMarkdown<T> {
        parent?: IMarkdownNode<T>;
    }
    export class MarkdownParser<T = undefined> {
        /**
         * Parses the supplied markdown string and returns a markdown parser instance.
         * @param sMarkdown Specifies the markdown string to parse.
         * @param pOptions Specifies options for the markdown parser.
         * @return Returns a markdown parser instance.
         */
        static parse<T = undefined>(sMarkdown: string, pOptions?: IMarkdownOptions<T>): MarkdownParser<T>;
        /**
         * Creates a new markdown parser instance.
         * @param sMarkdown Specifies the markdown string to parse.
         * @param pOptions Specifies options for the markdown parser.
         */
        constructor(sMarkdown: string, pOptions?: IMarkdownOptions<T>);
        /** Contains the enabled features. */
        get features(): MarkdownFeatures;
        /** Retrieves a reference to the AST. */
        get abstractSyntaxTree(): IMarkdown<T>;
        /** Retrieves the plain text without markdown formatting. */
        get text(): string;
        /** Retrieves if a mention with a value is parsed. */
        get hasMentions(): boolean;
        /** Retrieves if a reference with a value is parsed. */
        get hasReferences(): boolean;

        /**
         * Maps the markdown AST to a structure.
         * @param fnMap Specifies the map function.
         * @return Returns the ancestor of the map structure.
         */
        map<R>(
            fnMap: (
                sType: MarkdownTypes | undefined,
                sContent: string,
                pValue: string | T | undefined,
                pParent: R | undefined,
                sKind: "root" | "text" | "node"
            ) => R
        ): R;
        /**
         * Reduces the markdown AST.
         * @param fnReduce Specifies the reduce function.
         * @returns Returns the reduced value.
         */
        reduce<R>(fnReduce: (sType: MarkdownTypes | undefined, pContent: string | R[], pValue: string | T | undefined) => R): R;
    }
}

declare module "@tripetto/runner/module/matrix" {
    import { Enumerator } from "@tripetto/runner/module/functional";
    import { HookProps, Hooks, IHookPayload, THooks } from "@tripetto/runner/module/hookup";

    export interface ICursor {
        /** Specifies the current column of the cursor. */
        column?: number;
        /** Specifies the current row of the cursor. */
        row?: number;
        /** Specifies the current index of the cursor. */
        index?: number;
    }
    export interface ISafeCursor {
        /** Specifies the current column of the cursor. */
        column: number;
        /** Specifies the current row of the cursor. */
        row: number;
        /** Specifies the current index of the cursor. */
        index: number;
    }
    export interface IDispatch<Hook extends THooks, T extends IHookPayload<Hook>> {
        hook: Hook;
        payload: HookProps<T>;
    }
    export const enum Reasons {
        /** A new item is pushed to the matrix. */
        Push = 1,
        /** An item is popped from the matrix. */
        Pop = 2,
        /** An item is moved to another position in the matrix. */
        Move = 4,
        /** An item is swapped. */
        Swap = 8,
        /** The matrix is sorted. */
        Sort = 16,
        /** A matrix recalculation occurred. */
        Recalculation = 32,
        /** An item has become the last item or the predecessor of the last item. */
        Last = 64,
        /** An item has become the first item or the successor of the first item. */
        First = 128,
    }
    /** Defines the matrix hooks. */
    export type TMatrixHooks = "OnDimensionChange" | "OnCountChange" | "OnCursorChange" | "OnItemPush" | "OnItemChange" | "OnItemPop";
    /** Defines the item hooks. */
    export type TItemHooks = "OnItemPush" | "OnItemChange" | "OnItemPop";
    /** Defines the `DimensionChange` event. */
    export interface IDimensionChangeEvent<T extends Matrix<Item<THooks>, THooks>> extends IHookPayload<"OnDimensionChange"> {
        /** Reference to the matrix. */
        readonly matrix: T;
        /** Specifies the matrix volume difference since the last event. */
        readonly difference: number;
        /** Specifies the number of columns. */
        readonly columns: number;
        /** Specifies the number of rows. */
        readonly rows: number;
        /** Specifies the reason for the change. */
        readonly reason: Reasons;
    }
    /** Defines the `CountChange` event. */
    export interface ICountChangeEvent<T extends Matrix<Item<THooks>, THooks>> extends IHookPayload<"OnCountChange"> {
        /** Reference to the matrix. */
        readonly matrix: T;
        /** Specifies the matrix count. */
        readonly count: number;
        /** Specifies the matrix count difference since the last event. */
        readonly difference: number;
        /** Specifies the reason for the change. */
        readonly reason: Reasons;
    }
    /** Defines the `Item` event which is the base event for `IItemPushEvent` and `IItemChangeEvent`. */
    export interface IItemEvent<H extends THooks, T extends Item<THooks>> extends IHookPayload<H> {
        /** Reference to the current matrix. */
        readonly matrix: Matrix<T, THooks>;
        /** Reference to the previous matrix. */
        readonly matrixPrevious: Matrix<T, THooks> | undefined;
        /** Reference to the item. */
        readonly item: T;
        /** Specifies the reason for the push. */
        readonly reason: Reasons;
    }
    /** Defines the `ItemPush` event. */
    export interface IItemPushEvent<T extends Item<THooks>> extends IItemEvent<"OnItemPush", T> {}
    /** Defines the `ItemChange` event. */
    export interface IItemChangeEvent<T extends Item<THooks>> extends IItemEvent<"OnItemChange", T> {}
    /** Defines the `ItemPop` event. */
    export interface IItemPopEvent<T extends Item<THooks>> extends IHookPayload<"OnItemPop"> {
        /** Reference to the matrix. */
        readonly matrix: Matrix<T, THooks>;
        /** Reference to the item. */
        readonly item: T;
    }
    /** Defines the `CursorChange` event. */
    export interface ICursorChangeEvent<T extends Matrix<Item<THooks>, THooks>> extends IHookPayload<"OnCursorChange"> {
        /** Reference to the matrix. */
        readonly matrix: T;
        /** Contains the cursor position. */
        readonly cursor: ICursor;
    }
    class Stack {
        /**
         * Pushes a call to the stack.
         * @param fnCall Specifies the call.
         */
        push(fnCall: () => void): void;
        /** Flushes the stack. */
        flush(): void;
    }
    /**
     * Implements the matrix item.
     * @param H Specifies custom hooks for the matrix (optional).
     */
    export abstract class Item<H extends THooks = void> extends Hooks<TItemHooks | H> {
        /** Contains the id enumerator. */
        static readonly enumerator: Enumerator;

        /**
         * Pushes an item to the supplied matrix.
         * @param pItem Reference to the item.
         * @param pMatrix Reference to the matrix to push the item to. If omitted
         * the current matrix of the item will be used.
         * @return Returns a reference to the item.
         */
        static pushToMatrix<T extends Item<THooks>>(pItem: T, pMatrix?: Matrix<T, THooks>): T;
        /**
         * Creates a new item.
         * @param pMatrix Optional reference to the matrix.
         */
        constructor(pMatrix?: Matrix<Item<H>, THooks>);
        /** Retrieves a reference to the underlying matrix. */
        get parent(): Matrix<Item<H>, THooks> | undefined;
        /** Specifies the unique id of the item. The id is unique within the current session. */
        get uniqueId(): number;
        /** Returns a (SHA2-256) hash for the item. The hash is unique within the current session. */
        get hash(): string;
        /** Overrides the automatic calculated hash value for the item. */
        set hash(sHash: string);
        /** Retrieves the index of the item (first item is zero). */
        get index(): number;
        /** Sets the index of the item (first item is zero). */
        set index(nIndex: number);
        /** Returns the column index of the item in the matrix (first column is zero). */
        get columnIndex(): number;
        /** Returns the row index of the item in the matrix (first row is zero). */
        get rowIndex(): number;
        /** Retrieves if the item is popped (not in the matrix). */
        get isPopped(): boolean;
        /** Specifies if the item is the first item in the column or row. */
        get isFirst(): boolean;
        /** Specifies if the item is the last item in the column or row. */
        get isLast(): boolean;
        /** Specifies if the item is the first item in the column. */
        get isFirstColumn(): boolean;
        /** Specifies if the item is the last item in the column. */
        get isLastColumn(): boolean;
        /** Specifies if the item is the first item in the row. */
        get isFirstRow(): boolean;
        /** Specifies if the item is the last item in the row. */
        get isLastRow(): boolean;
        /** Specifies if the item is the first item in the matrix. */
        get isFirstOfMatrix(): boolean;
        /** Specifies if the item is the last item in the matrix. */
        get isLastOfMatrix(): boolean;
        /** Retrieves the previous sibling of the item. */
        get predecessorSibling(): Item<H> | undefined;
        /** Retrieves the next sibling of the item. */
        get successorSibling(): Item<H> | undefined;
        /** Retrieves the previous item in the same column. */
        get predecessorInColumn(): Item<H> | undefined;
        /** Retrieves the next item in the same column. */
        get successorInColumn(): Item<H> | undefined;
        /** Retrieves the previous item in the same row. */
        get predecessorInRow(): Item<H> | undefined;
        /** Retrieves the next item in the same row. */
        get successorInRow(): Item<H> | undefined;
        /**
         * Retrieves a reference to the underlying matrix.
         * @return Returns a reference to the matrix.
         */
        protected matrix(): Matrix<Item<H>, THooks> | undefined;
        /**
         * Fired when the item is pushed.
         * @param pEvent Specifies the event payload.
         * @event
         */
        protected onPush(pEvent: HookProps<IItemPushEvent<Item<H>>>): void;
        /**
         * Fired when the item is changed.
         * @param pEvent Specifies the event payload.
         * @event
         */
        protected onChange(pEvent: HookProps<IItemChangeEvent<Item<H>>>): void;
        /**
         * Fired when the item is popped.
         * @param pEvent Specifies the event payload.
         * @event
         */
        protected onPop(pEvent: HookProps<IItemPopEvent<Item<H>>>): void;
        /**
         * Dispatches a matrix event.
         * @param pStack Reference to the stack.
         * @param pEvent Specifies the event to dispatch.
         */
        dispatch(
            pStack: Stack,
            pEvent: IDispatch<"OnItemChange", IItemChangeEvent<Item<H>>> | IDispatch<"OnItemPop", IItemPopEvent<Item<H>>> | "Pop" | "Detach"
        ): void;
        /**
         * Sets the index of an item.
         * @param pStack Reference to the stack.
         * @param pMatrix Reference to the matrix.
         * @param nIndex Specifies the new index of the item.
         * @param sEmit Specifies if events needs to be emitted.
         * @param nReason Specifies the event reason.
         * @return Returns `true` if a change occured.
         */
        reindex(
            pStack: Stack,
            pMatrix: Matrix<Item<H>, THooks>,
            nIndex: number,
            sEmit: "nothing" | "auto" | "change" | "push",
            nReason: Reasons
        ): boolean;
        /**
         * Moves the item to the specified cursor.
         * @param pCursor Specifies the cursor.
         * @return Returns `true` if the move succeeded.
         */
        moveTo(pCursor: ICursor): boolean;
        /**
         * Moves the item to the specified index.
         * @param nIndex Specifies the index position.
         * @return Returns `true` if the move succeeded.
         */
        moveToIndex(nIndex: number): boolean;
        /**
         * Moves the item to the specified position.
         * @param nColumn Specifies the column.
         * @param nRow Specifies the row.
         * @return Returns `true` if the move succeeded.
         */
        moveToPosition(nColumn: number, nRow: number): boolean;
        /**
         * Moves the item to the specified item.
         * @param pTo Specifies the item to move to.
         * @param bAbove Specifies if the move position is above or below the
         * specified item.
         * @return Returns `true` if the move succeeded.
         */
        moveToItem(pTo: Item<H>, bAbove: boolean): boolean;
        /**
         * Moves the item up or down.
         * @param bUp Specifies if the move direction is up (true) or down (false).
         * @return Returns `true` if the move succeeded.
         */
        moveUpOrDown(bUp: boolean): boolean;
        /**
         * Swaps an item with another item.
         * @param pWith Specifies the item to swap with.
         * @return Returns `true` if the swap succeeded.
         */
        swap(pWith: Item<H>): boolean;
        /**
         * Removes the item from the matrix.
         * @return Returns `true` if the function succeeded.
         */
        pop(): boolean;
        /**
         * Removes the item from the matrix without emitting events.
         * @return Returns `true` if the function succeeded.
         */
        popSilent(): boolean;
        /**
         * Restores a popped item.
         * @param pMatrix Specifies a matrix to use.
         * @param nIndex Specifies the restore position.
         * @return Returns a reference to the item.
         */
        unpop(pMatrix?: Matrix<Item<H>, THooks>, nIndex?: number): boolean;
        /**
         * Restores a popped item.
         * @param pMatrix Specifies a matrix to use.
         * @param nIndex Specifies the restore position.
         * @return Returns a reference to the item.
         */
        unpopSilent(pMatrix?: Matrix<Item<H>, THooks>, nIndex?: number): boolean;
    }
    export const enum Orientations {
        /** Items a vertical oriented (columns are filled out). */
        Vertical = 0,
        /** Items are horizontal oriented (rows are filled out). */
        Horizontal = 1,
    }
    export const enum Types {
        /** A vertical matrix expands vertical (fixed number of columns). */
        Vertical = 0,
        /** A horizontal matrix expands horizontal (fixed number of rows). */
        Horizontal = 1,
        /** A square matrix expands horizontal and vertical in a perfect square. */
        Square = 2,
        /** A horizontal square matrix expands first horizontal and then vertical. */
        SquareHorizontal = 3,
        /** A vertical square matrix expands first vertical and then horizontal. */
        SquareVertical = 4,
    }
    /**
     * Implements the convolution matrix.
     * @param T Specifies the item type.
     * @param H Specifies custom hooks for the matrix (optional).
     */
    export abstract class Matrix<T extends Item<THooks>, H extends THooks = void> extends Hooks<TMatrixHooks | H> {
        /**
         * Creates a new matrix.
         * @param nType Specifies the matrix direction.
         * @param nOrientation Specifies the matrix orientation.
         * @param nDimensions Specifies the number of columns for vertical matrices or the number of rows for horizontal matrices.
         */
        constructor(nType?: Types, nOrientation?: Orientations, nDimensions?: number);
        /** Specifies the unique id of the matrix. */
        get uniqueId(): number;
        /** Retrieves the current matrix type. */
        get type(): Types;
        /** Sets the current matrix type. */
        set type(nType: Types);
        /** Retrieves the current matrix orientation. */
        get orientation(): Orientations;
        /** Sets the current matrix orientation. */
        set orientation(nOrientation: Orientations);
        /** Retrieves the number of columns in the matrix. */
        get columns(): number;
        /** Sets the number of columns in the matrix. */
        set columns(nColumns: number);
        /** Retrieves the number of rows in the matrix. */
        get rows(): number;
        /** Sets the number of rows in the matrix. */
        set rows(nRows: number);
        /** Retrieves the total number of items in the matrix. */
        get count(): number;
        /** Retrieves all the items. */
        get all(): T[];
        /** Retrieves the item at the current cursor position. */
        get currentItem(): T | undefined;
        /** Retrieves the first item in the matrix. */
        get firstItem(): T | undefined;
        /** Retrieves the last item in the matrix. */
        get lastItem(): T | undefined;
        /** Retrieves the last item in the first row of the matrix. */
        get lastItemInFirstRow(): T | undefined;
        /** Retrieves the last item in the first column of the matrix. */
        get lastItemInFirstColumn(): T | undefined;
        /** Retrieves the current cursor. */
        get cursor(): ICursor | ISafeCursor;
        /** Sets the current cursor. */
        set cursor(pCursor: ICursor | ISafeCursor);
        /** Retrieves the current (safe) cursor. */
        get safeCursor(): ISafeCursor;
        /** Verifies if the cursor is at the first column. */
        get isCursorAtFirstColumn(): boolean;
        /** Verifies if the cursor is at the last column. */
        get isCursorAtLastColumn(): boolean;
        /** Verifies if the column cursor is past the last column. */
        get isCursorAtEndColumn(): boolean;
        /** Verifies if the row cursor is at the first row. */
        get isCursorAtFirstRow(): boolean;
        /** Verifies if the row cursor is at the last row. */
        get isCursorAtLastRow(): boolean;
        /** Verifies if the row cursor is past the last row. */
        get isCursorAtEndRow(): boolean;
        /** Verifies if the cursor is at the first item of the matrix. */
        get isCursorAtFirst(): boolean;
        /** Verifies if the cursor is at the last item of the matrix. */
        get isCursorAtLast(): boolean;
        /** Verifies if the cursor is past the end of the matrix. */
        get isCursorAtEnd(): boolean;
        /** Retrieves the silent mode. */
        get isSilent(): boolean | (() => boolean);
        /** Sets the silent mode. */
        set isSilent(pSilent: boolean | (() => boolean));

        /**
         * Retrieves a validated cursor from the supplied cursor.
         * @param pCursor Specifies the source cursor.
         * @return Returns the validated cursor.
         */
        protected getSafeCursor(pCursor: ICursor): ISafeCursor;
        /**
         * Fired when the dimensions of the matrix are changed.
         * @param pEvent Specifies the event payload.
         * @event
         */
        protected onDimensionChange(pEvent: HookProps<IDimensionChangeEvent<this>>): void;
        /**
         * Fired when the item count of the matrix is changed.
         * @param pEvent Specifies the event payload.
         * @event
         */
        protected onCountChange(pEvent: HookProps<ICountChangeEvent<this>>): void;
        /**
         * Fired when the cursor position of the matrix is changed.
         * @param pEvent Specifies the event payload.
         * @event
         */
        protected onCursorChange(pEvent: HookProps<ICursorChangeEvent<this>>): void;
        /**
         * Retrieves the index for the given column and row.
         * @param nColumn Specifies the column.
         * @param nRow Specifies the row.
         * @return Returns the item index or `-1` if the index is invalid.
         */
        indexFromColumnRow(nColumn: number, nRow: number): number;
        /**
         * Retrieves a cursor for the specified index.
         * @param nIndex Specifies the index.
         * @return Returns a cursor.
         */
        cursorFromIndex(nIndex: number | undefined): ISafeCursor;
        /**
         * Pushes an item to the matrix.
         * @param pItem Specifies the item to put in the matrix.
         * @param pOptions Specifies one or more of the following options:
         * - Index: Specifies the desired index for the item (if `undefined` the
         * supplied index in the item will be used or the item will be pushed to the
         * end of the matrix if the index is invalid);
         * - Recalculate: Specifies if the matrix needs to be recalculated;
         * - Emit: Specifies what to emit.
         * @return Returns a reference to the item.
         */
        pushToMatrix(
            pItem: T,
            pOptions?: {
                index: number | undefined;
                recalculate: boolean;
                emit: "nothing" | "push" | "change";
            }
        ): T;
        /**
         * Moves an item to the specified cursor.
         * @param pItem Specifies the item to move.
         * @param pCursor Specifies the cursor.
         * @return Returns `true` if the move succeeded.
         */
        moveTo(pItem: T, pCursor: ICursor): boolean;
        /**
         * Moves an item to the specified index position.
         * @param pItem Specifies the item to move.
         * @param nIndex Specifies the index position.
         * @return Returns `true` if the move succeeded.
         */
        moveToIndex(pItem: T, nIndex: number): boolean;
        /**
         * Moves an item to the specified position.
         * @param pItem Specifies the item to move.
         * @param nColumn Specifies the column.
         * @param nRow Specifies the row.
         * @return Returns `true` if the move succeeded.
         */
        moveToPosition(pItem: T, nColumn: number, nRow: number): boolean;
        /**
         * Moves an item to the specified item.
         * @param pItem Specifies the item to swap.
         * @param pTo Specifies the item to move to.
         * @param bAbove Specifies if the move position is above or below the specified item.
         * @return Returns `true` if the move succeeded.
         */
        moveToItem(pItem: T, pTo: T, bAbove: boolean): boolean;
        /**
         * Moves an item up or down.
         * @param pItem Specifies the item to move.
         * @param bUp Specifies if the move direction is up (true) or down (false).
         * @return Returns `true` if the move succeeded.
         */
        moveUpOrDown(pItem: T, bUp: boolean): boolean;
        /**
         * Swaps two items.
         * @param pA Item A.
         * @param pB Item B.
         * @return Returns `true` if the swap succeeded.
         */
        swap(pA: T, pB: T): boolean;
        /**
         * Removes an item from the matrix (or the last item if no item is specified).
         * @param pItem Specifies the item to remove.
         * @param bEmit Specifies if the events needs to be emitted.
         * @return Returns the popped item.
         */
        popFromMatrix(pItem?: T, bEmit?: boolean): T | undefined;
        /**
         * Sorts the matrix using the supplied compare functions.
         * @param fnCompare Specifies the compare function. The compare function should return a number according to the following rules:
         * - A is less than B return -1;
         * - A is greater than B return 1;
         * - A is equal to B return 0.
         *
         * To compare numbers you can simply return `nA - nB`. If no compare function is specified, the items are sorted according to the
         * original push order.
         * @param fnCompare.pA Compare item A.
         * @param fnCompare.pB Compare item B.
         * @return Returns `true` if the sort invoked an item position change.
         */
        sort(fnCompare?: (pA: T, pB: T) => number): boolean;
        /**
         * Removes all matrix items.
         * @param sMode Specifies the clear mode:
         * - `dirty`: Just removes all the items from the matrix without emitting events;
         * - `fast`: Removes the items and invokes the `onPop` method for each item;
         * - `thorough`: Removes the items and invokes the `OnPop`method and hooks for each item.
         */
        clear(sMode?: "dirty" | "fast" | "thorough"): void;
        /** Invalidates the matrix and forces the `DimensionChange` event. */
        invalidateMatrix(): void;
        /** Recalculates the matrix. */
        recalculateMatrix(): void;
        /**
         * Iterates through each item.
         * @param fnCallee Specifies the function to be invoked for each item. The item value will be exposed to the function as the first
         * argument of the argument list. Additional arguments can be specified and will be pushed to the function. If the function returns
         * `true` the iteration is stopped.
         * @param nFrom Specifies the index to start the iteration from. A negative index indicates an offset from the end of the matrix.
         * @param nTo Specifies the index to stop the iteration. A negative index indicates an offset from the end of the matrix.
         * @return Returns `true` if the iteration is stopped (break).
         */
        each(fnCallee: (pItem: T) => boolean | void, nFrom?: number, nTo?: number): boolean;
        /**
         * Iterates through each item starting with the last item.
         * @param fnCallee Specifies the function to be invoked for each item. The item value will be exposed to the function as the first
         * argument of the argument list. Additional arguments can be specified and will be pushed to the function. If the function
         * returns `true` the iteration is stopped.
         * @param nFrom Specifies the index to start the iteration from. A negative index indicates an offset from the end of the matrix.
         * @param nTo Specifies the index to stop the iteration. A negative index indicates an offset from the end of the matrix.
         * @return Returns `true` if the iteration was stopped (break).
         */
        reverseEach(fnCallee: (pItem: T) => boolean | void, nFrom?: number, nTo?: number): boolean;
        /**
         * Retrieves the item at the specified index.
         * @param nIndex Specifies the index.
         * @return Returns the item or `undefined` if the item is not found.
         */
        itemAtIndex(nIndex: number): T | undefined;
        /**
         * Retrieves the item at the specified position.
         * @param nColumn Specifies the column.
         * @param nRow Specifies the row.
         * @return Returns the item or `undefined` if the item is not found.
         */
        itemAtPosition(nColumn: number, nRow: number): T | undefined;
        /**
         * Retrieves the item at the specified cursor.
         * @param pCursor Specifies the cursor.
         * @return Returns the item or `undefined` if the item is not found.
         */
        itemAtCursor(pCursor: ICursor): T | undefined;
        /**
         * Retrieves the item with the specified id.
         * @param nId Specifies the id of the item.
         * @return Returns the item or `undefined` if the item is not found.
         */
        itemFromId(nId: number): T | undefined;
        /**
         * Retrieves the last item in the specified row of the matrix.
         * @param nRow Specifies the row.
         * @return Returns a reference to the last item or `undefined` if the item is not found.
         */
        lastItemInRow(nRow: number): T | undefined;
        /**
         * Retrieves the last item in the specified column of the matrix.
         * @param nColumn Specifies the column.
         * @return Returns a reference to the last item or `undefined` if the item is not found.
         */
        lastItemInColumn(nColumn: number): T | undefined;
        /**
         * Moves the cursor to the first column.
         * @param bMoveToFirstRow Specifies if the cursor needs to be moved to the first row.
         * @return Returns the new cursor position.
         */
        moveCursorToFirstColumn(bMoveToFirstRow?: boolean): ISafeCursor;
        /**
         * Moves the cursor to the next column.
         * @param bMoveToFirstRow Specifies if the cursor needs to be moved to the first row.
         * @return Returns the new cursor position.
         */
        moveCursorToSuccessorColumn(bMoveToFirstRow?: boolean): ISafeCursor;
        /**
         * Moves the cursor to the previous column.
         * @param bMoveToFirstRow Specifies if the cursor needs to be moved to the first row.
         * @return Returns the new cursor position.
         */
        moveCursorToPredecessorColumn(bMoveToFirstRow?: boolean): ISafeCursor;
        /**
         * Moves the cursor to the last column.
         * @param bMoveToFirstRow Specifies if the cursor needs to be moved to the first row.
         * @return Returns the new cursor position.
         */
        moveCursorToLastColumn(bMoveToFirstRow?: boolean): ISafeCursor;
        /**
         * Moves the cursor to the first row.
         * @param bMoveToFirstColumn Specifies if the cursor needs to be moved to the first column.
         * @return Returns the new cursor position.
         */
        moveCursorToFirstRow(bMoveToFirstColumn?: boolean): ISafeCursor;
        /**
         * Moves the cursor to the next row.
         * @param bMoveToFirstColumn Specifies if the cursor needs to be moved to the first column.
         * @return Returns the new cursor position.
         */
        moveCursorToSuccessorRow(bMoveToFirstColumn?: boolean): ISafeCursor;
        /**
         * Moves the cursor to the previous row.
         * @param bMoveToFirstColumn Specifies if the cursor needs to be moved to the first column.
         * @return Returns the new cursor position.
         */
        moveCursorToPredecessorRow(bMoveToFirstColumn?: boolean): ISafeCursor;
        /**
         * Moves the row cursor to the last row.
         * @param bMoveToFirstColumn Specifies if column cursor needs to be moved to the first column.
         * @return Returns the new cursor position.
         */
        moveCursorToLastRow(bMoveToFirstColumn?: boolean): ISafeCursor;
        /**
         * Moves the cursor to the first item.
         * @return Returns the new cursor position.
         */
        moveCursorToFirst(): ISafeCursor;
        /**
         * Moves the cursor to the next item.
         * @return Returns the new cursor position.
         */
        moveCursorToSuccessor(): ISafeCursor;
        /**
         * Moves the cursor to the previous item.
         * @return Returns the new cursor position.
         */
        moveCursorToPredecessor(): ISafeCursor;
        /**
         * Moves the cursor to the last item.
         * @return Returns the new cursor position.
         */
        moveCursorToLast(): ISafeCursor;
        /**
         * Moves the cursor past the last item.
         * @return Returns the new cursor position.
         */
        moveCursorToEnd(): ISafeCursor;
    }
    /**
     * Implements the strict matrix item. In a strict matrix an item is always
     * bound to a parent matrix and items can be created by the matrix.
     * @param P Specifies the matrix type.
     * @param H Specifies custom hooks for the item (optional).
     * @param D Specifies a data type for the item (optional).
     */
    export abstract class StrictItem<
        P extends StrictMatrix<P, StrictItem<P, H, D>, THooks, D>,
        H extends THooks = void,
        D = undefined,
    > extends Item<H> {
        /**
         * Creates a new strict item.
         * @param pMatrix Reference to the matrix.
         */
        constructor(pMatrix: P);
        /** Retrieves a reference to the parent matrix. */
        get parent(): P;
        /**
         * Retrieves a reference to the underlying matrix.
         * @return Returns a reference to the matrix.
         */
        protected matrix(): P;
        /**
         * Inserts a new item before this item.
         * @param pData Data which is passed to the item constructor.
         * @return Returns a reference to the item.
         */
        protected insertBefore(pData: D): StrictItem<P, H, D>;
        /**
         * Inserts a new item after this item.
         * @param pData Data which is passed to the item constructor.
         * @return Returns a reference to the item.
         */
        protected insertAfter(pData: D): StrictItem<P, H, D>;
        /**
         * Dispatches a matrix event.
         * @param pStack Reference to the stack.
         * @param pEvent Specifies the event to dispatch.
         */
        dispatch(
            pStack: Stack,
            pEvent:
                | IDispatch<"OnItemChange", IItemChangeEvent<StrictItem<P, H, D>>>
                | IDispatch<"OnItemPop", IItemPopEvent<StrictItem<P, H, D>>>
                | "Pop"
                | "Detach"
        ): void;
    }
    /**
     * Describes the item constructor.
     * @param P Specifies the matrix type.
     * @param T Specifies the item type.
     * @param D Specifies a data type for the item (optional).
     */
    export interface IStrictItemConstructor<P extends StrictMatrix<P, T, THooks, D>, T extends StrictItem<P, THooks, D>, D> {
        new (pMatrix: P, pData: D): T;
    }
    /**
     * Implements the strict convolution matrix. In a strict matrix an item is
     * always bound to a parent matrix and items can be created by the matrix.
     * @param P Specifies the matrix type.
     * @param T Specifies the item type.
     * @param H Specifies custom hooks for the matrix (optional).
     * @param D Specifies a data type for the item (optional).
     */
    export abstract class StrictMatrix<
        P extends StrictMatrix<P, T, H, D>,
        T extends StrictItem<P, THooks, D>,
        H extends THooks = void,
        D = undefined,
    > extends Matrix<T, H> {
        /**
         * Creates a new matrix.
         * @param pItem Specifies the item constructor.
         * @param nType Specifies the matrix direction.
         * @param nOrientation Specifies the matrix orientation.
         * @param nDimensions Specifies the number of columns for vertical matrices or the number of rows for horizontal matrices.
         */
        constructor(pItemConstructor: IStrictItemConstructor<P, T, D>, nType?: Types, nOrientation?: Orientations, nDimensions?: number);
        /** Retrieves a reference to the item constructor. */
        get itemConstructor(): IStrictItemConstructor<P, T, D>;
        /**
         * Appends a new item to the end of the matrix.
         * @param pData Data which is passed to the item constructor.
         * @return Returns a reference to the item.
         */
        protected appendToMatrix(pData: D): T;
        /**
         * Inserts a new item at the beginning of the matrix.
         * @param pData Data which is passed to the item constructor.
         * @return Returns a reference to the item.
         */
        protected insertToMatrix(pData: D): T;
        /**
         * Inserts a new item at the specified cursor or at the beginning of the matrix.
         * @param pData Data which is passed to the item constructor.
         * @param pCursor Specifies the cursor.
         * @return Returns a reference to the item.
         */
        protected insertToMatrixAtCursor(pData: D, pCursor: ICursor): T;
        /**
         * Inserts a new item at the specified index.
         * @param pData Data which is passed to the item constructor.
         * @param nIndex Specifies the index position.
         * @return Returns a reference to the item.
         */
        protected insertToMatrixAtIndex(pData: D, nIndex: number): T;
        /**
         * Inserts a new item at the specified index.
         * @param pData Data which is passed to the item constructor.
         * @param nColumn Specifies the column.
         * @param nRow Specifies the row.
         * @return Returns a reference to the item.
         */
        protected insertToMatrixAtPosition(pData: D, nColumn: number, nRow: number): T;
        /**
         * Invoked when a new item instance is requested.
         * @param pData Specifies the data.
         * @return Returns the new item instance.
         * @event
         */
        onItemInstance(pData: D): T;
    }
    /** Defines the `DataChange` event. */
    export interface IDataChangeEvent<T> extends IHookPayload<"OnDataChange"> {
        /** Reference to the model. */
        readonly model: Model<T>;
        /** Reference to the item. */
        readonly item: ModelItem<T>;
        /** Reference to the data. */
        readonly data: T;
    }
    /**
     * Creates a new matrix model item.
     * @param T Specifies the type for the item.
     */
    export class ModelItem<T> extends StrictItem<Model<T>, "OnDataChange", T> {
        /**
         * Creates a new item.
         * @param pData Specifies the data for the item.
         */
        constructor(pMatrix: Model<T>, pData: T);
        /** Retrieves the attached data. */
        get data(): T;
        /** Sets the attached data. */
        set data(pData: T);
        /**
         * Inserts a new item before this item.
         * @param pData Specifies the data for the item.
         * @return Returns the new item.
         */
        insertBefore(pData: T): ModelItem<T>;
        /**
         * Inserts a new item after this item.
         * @param pData Specifies the data for the item.
         * @return Returns the new item.
         */
        insertAfter(pData: T): ModelItem<T>;
    }
    /**
     * Creates a matrix model of the specified type.
     * @param T Specifies the type for the model.
     */
    export class Model<T> extends StrictMatrix<Model<T>, ModelItem<T>, "OnDataChange", T> {
        /**
         * Creates a new matrix.
         * @param nType Specifies the matrix direction.
         * @param nOrientation Specifies the matrix orientation.
         * @param nDimensions Specifies the number of columns for vertical matrices
         * or the number of rows for horizontal matrices.
         * @param pItems Specifies an array with initial data items.
         */
        constructor(nType?: Types, nOrientation?: Orientations, nDimensions?: number, pItems?: T[]);
        /**
         * Appends a new item to the end of the model.
         * @param pData Specifies the data for the item.
         * @return Returns the new item.
         */
        append(pData: T): ModelItem<T>;
        /**
         * Inserts a new item at the beginning of the model.
         * @param pData Specifies the data for the item.
         * @return Returns the new item.
         */
        insert(pData: T): ModelItem<T>;
        /**
         * Inserts a new item at the specified cursor.
         * @param pData Specifies the data for the item.
         * @param pCursor Specifies the cursor.
         * @return Returns the new item.
         */
        insertAtCursor(pData: T, pCursor: ICursor): ModelItem<T>;
        /**
         * Inserts a new item at the specified index.
         * @param pData Specifies the data for the item.
         * @param nIndex Specifies the index position.
         * @return Returns the new item.
         */
        insertAtIndex(pData: T, nIndex: number): ModelItem<T>;
        /**
         * Inserts a new item at the specified index.
         * @param pData Specifies the data for the item.
         * @param nColumn Specifies the column.
         * @param nRow Specifies the row.
         * @return Returns the new item.
         */
        insertAtPosition(pData: T, nColumn: number, nRow: number): ModelItem<T>;
    }
}

declare module "@tripetto/runner/module/metrics" {
    export interface IPoint {
        /** Specifies the horizontal coordinate. */
        readonly x: number;
        /** Specifies the vertical coordinate. */
        readonly y: number;
    }
    export interface IRectangleProperties<T extends string> {
        /** Specifies the rectangle name. */
        name: T;
        /** Specifies the initial width of the rectangle. */
        readonly width?: number;
        /** Specifies the initial height of the rectangle. */
        readonly height?: number;
        /** Specifies the minimal width of the rectangle. */
        readonly minWidth?: number;
        /** Specifies the minimal height of the rectangle. */
        readonly minHeight?: number;
        /** Specifies the maximal width of the rectangle. */
        readonly maxWidth?: number;
        /** Specifies the minimal width of the rectangle. */
        readonly maxHeight?: number;
        /** Specifies the left spacing of the rectangle. */
        readonly spacingLeft?: number;
        /** Specifies the top spacing of the rectangle. */
        readonly spacingTop?: number;
        /** Specifies the right spacing of the rectangle. */
        readonly spacingRight?: number;
        /** Specifies the bottom spacing of the rectangle. */
        readonly spacingBottom?: number;
        /** Specifies the left hint correction. */
        readonly hintCorrectionLeft?: number;
        /** Specifies the top hint correction. */
        readonly hintCorrectionTop?: number;
        /** Specifies the right hint correction. */
        readonly hintCorrectionRight?: number;
        /** Specifies the bottom hint correction. */
        readonly hintCorrectionBottom?: number;
        /** Specifies the horizontal mean correction. */
        readonly meanCorrectionHorizontal?: number;
        /** Specifies the vertical mean correction. */
        readonly meanCorrectionVertical?: number;
        /** Specifies the names of the rectangles which should align to this rectangle. */
        readonly align?: T[];
    }
    export class Coordinate {
        /** Specifies the left coordinate. */
        left: number;
        /** Specifies the top coordinate. */
        top: number;
        /** Specifies the right coordinate. */
        right: number;
        /** Specifies the bottom coordinate. */
        bottom: number;
        /**
         * Constructs a new coordinate.
         * @param nLeft Specifies the left coordinate.
         * @param nTop Specifies the top coordinate.
         * @param nRight Specifies the right coordinate.
         * @param nBottom Specifies the bottom coordinate.
         */
        constructor(nLeft?: number, nTop?: number, nRight?: number, nBottom?: number);
    }
    export class Dimensions {
        /** Retrieves the `none` constant for the width and height. */
        static get NONE(): number;

        /**
         * Constructs a new dimension object.
         * @param nWidth Specifies the width.
         * @param nHeight Specifies the height.
         * @param nMinWidth Specifies the minimum width.
         * @param nMinHeight Specifies the minimum height.
         * @param nMaxWidth Specifies the maximum width.
         * @param nMaxHeight Specifies the minimum height.
         */
        constructor(nWidth?: number, nHeight?: number, nMinWidth?: number, nMinHeight?: number, nMaxWidth?: number, nMaxHeight?: number);
        /** Retrieves the minimum width. */
        get minWidth(): number;
        /** Sets the minimum width. */
        set minWidth(nMinWidth: number);
        /** Retrieves the minimum height. */
        get minHeight(): number;
        /** Sets the minimum height. */
        set minHeight(nMinHeight: number);
        /** Retrieves the maximum width. */
        get maxWidth(): number;
        /** Sets the maximum width. */
        set maxWidth(nMaxWidth: number);
        /** Retrieves the maximum height. */
        get maxHeight(): number;
        /** Sets the maximum height. */
        set maxHeight(nMaxHeight: number);
        /** Retrieves the current width. */
        get width(): number;
        /** Sets the current width. */
        set width(nWidth: number);
        /** Retrieves the current height. */
        get height(): number;
        /** Sets the current height. */
        set height(nHeight: number);
        /** Retrieves if the width is specified. */
        get isWidthSpecified(): boolean;
        /** Retrieves if the height is specified. */
        get isHeightSpecified(): boolean;
        /** Retrieves the unranged width. */
        get w(): number;
        /** Retrieves the unranged height. */
        get h(): number;
    }
    export class Rectangle {
        /**
         * Constructs a new rectangle.
         * @param pProperties Specifies the rectangle properties.
         */
        constructor(pProperties?: {
            /** Specifies the left position. */
            left?: number;
            /** Specifies the top position. */
            top?: number;
            /** Specifies the right position. */
            right?: number;
            /** Specifies the bottom position. */
            bottom?: number;
            /** Specifies the width of the rectangle. If the width is supplied the specified right position is ignored. */
            width?: number;
            /** Specifies the height of the rectangle. If the height is supplied the specified bottom position is ignored. */
            height?: number;
            /** Specifies the minimum width. */
            minWidth?: number;
            /** Specifies the minimum height. */
            minHeight?: number;
            /** Specifies the maximum width. */
            maxWidth?: number;
            /** Specifies the maximum height. */
            maxHeight?: number;
        });
        /** Retrieves the dimensions. */
        get dimensions(): Dimensions;
        /** Retrieves the coordinates. */
        get coordinate(): Coordinate;
        /** Retrieves the left coordinate of the rectangle. */
        get left(): number;
        /** Sets the left coordinate of the rectangle. */
        set left(nLeft: number);
        /** Retrieves the top coordinate of the rectangle. */
        get top(): number;
        /** Sets the top coordinate of the rectangle. */
        set top(nTop: number);
        /** Retrieves the right coordinate of the rectangle. */
        get right(): number;
        /** Sets the right coordinate of the rectangle. */
        set right(nRight: number);
        /** Retrieves the bottom coordinate of the rectangle. */
        get bottom(): number;
        /** Sets the bottom coordinate of the rectangle. */
        set bottom(nBottom: number);
        /** Retrieves the width of the rectangle. */
        get width(): number;
        /** Sets the width of the rectangle. */
        set width(nWidth: number);
        /** Retrieves the height of the rectangle. */
        get height(): number;
        /** Sets the height of the rectangle. */
        set height(nHeight: number);
        /** Retrieves the rounded width of the rectangle.  */
        get roundedWidth(): number;
        /** Retrieves the rounded height of the rectangle.  */
        get roundedHeight(): number;
        /** Retrieves the unranged width of the rectangle.  */
        get w(): number;
        /** Retrieves the unranged height of the rectangle.  */
        get h(): number;
        /** Retrieves an immutable copy of the rectangle. */
        get copy(): Rectangle;
        /**
         * Verifies if the supplied point is within the rectangle.
         * @param nX Specifies the horizontal position.
         * @param nY Specifies the vertical position.
         * @return Returns `true` if the point is within the rectangle.
         */
        isIn(nX?: number, nY?: number): boolean;
    }
    /**
     * Implements a rectangle manager which can be used to manage rectangle relationships. The relation between those rectangles is described
     * by specifying characteristics of the rectangles, such as padding, minimal and maximum dimensions, etc. When the dimensions of a
     * rectangle change, the resulting dimensions of the surrounding rectangles are calculated.
     * @param T Specifies the rectangle names.
     */
    export class Rectangles<T extends string> {
        /**
         * Constructs a new rectangle repository.
         * @param pRectangles Specifies an array with rectangles.
         */
        constructor(pRectangles?: IRectangleProperties<T>[]);
        /** Retrieves the left coordinate of the comprehensive rectangle. */
        get left(): number;
        /** Sets the left coordinate of the comprehensive rectangle. */
        set left(nLeft: number);
        /** Retrieves the top coordinate of the comprehensive rectangle. */
        get top(): number;
        /** Sets the top coordinate of the comprehensive rectangle. */
        set top(nTop: number);
        /** Retrieves the right coordinate of the comprehensive rectangle. */
        get right(): number;
        /** Retrieves the bottom coordinate of the comprehensive rectangle. */
        get bottom(): number;
        /** Retrieves the width of the comprehensive rectangle. */
        get width(): number;
        /** Retrieves the height of the comprehensive rectangle. */
        get height(): number;
        /** Returns the width and height of the comprehensive rectangle. */
        get dimensions(): Dimensions;
        /**
         * Retrieves the inner left coordinate of the comprehensive rectangle. This
         * is the rectangle which includes all rectangles without spacing.
         */
        get innerLeft(): number;
        /**
         * Retrieves the inner top coordinate of the comprehensive rectangle. This
         * is the rectangle which includes all rectangles without spacing.
         */
        get innerTop(): number;
        /**
         * Retrieves the inner right coordinate of the comprehensive rectangle. This
         * is the rectangle which includes all rectangles without spacing.
         */
        get innerRight(): number;
        /**
         * Retrieves the inner bottom coordinate of the comprehensive rectangle.
         * This is the rectangle which includes all rectangles without spacing.
         */
        get innerBottom(): number;
        /**
         * Retrieves the inner width of the comprehensive rectangle. This is the
         * rectangle which includes all rectangles without spacing.
         */
        get innerWidth(): number;
        /**
         * Retrieves the inner height of the comprehensive rectangle. This is the
         * rectangle which includes all rectangles without spacing.
         */
        get innerHeight(): number;
        /** Retrieves the shift mode. */
        get isShifted(): boolean;
        /** Sets the shift mode. */
        set isShifted(bShift: boolean);
        /** Retrieves the left position of the shifted element. */
        get shiftLeft(): number;
        /** Sets the left move. */
        set shiftLeft(nLeft: number);
        /** Retrieves the top position of the shifted element. */
        get shiftTop(): number;
        /** Sets the top shift. */
        set shiftTop(nTop: number);
        /** Retrieves the right position of the shifted element. */
        get shiftRight(): number;
        /** Retrieves the bottom position of the shifted element. */
        get shiftBottom(): number;
        /** Retrieves the last horizontal position shift. */
        get shiftHorizontal(): number;
        /** Retrieves the last vertical position shift. */
        get shiftVertical(): number;
        /** Retrieves the horizontal shift mean. */
        get shiftMeanHorizontal(): number;
        /** Retrieves the vertical shift mean. */
        get shiftMeanVertical(): number;
        /**
         * Iterates through all rectangles.
         * @param fnRectangle Specifies the function which is called for each rectangle.
         * @param fnRectangle.pRectangle Reference to the rectangle metrics.
         * @param fnRectangle.sRectangle Contains the rectangle name.
         * @param nZoom Specifies an optional zoom factor.
         */
        each(fnRectangle: (pRectangle: Rectangle, sRectangle: T) => void, nZoom?: number): void;
        /**
         * Sets or retrieves the minimum width of the specified rectangle.
         * @param sRectangle Specifies the name of the rectangle.
         * @param nMinWidth Specifies the minimum width.
         * @return Returns the minimal width.
         */
        minWidth(sRectangle: T, nMinWidth?: number): number;
        /**
         * Sets or retrieves the minimum height of the specified rectangle.
         * @param sRectangle Specifies the name of the rectangle.
         * @param nMinHeight Specifies the minimum height.
         * @return Returns the minimal height.
         */
        minHeight(sRectangle: T, nMinHeight?: number): number;
        /**
         * Sets or retrieves the maximum width of the specified rectangle.
         * @param sRectangle Specifies the name of the rectangle.
         * @param nMaxWidth Specifies the maximum width.
         * @return Returns the maximum width.
         */
        maxWidth(sRectangle: T, nMaxWidth?: number): number;
        /**
         * Sets or retrieves the maximum height of the specified rectangle.
         * @param sRectangle Specifies the name of the rectangle.
         * @param nMaxHeight Specifies the maximum height.
         * @return Returns the maximum height.
         */
        maxHeight(sRectangle: T, nMaxHeight?: number): number;
        /**
         * Retrieves the horizontal center of the specified rectangle or the comprehensive rectangle.
         * @param sRectangle Specifies the name of the rectangle. If omitted the mean of the comprehensive rectangle will be calculated.
         * @return Returns the horizontal mean.
         */
        meanHorizontal(sRectangle?: T): number;
        /**
         * Retrieves the vertical center of the specified rectangle or the comprehensive rectangle.
         * @param sRectangle Specifies the name of the rectangle. If omitted the mean of the comprehensive rectangle will be calculated.
         * @return Returns the vertical mean.
         */
        meanVertical(sRectangle?: T): number;
        /**
         * Retrieves the rectangle for the specified rectangle or the comprehensive rectangle.
         * @param sRectangle Specifies the name of the rectangle. If omitted the rectangle of the comprehensive rectangle will be calculated.
         * @param nZoom Specifies an optional zoom factor.
         * @return Returns the rectangle.
         */
        rectangle(sRectangle?: T, nZoom?: number): Rectangle;
        /**
         * Retrieves the applied rectangle for the specified rectangle. This is the rectangle which is currently stored in the buffer.
         * @param sRectangle Specifies the name of the rectangle. If omitted the rectangle of the comprehensive rectangle will be calculated.
         * @param nZoom Specifies an optional zoom factor.
         * @return Returns the rectangle.
         */
        rectangleApplied(sRectangle?: T, nZoom?: number): Rectangle;
        /**
         * Sets or retrieves the width of a rectangle or retrieves the width of the comprehensive rectangle.
         * @param sRectangle Specifies the name of the rectangle. If omitted the rectangle of the comprehensive rectangle will be calculated.
         * @param nWidth Specifies the width.
         * @return Returns the width.
         */
        rectangleWidth(sRectangle?: T, nWidth?: number): number;
        /**
         * Sets or retrieves the height of a rectangle or retrieves the width of the comprehensive rectangle.
         * @param sRectangle Specifies the name of the rectangle. If omitted the rectangle of the comprehensive rectangle will be calculated.
         * @param nWidth Specifies the width.
         * @return Returns the width.
         */
        rectangleHeight(sRectangle?: T, nHeight?: number): number;
        /**
         * Verifies if the specified rectangle is aligned with another rectangle.
         * @param sRectangleA Specifies the first rectangle.
         * @param sRectangleB Specifies the second rectangle.
         * @return Returns `true` if the rectangle is aligned.
         */
        isRectangleAligned(sRectangleA: T, sRectangleB: T): boolean;
        /**
         * Sets or retrieves the left spacing of a rectangle or retrieves the left comprehensive rectangle spacing.
         * @param sRectangle Specifies the name of the rectangle. If omitted the rectangle of the comprehensive rectangle will be calculated.
         * @param nSpacingLeft Specifies the left spacing.
         * @return Returns the left spacing.
         */
        spacingLeft(sRectangle?: T, nSpacingLeft?: number): number;
        /**
         * Sets or retrieves the top spacing of a rectangle or retrieves the top comprehensive rectangle spacing.
         * @param sRectangle Specifies the name of the rectangle. If omitted the rectangle of the comprehensive rectangle will be calculated.
         * @param nSpacingTop Specifies the top spacing.
         * @return Returns the top spacing.
         */
        spacingTop(sRectangle?: T, nSpacingTop?: number): number;
        /**
         * Sets or retrieves the right spacing of a rectangle or retrieves the right comprehensive rectangle spacing.
         * @param sRectangle Specifies the name of the rectangle. If omitted the rectangle of the comprehensive rectangle will be calculated.
         * @param nSpacingLeft Specifies the right spacing.
         * @return Returns the right spacing.
         */
        spacingRight(sRectangle?: T, nSpacingRight?: number): number;
        /**
         * Sets or retrieves the bottom spacing of a rectangle or retrieves the bottom comprehensive rectangle spacing.
         * @param sRectangle Specifies the name of the rectangle. If omitted the rectangle of the comprehensive rectangle will be calculated.
         * @param nSpacingBottom Specifies the bottom spacing.
         * @return Returns the bottom spacing.
         */
        spacingBottom(sRectangle?: T, nSpacingBottom?: number): number;
        /**
         * Retrieves the horizontal spacing of a rectangle or the comprehensive rectangle.
         * @param sRectangle Specifies the name of the rectangle. If omitted the rectangle of the comprehensive rectangle will be calculated.
         * @return Returns the horizontal spacing.
         */
        spacingHorizontal(sRectangle?: T): number;
        /**
         * Retrieves the vertical spacing of a rectangle or the comprehensive rectangle.
         * @param sRectangle Specifies the name of the rectangle. If omitted the rectangle of the comprehensive rectangle will be calculated.
         * @return Returns the vertical spacing.
         */
        spacingVertical(sRectangle?: T): number;
        /**
         * Sets or retrieves the left hint correction of a rectangle.
         * @param sRectangle Specifies the name of the rectangle.
         * @param nHintLeft Specifies the left hint correction.
         * @return Returns the left hint correction.
         */
        hintCorrectionLeft(sRectangle: T, nHintLeft?: number): number;
        /**
         * Sets or retrieves the top hint correction of a rectangle.
         * @param sRectangle Specifies the name of the rectangle.
         * @param nHintTop Specifies the top hint correction.
         * @return Returns the top hint correction.
         */
        hintCorrectionTop(sRectangle: T, nHintTop?: number): number;
        /**
         * Sets or retrieves the right hint correction of a rectangle.
         * @param sRectangle Specifies the name of the rectangle.
         * @param nHintRight Specifies the right hint correction.
         * @return Returns the right hint correction.
         */
        hintCorrectionRight(sRectangle: T, nHintRight?: number): number;
        /**
         * Sets or retrieves the bottom hint correction of a rectangle.
         * @param sRectangle Specifies the name of the rectangle.
         * @param nHintBottom Specifies the bottom hint correction.
         * @return Returns the bottom hint correction.
         */
        hintCorrectionBottom(sRectangle: T, nHintBottom?: number): number;
        /**
         * Retrieves the shifted rectangle.
         * @param sRectangle Specifies the name of the rectangle. If omitted the rectangle of the comprehensive rectangle will be calculated.
         * @return Returns the rectangle.
         */
        shiftRectangle(sRectangle?: T): Rectangle;
        /**
         * Positions the rectangles.
         * @return Returns `true` if the position is changed.
         */
        position(): boolean;
        /**
         * Resizes the rectangles.
         * @return Returns which properties are changed (`none`, `width`, `height` or `both`).
         */
        resize(): "none" | "width" | "height" | "both";
        /**
         * Verifies if the supplied coordinate is within one or more rectangles.
         * @param nX Specifies the left position.
         * @param nY Specifies the top position.
         * @param bSpacing Specifies if the spacing needs to be applied.
         * @return Returns `true` if the coordinate is within one or more rectangles.
         */
        isCoordinateIn(nX: number | undefined, nY: number | undefined, bSpacing?: boolean): boolean;
        /**
         * Verifies if the supplied coordinate is within the comprehensive rectangle.
         * @param nX Specifies the left position.
         * @param nY Specifies the top position.
         * @param bInner Specifies if the inner rectangle needs to be verified.
         * @param pCorrection Specifies correction coordinates.
         * @return Returns `true` if the coordinate is within the comprehensive rectangle.
         */
        isCoordinateInRectangles(nX: number | undefined, nY: number | undefined, bInner?: boolean, pCorrection?: Coordinate): boolean;
        /**
         * Verifies if the supplied coordinate is within the specified rectangle.
         * @param sRectangle Specifies the name of the rectangle.
         * @param nX Specifies the left position.
         * @param nY Specifies the top position.
         * @param bSpacing Specifies if spacing needs to be included.
         * @return Returns `true` if the coordinate is within the specified rectangle.
         */
        isCoordinateInRectangle(sRectangle: T, nX: number | undefined, nY: number | undefined, bSpacing?: boolean): boolean;
    }
    export class Spacing extends Coordinate {
        /**
         * Constructs a new spacing container.
         * @param nLeft Specifies the left spacing.
         * @param nTop Specifies the top spacing.
         * @param nRight Specifies the right spacing.
         * @param nBottom Specifies the bottom spacing.
         */
        constructor(nLeft?: number, nTop?: number, nRight?: number, nBottom?: number);
        /** Retrieves the total horizontal spacing. */
        get horizontal(): number;
        /** Retrieves the total vertical spacing. */
        get vertical(): number;
    }
}

declare module "@tripetto/runner/module/serializer" {
    import { Stack, TAny } from "@tripetto/runner/module/functional";

    export type TSerializePrimitives = string | number | boolean | undefined | null | ISerialize;
    export type TSerializeTypes = TSerializePrimitives | TSerializePrimitives[];
    export interface ISerialize {
        /** Retrieves the specified property. */
        readonly [property: string]: TSerializeTypes;
    }
    /**
     * Serializes a source.
     * @param pSource Reference to the source.
     * @param pData Reference to the data object which receives the serialized data.
     */
    export function serializeTo<T, S extends ISerialize>(pSource: T, pData: S): S;
    /**
     * Deserializes data to a target.
     * @param pTarget Reference to the target.
     * @param pData Reference to the serialized data.
     * @param pAfterwards Optional stack with calls that are invoked after the
     * structural deserialization is done.
     */
    export function deserializeFrom<T, S extends ISerialize>(pTarget: T, pData: S, pAfterwards?: Stack): T;
    export interface IProp {
        /** Name of the propery. */
        readonly property: string;
        /** Value of the property. */
        readonly value: TAny;
    }
    /**
     * Finds all the serializable props.
     * @param pSource Reference to the source.
     */
    export function serializableProps<T>(pSource: T): IProp[];
    /**
     * Finds all the deserializable props.
     * @param pSource Reference to the source.
     */
    export function deserializableProps<T>(pSource: T): IProp[];
    /** Decorator which marks a property to be deserialized. */
    export function deserialize<T>(pTarget: T, sProperty: string, pDescriptor?: PropertyDescriptor): void;
    /** Decorator which marks a function as the deserializer of an object. */
    export function deserializer<T>(pTarget: T, sProperty: string, pDescriptor?: PropertyDescriptor): void;
    /** Decorator which marks a function as the serializer of an object. */
    export function serializer<T>(pTarget: T, sProperty: string, pDescriptor?: PropertyDescriptor): void;
    /** Decorator which marks a property to be serialized. */
    export function serialize<T>(pTarget: T, sProperty: string, pDescriptor?: PropertyDescriptor): void;
}

declare module "@tripetto/runner/module/sha2" {
    /**
     * Hashes the supplied string data using SHA2-224.
     * @param sData Specifies the data to hash.
     * @return Returns the hash string.
     */
    export function SHA2_224(sData: string): string;
    /**
     * Hashes the supplied string data using SHA2-256.
     * @param sData Specifies the data to hash.
     * @return Returns the hash string.
     */
    export function SHA2_256(sData: string): string;
    /**
     * Hashes the supplied string data using SHA2-384.
     * @param sData Specifies the data to hash.
     * @return Returns the hash string.
     */
    export function SHA2_384(sData: string): string;
    /**
     * Hashes the supplied string data using SHA2-512.
     * @param sData Specifies the data to hash.
     * @return Returns the hash string.
     */
    export function SHA2_512(sData: string): string;
    /**
     * Hashes the supplied string data using SHA2-512/224.
     * @param sData Specifies the data to hash.
     * @return Returns the hash string.
     */
    export function SHA2_512_224(sData: string): string;
    /**
     * Hashes the supplied string data using SHA2-512/256.
     * @param sData Specifies the data to hash.
     * @return Returns the hash string.
     */
    export function SHA2_512_256(sData: string): string;
    /**
     * Hashes the supplied string data using SHA2-224. This function implements a
     * cache to optimize performance when the same data is hashed multiple times.
     * @param sData Specifies the data to hash.
     * @return Returns the hash string.
     */
    export function CSHA2_224(sData: string): string;
    /**
     * Hashes the supplied string data using SHA2-256. This function implements a
     * cache to optimize performance when the same data is hashed multiple times.
     * @param sData Specifies the data to hash.
     * @return Returns the hash string.
     */
    export function CSHA2_256(sData: string): string;
    /**
     * Hashes the supplied string data using SHA2-384. This function implements a
     * cache to optimize performance when the same data is hashed multiple times.
     * @param sData Specifies the data to hash.
     * @return Returns the hash string.
     */
    export function CSHA2_384(sData: string): string;
    /**
     * Hashes the supplied string data using SHA2-512. This function implements a
     * cache to optimize performance when the same data is hashed multiple times.
     * @param sData Specifies the data to hash.
     * @return Returns the hash string.
     */
    export function CSHA2_512(sData: string): string;
    /**
     * Hashes the supplied string data using SHA2-512/224. This function implements a
     * cache to optimize performance when the same data is hashed multiple times.
     * @param sData Specifies the data to hash.
     * @return Returns the hash string.
     */
    export function CSHA2_512_224(sData: string): string;
    /**
     * Hashes the supplied string data using SHA2-512/256. This function implements a
     * cache to optimize performance when the same data is hashed multiple times.
     * @param sData Specifies the data to hash.
     * @return Returns the hash string.
     */
    export function CSHA2_512_256(sData: string): string;
}

declare module "@tripetto/runner/module/contracts" {
    import { TTranslation } from "@tripetto/runner/module/l10n";

    export interface IContract {
        /** Specifies contract information. */
        readonly contract?: {
            /** Specifies the contract name. */
            readonly name: string;
            /** Specifies the contract version. */
            readonly version: string;
        };
    }
    export interface IL10nContract {
        /** Specifies the language identifiers of the available translations. */
        readonly availableTranslations?: string[];
        /** Specifies if the locale can be changed. */
        readonly customLocale?: boolean;
        /** Contains the translatable strings table. */
        readonly strings?: (string | [string, string])[];
    }
    export interface IL10n {
        /** Specifies the language of the translation to use. */
        readonly language?: "auto" | string;
        /** Specifies the locale to use. */
        readonly locale?: "auto" | string;
        /** Contains the translations. */
        readonly translations?: TTranslation | TTranslation[];
    }
    export type TL10nContract = IContract & IL10nContract;
    export type TL10n = IContract & IL10n;
    export interface IStyleDependencyObserver {
        /** Specifies the property to observe. */
        readonly property: string;
        /** Specifies the value that should be evaluated. */
        readonly value?: string | string[] | number | number[] | boolean | boolean[];
        /** Specifies if the value is defined or not. */
        readonly defined?: boolean;
    }
    export interface IStyleDependency {
        /** Specifies the observers for the dependency (multiple observers are processed using logical AND). */
        readonly observe: IStyleDependencyObserver | IStyleDependencyObserver[];
        /** Specifies the action to perform. */
        readonly action: "enable" | "disable" | "show" | "hide";
    }
    export type TStyleTiers = "unlicensed" | "licensed";
    export interface IStyleStatic<Type extends string> {
        /** Specifies the style element type. */
        readonly type: Type;
        /** Specifies the variable and its value where the state of this style element depends on. */
        readonly dependency?: IStyleDependency;
        /** Specifies a label for the style element. */
        readonly label?: string;
        /** Specifies a optional description for the style element. */
        readonly description?: string;
        /** Specifies the required tier for using this style element. */
        readonly tier?: TStyleTiers;
    }
    export interface IStyleElement<Type extends string, T> extends IStyleStatic<Type> {
        /** Specifies the name of the style element property. */
        readonly name: string;
        /** Specifies the default value for the style element. */
        readonly default?: T;
    }
    export type TStyleDropdownOption =
        | {
              /** Label for the option. */
              readonly label: string;
              /** Value for the option. */
              readonly value: string | number;
          }
        | {
              /** Specifies an option group. */
              readonly optGroup: string;
          }
        | {
              /** Specifies a custom option that allows the user to specify a custom value. */
              readonly custom: string;
          };
    export interface IStyleDropdown extends IStyleElement<"dropdown", string> {
        /** Specifies the dropdown options. */
        readonly options: TStyleDropdownOption[];
        /** Specifies the width of the field. */
        readonly width?: number | "auto" | "full";
    }
    export interface IStyleRadiobutton {
        /** Label for the button. */
        readonly label: string;
        /** Value for the button. */
        readonly value: string | number;
        /** Optional description for the button. */
        readonly description?: string;
    }
    export interface IStyleRadiobuttons extends IStyleElement<"radiobuttons", string> {
        /** Specifies the radio buttons. */
        readonly buttons: IStyleRadiobutton[];
    }
    export interface IStyleNumber extends IStyleElement<"number", number> {
        /** Prefix for the number. */
        readonly prefix?: string;
        /** Suffix for the number. */
        readonly suffix?: string;
        /** Specifies the minimum value. */
        readonly min?: number;
        /** Specifies the maximum value. */
        readonly max?: number;
        /** Specifies the width of the field. */
        readonly width?: number;
    }
    export type TStyleElement =
        | IStyleStatic<"static">
        | IStyleElement<"label" | "color" | "image", string>
        | IStyleElement<"checkbox", boolean>
        | IStyleNumber
        | IStyleDropdown
        | IStyleRadiobuttons;
    export interface IStyleCollectionBase {
        /** Specifies a description for the collection of style elements. */
        readonly description?: string;
        /** Specifies a property name for the styles. */
        readonly name?: string;
        /** Specifies the variable and its value where the state of this collection depends on. */
        readonly dependency?: IStyleDependency;
        /** Specifies the required tier for using this collection. */
        readonly tier?: TStyleTiers;
        /** Specifies the style elements in this collection. */
        readonly elements: TStyleElement[];
    }
    export interface IStyleCollection extends IStyleCollectionBase {
        /** Specifies the title for the collection of style elements. */
        readonly title?: string;
        /** Specifies if the collection contains optional customizations (a checkbox will be shown before the collection to enable or disable it). */
        readonly optional?: false;
        /** Specifies if the collection contains additional options (they will be displayed at the end). */
        readonly additional?: boolean;
    }
    export interface IStyleCollectionOptional extends IStyleCollectionBase {
        /** Specifies the title for the collection of style elements. */
        readonly title: string;
        /** Specifies if the collection contains optional customizations (a checkbox will be shown before the collection to enable or disable it). */
        readonly optional: true;
        /** An optional collection cannot be additional. */
        readonly additional?: undefined | false;
    }
    export interface IStylesContract {
        /** Specifies the styles. */
        readonly styles: (IStyleCollection | IStyleCollectionOptional)[];
    }
    export interface IStylesProperties {
        readonly [property: string]: string | number | boolean | IStylesProperties | undefined;
    }
    export type TStylesContract = IContract & IStylesContract;
    export type TStyles = IContract & IStylesProperties;
    export interface IThemeContract<T extends TStyles = TStyles> {
        /** Contains the theme name. */
        readonly name: string;
        /** Contains an optional description for the theme. */
        readonly description?: string;
        /** Contains a preview image (as URL or base64 encoded data). */
        readonly preview?: string;
        /** Contains the styles for the theme. */
        readonly styles: T;
    }
    export type TThemesContract<T extends TStyles = TStyles> = IThemeContract<T>[];
}

declare module "@tripetto/runner/module/map" {
    import { Stack, TAny } from "@tripetto/runner/module/functional";
    import {
        Grid,
        GridBranch,
        GridBranches,
        GridNode,
        GridNodes,
        GridRenderer,
        GridSection,
        GridSections,
        IGridResource,
    } from "@tripetto/runner/module/grid";
    import { IHookPayload } from "@tripetto/runner/module/hookup";
    import { MarkdownParser } from "@tripetto/runner/module/markdown";
    import { IItemChangeEvent, IItemPopEvent } from "@tripetto/runner/module/matrix";
    import { IPoint } from "@tripetto/runner/module/metrics";
    import { ISerialize } from "@tripetto/runner/module/serializer";
    import { ISlot, Slot, Slots } from "@tripetto/runner/module/slots";

    export interface INodeBlock extends ISerialize {
        /** Contains the node block type. */
        readonly type: string;
        /** Contains the version of the block. */
        readonly version: string;
    }
    export interface INodeBlockCache {
        readonly timestamp: number;
        readonly block: INodeBlock;
        readonly slots?: ISlot[];
    }
    export interface INode extends IGridResource {
        readonly block?: INodeBlock;
        readonly slots?: ISlot[];
        readonly disabled?: boolean;
        readonly name?: string;
        readonly nameVisible?: boolean;
        readonly placeholder?: string;
        readonly description?: string;
        readonly explanation?: string;
    }
    export abstract class NodeBlock {
        /** Contains the type identifier of the block. */
        static readonly identifier: string;
        /** Contains the version of the block. */
        static readonly version: string;
        /** Contains the kind of block. */
        static readonly kind: "headless" | "ui";
        /** Contains the label localizer. */
        static readonly _: () => string;
        /** Verifies if the block has the specified flag. */
        static readonly flag: (sFlag: string) => boolean;
        /** Retrieves the localized label (name) of the block. */
        static get label(): string;
        /** Specifies an exchange handler for block migrations. */
        static exchanger?: (pSrc: {}[], pDest: {}) => void;

        /** Retrieves the block type. */
        readonly type: INodeBlockType<NodeBlock>;
        /** Specifies if markdown is supported. */
        readonly allowMarkdown?: boolean;
        /**
         * Creates a new block instance or verifies an existing instance.
         * @param pBlock Reference to the block constructor or instance.
         * @param pNode Reference to the parent node.
         * @param sType Specifies the block style.
         * @return Returns the block instance.
         */
        static create<Block extends NodeBlock>(
            pBlock: INodeBlockType<Block> | Block | string,
            pNode: Node,
            sType?: "existing" | "proxy"
        ): Block | undefined;
        /**
         * Constructs a new block.
         * @param pNode Reference to the node.
         */
        constructor(pNode: Node);
        /** Retrieves the identifier of the node. */
        get id(): string;
        /** Retrieves the parent map. */
        get map(): Map | undefined;
        /** Retrieves a reference to the node. */
        get node(): Node;
        /** Retrieves a reference to the slots. */
        get slots(): Slots;
        /** Retrieves the label of the node block. */
        get label(): string;
        /** Retrieves if the block is initialized. */
        get isInitialized(): boolean;

        /**
         * The block is assigned to a node.
         * @param pPrevious Reference to the previous block that was attached to the node.
         * @return Returns an initialization function.
         */
        assignedToNode(pPrevious?: NodeBlock): () => void;
        /** The block is unassigned from the node. */
        unassignedFromNode(): INodeBlockCache;
        /** Marks a change in the block. */
        detectChange(): void;
        /**
         * Rerenders the block.
         * @param bShouldRerender Specifies if the node should rerender.
         * @event
         */
        rerender(bShouldRerender?: boolean): void;
        /**
         * Serializes a block.
         * @param pProperties Specifies additional serialized properties.
         * @return Returns a reference to the serialized block.
         */
        serialize(pProperties?: ISerialize): INodeBlock;
        /**
         * Deserializes to a block instance.
         * @param pBlock Contains the serialized block.
         * @param pAfterwards Stack with calls which are invoked after the
         * structural deserialization is done.
         * @return Returns a reference to the instance.
         */
        deserialize(pBlock: INodeBlock, pAfterwards?: Stack): this;
        /** Destroys the block. */
        destroy(): void;
    }
    export type TNodeEvents = "OnBlockAssign" | "OnBlockUnassign" | "OnBlockChange" | "OnTypeChange" | "OnRename" | "OnDisable";
    export interface INodeBlockAssignEvent extends IHookPayload<"OnBlockAssign"> {
        readonly node: Node;
        readonly block: NodeBlock;
    }
    export interface INodeBlockUnassignEvent extends IHookPayload<"OnBlockUnassign"> {
        readonly node: Node;
        readonly block: NodeBlock;
    }
    export interface INodeBlockChangeEvent extends IHookPayload<"OnBlockChange"> {
        readonly node: Node;
        readonly block: NodeBlock | undefined;
    }
    export interface INodeConstructor {
        new (pNodes: Nodes): Node;
    }
    //@ts-ignore
    export class Nodes extends GridNodes<Node> {
        constructor(pNodeConstructor: INodeConstructor, pSection: Section);
        /** Retrieves the section of the node dispatcher. */
        get section(): Section;
        /**
         * Invoked when the nodes dimensions are changed.
         * @event
         */
        onDimensions(): void;
        /**
         * Inserts a new node.
         * @return Returns the new node.
         */
        append(): Node;
        /**
         * Inserts a new node.
         * @return Returns the new node.
         */
        insert(): Node;
        /**
         * Inserts a new node before the supplied node.
         * @param pNode Specifies the reference node.
         * @return Returns the new node.
         */
        insertBefore(pNode: Node): Node;
        /**
         * Inserts a new node after the supplied node.
         * @param pNode Specifies the reference node.
         * @return Returns the new node.
         */
        insertAfter(pNode: Node): Node;
        /**
         * Deserializes the supplied serialized nodes to the node dispatcher.
         * @param pAfterwards Stack with calls which are invoked after the
         * structural deserialization is done.
         * @param pNodes Specifies the nodes.
         * @return Returns a reference to the instance.
         */
        deserialize(pAfterwards: Stack, ...pNodes: INode[]): this;
    }
    export interface IVariable {
        /** Contains the variable key. */
        readonly key: string;
        /** Human readable label for the variable. */
        readonly label: string;
        /** Reference to the node. */
        readonly node: Node;
        /** Reference to the block. */
        readonly block?: NodeBlock;
        /** Reference to the slot. */
        readonly slot?: Slot;
        /** Reference to the slot pipe. */
        readonly pipe?: Slot;
    }
    /**
     * Tries to find the variable for the given key.
     * @param pRef Reference to a node, condition or block.
     * @param sKey Specifies the key of the variable.
     */
    export const lookupVariable: (pRef: Node | NodeBlock | Condition | ConditionBlock | Section, sKey: string) => IVariable | undefined;
    /**
     * Parses markdown variables.
     * @param pMap Specifies the source map.
     * @return Returns a parser object.
     */
    export const parseVariables: (pRef: Node | NodeBlock | Condition | ConditionBlock | Section) => {
        numberOfChars: number;
        parser: (sKey: string) =>
            | {
                  shift: number;
                  markdown: string;
                  value: IVariable | undefined;
              }
            | undefined;
    };
    export type TNodeType = "undefined" | "static" | "note" | "error" | TNodeBlock;
    export class Node extends GridNode<TNodeEvents> {
        /** Contains the explanation for the node. */
        explanation?: string;
        /** Retrieves the identifier of the node. */
        get id(): string;
        /** Retrieves the parent node dispatcher. */
        //@ts-ignore
        get parent(): Nodes | undefined;
        /** Retrieves the predecessor of the node. */
        get predecessor(): Node | undefined;
        /** Retrieves the successor of the node. */
        get successor(): Node | undefined;
        /** Retrieves the parent map. */
        get map(): Map | undefined;
        /** Retrieves the parent section. */
        get section(): Section | undefined;
        /** Retrieves the block for the node. */
        get block(): NodeBlock | undefined;
        /** Retrieves the block type identifier as a string. */
        get blockTypeIdentifier(): string;
        /** Retrieves if the node has a block. */
        get hasBlock(): boolean;
        /** Retrieves if the block is invalid. */
        get isBlockInvalid(): boolean;
        /** Retrieves if the node is disabled. */
        get disabled(): boolean | undefined;
        /** Specifies if the node is disabled. */
        set disabled(bDisabled: boolean | undefined);
        /** Retrieves the node type. */
        get type(): TNodeType;
        /** Retrieves the name of the node. */
        get name(): string | undefined;
        /** Sets the name of the node. */
        set name(sName: string | undefined);
        /** Retrieves if the name of the node is visible. */
        get nameVisible(): boolean | undefined;
        /** Specifies if the name of the node should be visible. */
        set nameVisible(bNameVisible: boolean | undefined);
        /** Retrieves the placeholder of the node. */
        get placeholder(): string | undefined;
        /** Sets the placeholder of the node. */
        set placeholder(sPlaceholder: string | undefined);
        /** Returns the raw label including markdown formatting. */
        get labelRaw(): string;
        /** Retrieves a markdown instance for the label. */
        get labelMarkdown(): MarkdownParser<IVariable>;
        /**
         * Retrieves the node label in plain text (all markdown is removed). This
         * label is the name of the node or the placeholder if no name is specified.
         */
        get label(): string;
        /** Retrieves the alias for the node. */
        get alias(): string | undefined;
        /** Retrieves the description of the node. */
        get description(): string | undefined;
        /** Sets the description of the node. */
        set description(sDescription: string | undefined);

        /**
         * Fired when a node is changed.
         * @param pEvent Contains the event payload.
         * @event
         */
        protected onChange(pEvent: IItemChangeEvent<this>): void;
        /**
         * Calculates the dimensions of the node (only necessary when we are not moving).
         * @param nWidth Specifies the width of the node.
         * @param nHeight Specifies the height of the node.
         * @return Returns `true` if the node is resized.
         */
        resize(nWidth?: number, nHeight?: number): boolean;
        /**
         * Calculates the z-index of the resource.
         * @return Returns `true` if the z-index is changed.
         */
        zIndex(): boolean;
        /**
         * Assigns a block to the node.
         * @param pBlock Specifies the block type.
         * @return Returns a reference to the block instance.
         */
        assignBlock<T extends NodeBlock>(pBlock: INodeBlockType<T> | T): T | undefined;
        /**
         * Unassigns a block.
         * @return Returns the previously assigned block or `undefined` if there
         * was none.
         */
        unassignBlock(): NodeBlock | undefined;
        /**
         * Generates a serialized representation of a node.
         * @return Returns a reference to the serialized data.
         */
        serialize(): INode;
        /**
         * Deserializes to a node.
         * @param pNode Contains the serialized node.
         * @param pAfterwards Stack with calls which are invoked after the
         * structural deserialization is done.
         * @return Returns a reference to the instance.
         */
        deserialize(pNode: INode, pAfterwards?: Stack): this;
        /**
         * Retrieves a slot.
         * @param sReference Specifies the slot reference or identifier.
         * @param pBlockTypeIdentifier Specifies the block type identifier of the node.
         * @return Returns a reference to the slot.
         */
        slot<S extends Slot>(sReference: string, pBlockTypeIdentifier?: string | TNodeBlock): S | undefined;
        /** Refreshes the node (this will rerender the node and emit an `OnRename` event). */
        refresh(): this;
        /** Indicate the node is refreshed (this will emit an `OnRename` event). */
        refreshed(): this;
        /**
         * Inserts a new node before this node.
         * @return Returns a reference to the new node.
         */
        insertBefore(): Node;
        /**
         * Inserts a new node after this node.
         * @return Returns a reference to the new node.
         */
        insertAfter(): Node;
        /** Enables the node. */
        enable(): this;
        /** Disables the node. */
        disable(): this;
        /**
         * Duplicates the node.
         * @param pDest Specifies the destination node. If omitted a new node is inserted after this node.
         * @return Returns a reference to the new node.
         */
        duplicate(pDest?: Node): Node;
        /** Deletes this node from the map. */
        delete(): this;
        /** Destroys the node. */
        destroy(): void;
    }
    export interface INodeBlockType<T extends NodeBlock> {
        /** Contains the block type identifier. */
        readonly identifier: string;
        /** Contains the block label (name). */
        readonly label: string;
        /** Contains the block version. */
        readonly version: string;
        /** Contains the kind of block. */
        readonly kind: "headless" | "ui";
        /** Contains the label localizer. */
        readonly _: () => string;
        /** Verifies if the block has the specified flag. */
        readonly flag: (sFlag: string) => boolean;
        /**
         * Creates a new block instance.
         * @param pNode Reference to the node.
         */
        new (pNode: Node): T;
    }
    export type TNodeBlock<T extends NodeBlock = NodeBlock> = INodeBlockType<T>;
    export type TConditionBlockContext = "*" | "section" | "branch" | "node" | TNodeBlock;
    export interface IConditionBlockType<T extends ConditionBlock> {
        /** Contains the block type identifier. */
        readonly identifier: string;
        /** Contains the block label (name). */
        readonly label: string;
        /** Contains the block version. */
        readonly version: string;
        /** Contains the block context. */
        readonly context: TConditionBlockContext;
        /** Contains the label localizer. */
        readonly _: () => string;
        /** Verifies if the block has the specified flag. */
        readonly flag: (sFlag: string) => boolean;
        /**
         * Creates a new block instance.
         * @param pCondition Reference to the condition.
         */
        new (pCondition: Condition): T;
    }
    export type TConditionBlock<T extends ConditionBlock = ConditionBlock> = IConditionBlockType<T>;
    export interface IConditionBlock extends ISerialize {
        /** Contains the condition block type. */
        readonly type: string;
        /** Contains the version of the block. */
        readonly version: string;
        /** Contains the id of a related branch. */
        readonly branch?: string;
        /** Contains the id of a related section. */
        readonly section?: string;
        /** Contains the id of a related node. */
        readonly node?: string;
        /** Contains the id of a related slot. */
        readonly slot?: string;
    }
    class Labels {
        constructor(pBlock: ConditionBlock);
        /** Retrieves the branch label (if the branch is present). */
        get branch(): string;
        /** Retrieves the branch label (if the branch is present and an orphan). */
        get branchOrphan(): string;
        /** Retrieves the section label (if the section is present). */
        get section(): string;
        /** Retrieves the section label (if the section is present and an orphan). */
        get sectionOrphan(): string;
        /** Retrieves the node label (if the node is present). */
        get node(): string;
        /** Retrieves the node label (if the node is present and an orphan). */
        get nodeOrphan(): string;
    }
    export abstract class ConditionBlock {
        /** Contains the type identifier of the block. */
        static readonly identifier: string;
        /** Contains the version of the block. */
        static readonly version: string;
        /** Contains the block context. */
        static readonly context: TConditionBlockContext;
        /** Contains the label localizer. */
        static readonly _: () => string;
        /** Verifies if the block has the specified flag. */
        static readonly flag: (sFlag: string) => boolean;
        /** Retrieves the localized label (name) of the block. */
        static get label(): string;

        /** Retrieves the block type. */
        readonly type: IConditionBlockType<ConditionBlock>;
        /** Specifies if markdown is supported. */
        readonly allowMarkdown?: boolean;
        /** Contains the branch. */
        branch?: Branch;
        /** Contains the section. */
        section?: Section;
        /** Contains the node. */
        node?: Node;
        /** Contains the slot. */
        slot?: Slot;
        /**
         * Creates a new block instance or verifies an existing instance.
         * @param pBlock Reference to the block constructor or instance.
         * @param pCondition Reference to the parent condition.
         * @param bInitialize Specifies if the block should be initialized.
         * @return Returns the block instance.
         */
        static create<Block extends ConditionBlock>(
            pBlock: IConditionBlockType<Block> | Block | string,
            pCondition: Condition,
            bInitialize: boolean
        ): Block | undefined;
        /**
         * Constructs a new block.
         * @param pCondition Reference to the condition.
         */
        constructor(pCondition: Condition);
        /** Retrieves the identifier of the condition. */
        get id(): string;
        /** Retrieves the parent map. */
        get map(): Map | undefined;
        /** Retrieves a reference to the condition. */
        get condition(): Condition;
        /** Retrieves if the block is initialized. */
        get isInitialized(): boolean;
        /** Retrieves the name of the condition block. */
        get name(): string;
        /**
         * Retrieves the labels collection. This is a collection of labels that give
         * context to the condition.
         */
        get labels(): Labels;
        /**
         * Retrieves the label of the condition block. This label contains additional
         * context for the condition. For example, if a node is attached to the
         * condition, the label will contain the name of that node. Otherwise, the
         * name of the parent section will be used or the name of the parent branch.
         */
        get label(): string;

        /**
         * Block is assigned to a condition.
         * @param pPrevious Reference to the previous block that was attaced to the condition.
         * @return Returns an initialization function.
         */
        assignedToCondition(pPrevious?: ConditionBlock): () => void;
        /** Block is unassigned from the condition. */
        unassignedFromCondition(): IConditionBlock;
        /**
         * Invoked when the block of a node is unassigned. This may affect the
         * condition. This function verifies if the condition should be deleted.
         * @param pBlock Reference to the node block that is unassigned.
         * @return Should return `true` if the condition should be deleted.
         */
        shouldBeDeleted(pBlock: NodeBlock): boolean;
        /** Marks a change in the block. */
        detectChange(): void;
        /**
         * Rerenders the block.
         * @param bShouldRerender Specifies if the condition should rerender.
         * @event
         */
        rerender(bShouldRerender?: boolean): void;
        /**
         * Serializes a block.
         * @param pProperties Specifies additional serialized properties.
         * @return Returns a reference to the serialized block.
         */
        serialize(pProperties?: ISerialize): IConditionBlock;
        /**
         * Deserializes to a block instance.
         * @param pBlock Contains the serialized block.
         * @param pAfterwards Stack with calls which are invoked after the
         * structural deserialization is done.
         * @return Returns a reference to the instance.
         */
        deserialize(pBlock: IConditionBlock, pAfterwards?: Stack): this;
        /**
         * Deletes the condition.
         * @param sProperty Optional property causing the removal.
         */
        delete(sProperty?: keyof this): void;
        /** Destroys the block. */
        destroy(): void;
    }
    export interface ICondition extends IGridResource {
        readonly block?: IConditionBlock;
        readonly disabled?: boolean;
    }
    export interface IConditionConstructor {
        new (pConditions: Conditions): Condition;
    }
    //@ts-ignore
    export class Conditions extends GridNodes<Condition> {
        constructor(pConditionConstructor: IConditionConstructor, pBranch: Branch);
        /** Retrieves the branch of the condition dispatcher. */
        get branch(): Branch;
        /**
         * Invoked when the conditions dimensions are changed.
         * @event
         */
        onDimensions(): void;
        /**
         * Appends a new condition.
         * @return Returns the new condition.
         */
        append(): Condition;
        /**
         * Inserts a new condition.
         * @return Returns the new condition.
         */
        insert(): Condition;
        /**
         * Inserts a new condition before the supplied condition.
         * @param pCondition Specifies the reference condition.
         * @return Returns the new condition.
         */
        insertBefore(pCondition: Condition): Condition;
        /**
         * Inserts a new condition after the supplied condition.
         * @param pCondition Specifies the reference condition.
         * @return Returns the new condition.
         */
        insertAfter(pCondition: Condition): Condition;
        /**
         * Deserializes the supplied serialized conditions to the condition dispatcher.
         * @param pAfterwards Stack with calls which are invoked after the
         * structural deserialization is done.
         * @param pConditions Specifies the conditions.
         * @return Returns a reference to the instance.
         */
        deserialize(pAfterwards: Stack, ...pConditions: ICondition[]): this;
    }
    export type TConditionEvents = "OnBlockAssign" | "OnBlockUnassign" | "OnBlockChange" | "OnRename" | "OnDisable";
    export interface IConditionBlockAssignEvent extends IHookPayload<"OnBlockAssign"> {
        readonly condition: Condition;
        readonly block: ConditionBlock;
    }
    export interface IConditionBlockUnassignEvent extends IHookPayload<"OnBlockUnassign"> {
        readonly condition: Condition;
        readonly block: ConditionBlock;
    }
    export interface IConditionBlockChangeEvent extends IHookPayload<"OnBlockChange"> {
        readonly condition: Condition;
        readonly block: ConditionBlock | undefined;
    }
    export class Condition extends GridNode<TConditionEvents> {
        /**
         * Creates a new condition instance.
         * @param pConditions Reference to the condition dispatcher.
         */
        constructor(pConditions: Conditions);
        /** Retrieves the identifier of the condition. */
        get id(): string;
        /** Retrieves the parent condition dispatcher. */
        //@ts-ignore
        get parent(): Conditions | undefined;
        /** Retrieves the predecessor of the condition. */
        get predecessor(): Condition | undefined;
        /** Retrieves the successor of the condition. */
        get successor(): Condition | undefined;
        /** Retrieves the parent map. */
        get map(): Map | undefined;
        /** Retrieves the parent branch. */
        get branch(): Branch | undefined;
        /** Retrieves the parent section of the condition. */
        get section(): Section | undefined;
        /** Retrieves the block for the condition. */
        get block(): ConditionBlock | undefined;
        /** Retrieves the block type identifier as a string. */
        get blockTypeIdentifier(): string;
        /** Retrieves if the condition has a block. */
        get hasBlock(): boolean;
        /** Retrieves if the block is invalid. */
        get isBlockInvalid(): boolean;
        /** Retrieves if the condition is disabled. */
        get disabled(): boolean | undefined;
        /** Specifies if the condition is disabled. */
        set disabled(bDisabled: boolean | undefined);
        /** Retrieves the condition type. */
        get type(): IConditionBlockType<ConditionBlock> | undefined;
        /** Retrieves the condition name. */
        get name(): string;
        /** Retrieves a markdown instance for the name. */
        get nameMarkdown(): MarkdownParser<IVariable>;
        /** Retrieves the condition label. */
        get label(): string;

        /**
         * Fired when the condition is changed.
         * @param pEvent Specifies the event payload.
         * @event
         */
        protected onChange(pEvent: IItemChangeEvent<this>): void;
        /**
         * Fired when a condition move occurs.
         * @param nMoveX Specifies the horizontal movement.
         * @param nMoveY Specifies the vertical movement.
         * @param pOffset Specifies the offset of the touch point.
         * @event
         */
        onMove(nMoveX: number, nMoveY: number, pOffset: IPoint): void;
        /**
         * Invokes the condition layout renderer.
         * @param sType Specifies the rerender type. Can be one of the following values:
         * - `refresh`: Refresh the rendering;
         * - `update`: Update the rendering.
         */
        rerender(sType: "refresh" | "update"): void;
        /**
         * Assigns a block to the condition.
         * @param pBlock Specifies the block type.
         * @return Returns a reference to the block instance.
         */
        assignBlock<T extends ConditionBlock>(pBlock: IConditionBlockType<T> | T): T | undefined;
        /**
         * Unassigns a block.
         * @return Returns the previously assigned block or `undefined` if there
         * was none.
         */
        unassignBlock(): ConditionBlock | undefined;
        /**
         * Generates a serialized representation of a condition.
         * @return Returns a reference to the serialized condition.
         */
        serialize(): ICondition;
        /**
         * Deserializes to a condition.
         * @param pCondition Contains the serialized condition.
         * @param pAfterwards Stack with calls which are invoked after the
         * structural deserialization is done.
         * @return Returns a reference to the instance.
         */
        deserialize(pCondition: ICondition, pAfterwards?: Stack): this;
        /** Refreshes the condition (this will rerender the condition and emit an `OnRename` event). */
        refresh(): this;
        /** Indicate the condition is refreshed (this will emit an `OnRename` event). */
        refreshed(): this;
        /**
         * Inserts a new condition before this condition.
         * @return Returns a reference to the new condition.
         */
        insertBefore(): Condition;
        /**
         * Inserts a new condition after this condition.
         * @return Returns a reference to the new condition.
         */
        insertAfter(): Condition;
        /** Enables the condition. */
        enable(): this;
        /** Disables the condition. */
        disable(): this;
        /**
         * Duplicates the condition.
         * @param pDest Specifies the destination condition. If omitted a new condition is inserted after this condition.
         * @return Returns a reference to the new condition.
         */
        duplicate(pDest?: Condition): Condition;
        /** Deletes this condition from the map. */
        delete(): this;
        /** Destroys the condition. */
        destroy(): void;
    }
    export type TBranchCulling = "first" | "each" | "all" | "none";
    export interface IEpilogue {
        readonly title?: string;
        readonly description?: string;
        readonly image?: string;
        readonly video?: string;
        readonly button?: {
            readonly label: string;
            readonly url: string;
            readonly target: "self" | "blank";
        };
        readonly repeatable?: boolean;
        readonly redirectUrl?: string;
    }
    export interface IBranch extends IGridResource {
        readonly conditions?: ICondition[];
        readonly sections?: ISection[];
        readonly culling?: TBranchCulling;
        readonly jump?: string;
        readonly name?: string;
        readonly epilogue?: IEpilogue & ISerialize;
    }
    export interface ISection extends IGridResource {
        readonly type?: "branch" | "nest";
        readonly branches?: IBranch[];
        readonly nodes?: INode[];
        readonly name?: string;
        readonly reference?: string;
        readonly version?: string;
        readonly alias?: string;
        readonly readonly?: true;
        readonly randomize?: boolean;
        readonly bookmark?: boolean;
        readonly bookmarkName?: string;
        readonly bookmarkDescription?: string;
        readonly bookmarkLevel?: number;
    }
    export interface IBuilder {
        /** Builder name. */
        readonly name: string;
        /** Builder version. */
        readonly version: string;
    }
    export interface IPrologue {
        readonly title?: string;
        readonly description?: string;
        readonly image?: string;
        readonly video?: string;
        readonly button?: string;
    }
    export interface IDefinition {
        /** Contains the sections. */
        readonly sections: ISection[];
        /** Contains information about the builder. */
        readonly builder: IBuilder;
        /** Contains the map name. */
        readonly name?: string;
        /** Contains the map description. */
        readonly description?: string;
        /** Contains the map keywords. */
        readonly keywords?: string[];
        /** Contains the language of the map. */
        readonly language?: string;
        /** Contains the prologue for the map. */
        readonly prologue?: IPrologue;
        /** Contains the epilogue for the map. */
        readonly epilogue?: IEpilogue;
        /**
         * Contains the preface for the map.
         * @deprecated
         */
        readonly preface?: IPrologue;
    }
    //@ts-ignore
    export class Map extends Grid<Sections, Node, "OnRename" | "OnChange" | "OnReset" | "OnError"> {
        /** Contains the name of the map. */
        name?: string;
        /** Contains the description of the map. */
        description?: string;
        /** Contains the language of the map. */
        language?: string;
        /** Contains the keywords for the map. */
        keywords?: string[];
        /** Contains the prologue for the map. */
        prologue?: IPrologue;
        /** Contains the epilogue for the map. */
        epilogue?: IEpilogue;
        /**
         * Creates a new map instance.
         * @param pRenderer Reference to a renderer for the map.
         * @param pBuilder Specifies information about the builder.
         */
        //@ts-ignore
        static create(pRenderer?: GridRenderer<Map>, pBuilder?: IBuilder): Map;
        /**
         * Creates a new map instance.
         * @param pRenderer Reference to a renderer for the map.
         * @param pBuilder Specifies information about the builder.
         */
        //@ts-ignore
        constructor(pRenderer?: GridRenderer<Map>, pBuilder?: IBuilder);
        /** Retrieves information about the builder application. */
        get application(): IBuilder;
        /** Retrieves information about the builder used to create the definition. */
        get builder(): IBuilder;
        /** Retrieves the sections. */
        get sections(): Sections;
        /** Retrieves the map definition. */
        get definition(): IDefinition;
        /** Sets the map definition. */
        set definition(pMap: IDefinition);
        /** Retrieves if the map is deserializing. */
        get isDeserializing(): boolean;
        /**
         * Generates a serialized representation of a map.
         * @return Returns a reference to the serialized map.
         */
        serialize(): IDefinition & IGridResource;
        /**
         * Deserializes to a map.
         * @param pMap Specifies the serialized map.
         * @return Returns a reference to the instance.
         */
        deserialize(pMap: IDefinition & IGridResource): this;
        /**
         * Iterate recursively through each item in the map.
         * @param fnEach Callback which is invoked for each item.
         * @param sType Specifies the type of items.
         * @param pExclude Specifies an item that needs to be excluded from the iteration.
         * @param bFromExcluded Specifies if the iteration should start when the excluded item is found.
         * @return Returns `true` if the iteration was interrupted.
         */
        forEach(
            fnItem:
                | ((pItem: Branch, nDepth: number) => boolean | void)
                | ((pItem: Section, nDepth: number) => boolean | void)
                | ((pItem: Node, nDepth: number) => boolean | void)
                | ((pItem: Condition, nDepth: number) => boolean | void)
                | ((pItem: Branch | Section | Node | Condition, nDepth: number) => boolean | void),
            sType?: "branches" | "sections" | "nodes" | "conditions" | "all",
            pExclude?: Branch | Section | Node | Condition,
            bFromExcluded?: boolean
        ): boolean;
        /** Complete reload of the map. */
        reload(): void;
        /** Resets the map. */
        reset(): void;
        /** Destroys the map. */
        destroy(): void;
    }
    export interface ISectionConstructor {
        new (pSections: Sections): Section;
    }
    //@ts-ignore
    export class Sections extends GridSections<Section, Node> {
        constructor(pSectionConstructor: ISectionConstructor, pBranch: Branch);
        /** Retrieves the map of the section dispatcher. */
        get map(): Map | undefined;
        /** Retrieves the branch of the section dispatcher. */
        get branch(): Branch | Map | undefined;
        /**
         * Invoked when the section dimensions are changed.
         * @event
         */
        onDimensions(): void;
        /**
         * Appends a new section.
         * @return Returns the new section.
         */
        append(): Section;
        /**
         * Inserts a new section.
         * @return Returns the new section.
         */
        insert(): Section;
        /**
         * Inserts a new section before the supplied section.
         * @param pSection Specifies the reference section.
         * @return Returns the new section.
         */
        insertBefore(pSection: Section): Section;
        /**
         * Inserts a new section after the supplied section.
         * @param pSection Specifies the reference section.
         * @return Returns the new branch.
         */
        insertAfter(pSection: Section): Section;
        /**
         * Appends a new branch section.
         * @returns Returns a reference to the new branch and section.
         */
        appendBranch(): [Branch, Section];
        /**
         * Inserts a new branch section.
         * @returns Returns a reference to the new branch and section.
         */
        insertBranch(): [Branch, Section];
        /**
         * Inserts a new branch section before the supplied section.
         * @param pBefore Specifies the reference section.
         * @returns Returns a reference to the new branch and section.
         */
        insertBranchBefore(pBefore: Section): [Branch, Section];
        /**
         * Inserts a new branch section after the supplied section.
         * @param pAfter Specifies the reference section.
         * @returns Returns a reference to the new branch and section.
         */
        insertBranchAfter(pAfter: Section): [Branch, Section];
        /**
         * Appends a new nested branch section.
         * @returns Returns a reference to the new branch and section.
         */
        appendNestedBranch(): [Branch, Section];
        /**
         * Inserts a new nested branch section.
         * @returns Returns a reference to the new branch and section.
         */
        insertNestedBranch(): [Branch, Section];
        /**
         * Inserts a new nested branch section before the supplied section.
         * @param pBefore Specifies the reference section.
         * @returns Returns a reference to the new branch and section.
         */
        insertNestedBranchBefore(pBefore: Section): [Branch, Section];
        /**
         * Inserts a new nested branch section after the supplied section.
         * @param pAfter Specifies the reference section.
         * @returns Returns a reference to the new branch and section.
         */
        insertNestedBranchAfter(pAfter: Section): [Branch, Section];
        /**
         * Deserializes the supplied serialized sections to the section dispatcher.
         * @param pAfterwards Stack with calls which are invoked after the
         * structural deserialization is done.
         * @param pSections Specifies the sections.
         * @return Returns a reference to the instance.
         */
        deserialize(pAfterwards: Stack, ...pSections: ISection[]): this;
    }
    export interface IBranchConstructor {
        new (pBranches: Branches): Branch;
    }
    //@ts-ignore
    export class Branches extends GridBranches<Branch, Node> {
        constructor(pBranchConstructor: IBranchConstructor, pSection: Section);
        /** Retrieves the section of the branch dispatcher. */
        get section(): Section;
        /**
         * Invoked when the branch dimensions are changed. This aligns the space
         * occupied by the conditions.
         * @event
         */
        onDimensions(): void;
        /**
         * Appends a new branch.
         * @return Returns the new branch.
         */
        append(): Branch;
        /**
         * Inserts a new branch.
         * @return Returns the new branch.
         */
        insert(): Branch;
        /**
         * Inserts a new branch before the supplied branch.
         * @param pBranch Specifies the reference branch.
         * @return Returns the new branch.
         */
        insertBefore(pBranch: Branch): Branch;
        /**
         * Inserts a new branch after the supplied branch.
         * @param pBranch Specifies the reference branch.
         * @return Returns the new branch.
         */
        insertAfter(pBranch: Branch): Branch;
        /**
         * Deserializes the supplied serialized branches to the branch dispatcher.
         * @param pAfterwards Stack with calls which are invoked after the
         * structural deserialization is done.
         * @param pBranches Specifies the branches.
         * @return Returns a reference to the instance.
         */
        deserialize(pAfterwards: Stack, ...pBranches: (IBranch & IGridResource)[]): this;
    }
    export type TSectionEvents = "OnRename";
    //@ts-ignore
    export class Section extends GridSection<Nodes, Node, TSectionEvents> {
        /** Contains the bookmark description. */
        bookmarkDescription?: string;
        /** Contains the bookmark level. */
        bookmarkLevel?: number;
        /**
         * Creates a new section instance.
         * @param pSections Reference to the section dispatcher.
         */
        constructor(pSections: Sections, sType?: "branch" | "nest");
        /** Retrieves the identifier of the section. */
        get id(): string;
        /** Retrieves the parent section dispatcher. */
        //@ts-ignore
        get parent(): Sections | undefined;
        /** Retrieves the predecessor of the section. */
        get predecessor(): Section | undefined;
        /** Retrieves the successor of the section. */
        get successor(): Section | undefined;
        /** Retrieves the parent map. */
        get map(): Map | undefined;
        /** Retrieves the parent branch. */
        get branch(): Branch | undefined;
        /** Retrieves the nodes. */
        get nodes(): Nodes;
        /** Retrieves the branches. */
        get branches(): Branches;
        /** Retrieves if the section has branches. */
        get hasBranches(): boolean;
        /**
         * Retrieves the section type, which can be one of the following values:
         * - `section`: The section is a regular section;
         * - `branch`: The section serves as a branch;
         * - `nest`: The section holds a nested branch.
         */
        get type(): "section" | "branch" | "nest";
        /** Retrieves the optional reference for a nested branch. */
        get reference(): string | undefined;
        /** Sets the optional reference for a nested branch. */
        set reference(sReference: string | undefined);
        /** Retrieves the optional version for a nested branch. */
        get version(): string | undefined;
        /** Sets the optional version for a nested branch. */
        set version(sVersion: string | undefined);
        /** Retrieves if the nested branch is read-only. */
        get isReadonly(): boolean;
        /** Sets if the nested branch is read-only. */
        set isReadonly(bReadonly: boolean);
        /** Retrieves the name of the section. */
        get name(): string | undefined;
        /** Sets the name of the section. */
        set name(sName: string | undefined);
        /** Retrieves the optional alias of the section. */
        get alias(): string | undefined;
        /** Sets the optional alias for the section. */
        set alias(sAlias: string | undefined);
        /** Retrieves a list of branches which have a jump to this section. */
        get jumps(): Branch[];
        /** Retrieves if the bookmark is enabled. */
        get bookmark(): boolean | undefined;
        /** Enables or disables the bookmark. */
        set bookmark(bBookmark: boolean | undefined);
        /** Retrieves the bookmark name. */
        get bookmarkName(): string | undefined;
        /** Sets the bookmark name. */
        set bookmarkName(sBookmark: string | undefined);
        /** Contains if the section content should be randomized. */
        get randomize(): boolean | undefined;
        /** Enables or disables section content randomization. */
        set randomize(bRandomize: boolean | undefined);

        /**
         * Fired when a section is changed.
         * @param pEvent Contains the event payload.
         * @event
         */
        protected onChange(pEvent: IItemChangeEvent<this>): void;
        /**
         * Invoked when the section is popped.
         * @param pEvent Contains the event payload.
         * @event
         */
        onPop(pEvent: IItemPopEvent<this>): void;
        /**
         * Iterate through each node and branch of the section.
         * @param fnResource Specifies the resource function.
         * @param fnResource.pResource Contains a reference to the resource.
         * @return Returns `true` if the iteration is stopped (break).
         */
        //@ts-ignore
        forEachDescendant(fnResource: (pResource: Node | Branch) => boolean | void): boolean;
        /**
         * Calculates the dimensions of the section (only necessary when we are not moving).
         * @param nWidth Specifies the width of the section.
         * @param nHeight Specifies the height of the section.
         * @return Returns `true` if the section is resized.
         */
        resize(nWidth?: number, nHeight?: number): boolean;
        /**
         * Generates a serialized representation of a section.
         * @return Returns a reference to the serialized section.
         */
        serialize(): ISection;
        /**
         * Deserializes to a section.
         * @param pSection Contains the serialized section.
         * @param pAfterwards Stack with calls which are invoked after the
         * structural deserialization is done.
         * @return Returns a reference to the instance.
         */
        deserialize(pSection: ISection, pAfterwards?: Stack): this;
        /**
         * Inserts a new section before this section.
         * @return Returns a reference to the new section.
         */
        insertBefore(): Section;
        /**
         * Inserts a new section after this section.
         * @return Returns a reference to the new section.
         */
        insertAfter(): Section;
        /**
         * Inserts a new branch section before this section.
         * @returns Returns a reference to the new branch and section.
         */
        insertBranchBefore(): [Branch, Section];
        /**
         * Inserts a new branch section after this section.
         * @returns Returns a reference to the new branch and section.
         */
        insertBranchAfter(): [Branch, Section];
        /**
         * Inserts a new nested branch section before this section.
         * @returns Returns a reference to the new branch and section.
         */
        insertNestedBranchBefore(): [Branch, Section];
        /**
         * Inserts a new nested branch section after this section.
         * @returns Returns a reference to the new branch and section.
         */
        insertNestedBranchAfter(): [Branch, Section];
        /**
         * Duplicates the section.
         * @return Returns a reference to the new section.
         */
        duplicate(): Section;
        /**
         * Extracts a nested branch to the parent form.
         * @returns Returns `true` if the subform was extracted successfully.
         */
        extract(): boolean;
        /**
         * Convert a (nested) section back to a regular section.
         * @returns Returns `true` if the conversion was successfully.
         */
        convertToSection(): boolean;
        /**
         * Convert the section to a branch.
         * @returns Returns `true` if the conversion was successfully.
         */
        convertToBranch(): boolean;
        /** Converts a section to a nested branch. */
        convertToNestedBranch(): void;
        /**
         * Moves the section to a nested branch.
         * @param pDest Specifies the nested branch to add the section to.
         * @return Returns `true` if the section was moved succesfully.
         */
        moveToNestedBranch(pDest: Section): boolean;
        /**
         * Moves the section to the parent of the nested branch.
         * @returns Returns `true` if the section was moved succesfully.
         */
        moveToParent(): boolean;
        /**
         * Loads a definition to a nested branch.
         * @param pDefinition Specifies the definition to load as nested branch.
         * @param sReference Specifies an optional reference to store.
         * @param sVersion Specifies an optional version identifier.
         * @param sAlias Specifies an optional alias for the nested branch.
         * @param bReadonly Specifies if the form is read-only.
         * @return Returns `true` if the nest was loaded succesfully.
         */
        loadNestedBranch(pDefinition: IDefinition, sReference?: string, sVersion?: string, sAlias?: string, bReadonly?: boolean): boolean;
        /** Deletes this section from the map. */
        delete(): this;
        /** Resets the section. */
        reset(): void;
        /** Destroys a section. */
        destroy(): void;
    }
    export type TBranchTerminator = "continuous" | "abort" | "return" | "jump" | "epilogue";
    export type TBranchEvents = "OnCullingChange" | "OnTerminatorChange" | "OnRename";
    export interface IBranchCullingEvent extends IHookPayload<"OnCullingChange"> {
        readonly branch: Branch;
        readonly culling: TBranchCulling;
    }
    export interface IBranchTerminatorEvent extends IHookPayload<"OnTerminatorChange"> {
        readonly branch: Branch;
        readonly terminator: TBranchTerminator;
        readonly jump: Section | undefined;
        readonly epilogue: IEpilogue | undefined;
    }
    //@ts-ignore
    export class Branch extends GridBranch<Sections, Node, TBranchEvents> {
        /** Retrieves if the branch is validating. */
        static get isValidating(): boolean;
        /**
         * Creates a new branch instance.
         * @param pBranches Reference to the branch dispatcher.
         */
        constructor(pBranches: Branches);
        /** Retrieves the identifier of the branch. */
        get id(): string;
        /** Retrieves the parent branch dispatcher. */
        //@ts-ignore
        get parent(): Branches | undefined;
        /** Retrieves the predecessor of the branch. */
        get predecessor(): Branch | undefined;
        /** Retrieves the successor of the branch. */
        get successor(): Branch | undefined;
        /** Retrieves the parent map. */
        get map(): Map | undefined;
        /** Retrieves the origin. */
        //@ts-ignore
        get origin(): Map | Branch | undefined;
        /** Retrieves if this is an origin branch. */
        get isOrigin(): boolean;
        /** Retrieves the parent section. */
        get section(): Section | undefined;
        /** Retrieves the conditions. */
        get conditions(): Conditions;
        /** Retrieves the sections. */
        get sections(): Sections;
        /** Retrieves the branch spacing. */
        get spacing(): number;
        /** Retrieves the current offset for the branch. */
        get offset(): number;
        /** Sets the offset for the branch. */
        set offset(nOffset: number);
        /** Retrieves the culling mode. */
        get culling(): TBranchCulling;
        /** Sets the culling mode. */
        set culling(sCulling: TBranchCulling);
        /** Retrieves the termination mode. */
        get terminator(): TBranchTerminator;
        /** Sets the termination mode for the branch. */
        set terminator(sTerminator: TBranchTerminator);
        /** Retrieves the jump-to-section. */
        get jump(): Section | undefined;
        /** Sets the jump-to-section. */
        set jump(pTo: Section | undefined);
        /** Retrieves the jump-to-section. */
        get epilogue(): IEpilogue | undefined;
        /** Sets the jump-to-section. */
        set epilogue(pEpilogue: IEpilogue | undefined);
        /** Retrieves the name of the branch. */
        get name(): string | undefined;
        /** Sets the name of the branch. */
        set name(sName: string | undefined);
        /**
         * Fired when a branch is changed.
         * @param pEvent Contains the event payload.
         * @event
         */
        protected onChange(pEvent: IItemChangeEvent<this>): void;
        /**
         * Fired when a branch move occurs.
         * @param nMoveX Specifies the horizontal movement.
         * @param nMoveY Specifies the vertical movement.
         * @param pOffset Specifies the offset of the touch point.
         * @event
         */
        onMove(nMoveX: number, nMoveY: number, pOffset: IPoint): void;
        /**
         * Iterate through each section and condition of the branch.
         * @param fnResource Specifies the resource function.
         * @param fnResource.pResource Contains a reference to the resource.
         * @return Returns `true` if the iteration is stopped (break).
         */
        //@ts-ignore
        forEachDescendant(fnResource: (pResource: Condition | Section) => boolean | void): boolean;
        /**
         * Applies the spacing for the conditions.
         * @param nWidth Specifies the width of the resource.
         * @param nHeight Specifies the height of the resource.
         * @return Returns `true` if the resource is resized.
         */
        resize(nWidth?: number, nHeight?: number): boolean;
        applyResize(sType?: "redraw" | "zoom"): boolean;
        /**
         * Generates a serialized representation of a branch.
         * @return Returns a reference to the serialized branch.
         */
        serialize(): IBranch;
        /**
         * Deserializes to a branch.
         * @param pBranch Contains the serialized data.
         * @param pAfterwards Stack with calls which are invoked after the
         * structural deserialization is done.
         * @return Returns a reference to the instance.
         */
        deserialize(pBranch: IBranch & IGridResource, pAfterwards?: Stack): this;
        /**
         * Inserts a new branch before this branch.
         * @return Returns a reference to the new branch.
         */
        insertBefore(): Branch;
        /**
         * Inserts a new branch after this branch.
         * @return Returns a reference to the new branch.
         */
        insertAfter(): Branch;
        /**
         * Duplicates the branch.
         * @param pDest Specifies the destination branch. If omitted a new branch is inserted after this branch.
         * @return Returns a reference to the new branch.
         */
        duplicate(pDest?: Branch): Branch;
        /**
         * Loads a nested branch.
         * @param pDefinition Specifies the definition to load as nested branch.
         * @param sReference Specifies an optional reference to store.
         * @param sVersion Specifies an optional version identifier.
         * @param sAlias Specifies an optional alias for the nested branch.
         * @param bReadonly Specifies if the subform is read-only.
         * @return Returns `true` if the nest was loaded succesfully.
         */
        load(pDefinition: IDefinition, sReference?: string, sVersion?: string, sAlias?: string, bReadonly?: boolean): boolean;
        /** Deletes this branch from the map. */
        delete(): this;
        /** Resets the branch. */
        reset(): void;
        /** Destroys a branch. */
        destroy(): void;
    }
    export interface IConditionBlockDecorator {
        /** Specifies the block namespace(s). */
        readonly namespace?: string | string[];
        /** Specifies this block is a condition block. */
        readonly type: "condition";
        /** Specifies the block identifier. */
        readonly identifier: string;
        /** Specifies optional type aliases. */
        readonly alias?: string | string[];
        /** Specifies the localized block label (if you use `gettext`, return the localized string using a getter function). */
        readonly label: string;
        /**
         * Specifies the block context. Can be one of the following values:
         * - `*`: Conditions that can be used anywhere in the map;
         * - `section`: If the condition applies to sections;
         * - `branch`: If the condition applies to branches;
         * - `node`: If the condition applies to nodes;
         * - A reference to a node block (the condition applies to nodes of that specific type);
         * - The type string identifier of a node block (the condition applies to nodes of that specific type).
         */
        readonly context: TConditionBlockContext | string;
        /** Specifies the version of the block in SemVer format (defaults to `0.0.0`). */
        readonly version?: string;
        /**
         * Specifies that this is a Tripetto legacy block. These blocks were previously
         * registered with the identifier `tripetto-block-<name>`. Later we moved the
         * blocks to the organization scope `@tripetto`. When this property is specified,
         * Tripetto will automatically create an alias for blocks that are in the Tripetto
         * organization scope so their old identifier still works.
         */
        readonly legacyBlock?: true;
    }
    export interface INodeBlockDecorator {
        /** Specifies the block namespace(s). */
        readonly namespace?: string | string[];
        /** Specifies this block is a node block. */
        readonly type: "node";
        /** Specifies the type identifier. */
        readonly identifier: string;
        /** Specifies optional type aliases. */
        readonly alias?: string | string[];
        /** Specifies the localized block label (if you use `gettext`, return the localized string using a getter function). */
        readonly label: string;
        /** Specifies the version of the block in SemVer format (defaults to `0.0.0`). */
        readonly version?: string;
        /**
         * Specifies the kind of block. Can be one of the following values:
         * - `headless`: Specifies the block is headless (needs no user interface);
         * - `ui`: Specifies the block needs a user interface.
         */
        readonly kind?: "headless" | "ui";
        /**
         * Specifies that this is a Tripetto legacy block. These blocks were previously
         * registered with the identifier `tripetto-block-<name>`. Later we moved the
         * blocks to the organization scope `@tripetto`. When this property is specified,
         * Tripetto will automatically create an alias for blocks that are in the Tripetto
         * organization scope so their old identifier still works.
         */
        readonly legacyBlock?: true;
    }
    function observe(map?: Map): void;
    /**
     * Verifies if a required property evaluates to `true`.
     * @param pTarget Reference to the target.
     * @return Returns `true` if the target has required condition.
     */
    export function isRequired<T extends NodeBlock>(pTarget: T): boolean;
    class NodeBlocksNamespace {
        /** Creates a new namespace instance. */
        constructor(sIdentifier: string);
        /** Retrieves the identifier for the namespace. */
        get identifier(): string;
        /** Retrieves a list of registered blocks. */
        get all(): TNodeBlock[];
        /** Retrieves the array of missing block types. */
        get missing(): string[];
        /** Contains the number of missing block types. */
        get errors(): number;
        /**
         * Registers the supplied block.
         * @param pBlock Specifies the block.
         * @param sIdentifier Specifies the block type identifier.
         * @param pAliases Specifies type aliases for the block.
         * @param fnLabel Specifies the localized label for the block as a function.
         * @param sVersion Specifies the version of the block in SemVer format (defaults to `0.0.0`).
         * @param sKind Specifies the block kind. Can be one of the following values:
         * - `headless`: Specifies the block is headless (has no user interface);
         * - `ui`: Specifies the block implements a user interface.
         * @param bLegacyBlock Specifies the block is a Tripetto legacy block.
         */
        register(
            pBlock: TNodeBlock,
            sIdentifier: string,
            pAliases: string[],
            fnLabel: () => string,
            sVersion: string,
            sKind: "headless" | "ui",
            bLegacyBlock: boolean
        ): TNodeBlock;
        /**
         * Retrieves the block constructor of the specified type identifier.
         * @param sIdentifier Specifies the block type identifier.
         * @return Returns the block constructor or `undefined` if the block
         * type is not available.
         */
        ofType<T extends TNodeBlock>(sIdentifier: string): T | undefined;
        /** Reset missing types. */
        resetMissing(): void;
    }
    class ConditionBlocksNamespace {
        /** Creates a new namespace. */
        constructor(sIdentifier: string);
        /** Retrieves the identifier for the namespace. */
        get identifier(): string;
        /** Retrieves a list of registered blocks. */
        get all(): TConditionBlock[];
        /** Retrieves the array of missing block types. */
        get missing(): string[];
        /** Contains the number of missing block types. */
        get errors(): number;
        /**
         * Registers a block.
         * @param pBlock Specifies the block.
         * @param sIdentifier Specifies the block type identifier.
         * @param pAliases Specifies type aliases for the block.
         * @param fnLabel Specifies the localized label for the block as a function.
         * @param pContext Specifies the context.
         * @param sVersion Specifies the version of the block in SemVer format (defaults to `0.0.0`).
         * @param bLegacyBlock Specifies the block is a Tripetto legacy block.
         */
        register(
            pBlock: TConditionBlock,
            sIdentifier: string,
            pAliases: string[],
            fnLabel: () => string,
            pContext: TConditionBlockContext | string,
            sVersion: string,
            bLegacyBlock: boolean
        ): TConditionBlock;
        /**
         * Retrieves the registered blocks for the specified context.
         * @param pContext Specifies the context.
         */
        for<T extends TConditionBlock>(pContext: TConditionBlockContext | NodeBlock): T[];
        /**
         * Retrieves the block constructor with the specified type identifier.
         * @param sIdentifier Specifies the block type identifier.
         * @return Returns the block constructor or `undefined` if the block
         * type is not available.
         */
        ofType<T extends TConditionBlock>(sIdentifier: string): T | undefined;
        /** Reset missing types. */
        resetMissing(): void;
    }
    export interface INamespace {
        readonly identifier: string;
        readonly nodeBlocks: NodeBlocksNamespace;
        readonly conditionBlocks: ConditionBlocksNamespace;
    }
    export class Namespaces {
        /** Invoked when a block is registered. */
        static onRegister?: (identifier: string, block: TAny, type: "node" | "condition", version: string) => void;
        /** Retrieves the active namespace. */
        static get active(): INamespace;
        /** Retrieves a list of missing block type identifiers. */
        static get missingBlockTypes(): string[];
        /** Retrieves the total number of erroneous blocks due to missing block types. */
        static get erroneousBlocks(): number;
        /**
         * Retrieves the namespace for the specified identifier (or the active
         * namespace if the identifier is omitted).
         */
        static get(sIdentifier?: string): INamespace;
        /** Retrieves if the supplied namespace is available. */
        static isAvailable(sIdentifier: string): boolean;
        /**
         * Load an UMD namespace for the specified identifier.
         * @param sIdentifier Specifies the namespace identifier.
         * @param pContext Reference to a context to use.
         * @param sContext Specifies the UMD name of the context.
         * @param sUMD UMD code that is executed within the context.
         * @param bUnload Specifies if the namespace should unload if it is already available (default is `true`).
         * @return Returns a ref to the namespace.
         */
        static loadUMD(sIdentifier: string, pContext: {}, sContext: string, sUMD: string, bUnload?: boolean): INamespace | undefined;
        /**
         * Loads a namespace from an URL for the specified identifier.
         * @param sIdentifier Specifies the namespace identifier.
         * @param pContext Reference to a context to use.
         * @param sContext Specifies the UMD name of the context.
         * @param sPolicy Specifies the Trusted Types policy to use.
         * @param sURL Specifies the URL to load from.
         * @param fnCallback Invoked when the loading is done.
         * @param bUnload Specifies if the namespace should unload if it is already available (default is `true`).
         */
        static loadURL(
            sIdentifier: string,
            pContext: {},
            sContext: string,
            sPolicy: string,
            sURL: string,
            fnCallback?: (pNamespace?: INamespace) => void,
            bUnload?: boolean
        ): void;
        /** Unloads the specified namespace. */
        static unload(sIdentifier: string): boolean;
        /**
         * Mounts (activates) a namespace context.
         * @param sIdentifier Specifies the namespace identifier.
         */
        static mount(sIdentifier: string): INamespace;
        /** Unmounts (deactivates) the active namespace context. */
        static unmount(): void;
        /** Activates the namespace with the specified identifier. */
        static activate(sIdentifier: string): INamespace;
        /** Activates the default namespace. */
        static activateDefault(): INamespace;
        /**
         * Activate a namespace for the specified identifier (or tries to load it if it is not available).
         * @param sIdentifier Specifies the namespace identifier.
         * @param pContext Reference to a context to use.
         * @param sContext Specifies the UMD name of the context.
         * @param sUMD UMD code that is executed within the context.
         * @param bAlwaysLoad Specifies if the bundle should always load, even when there is already a
         * namespace available with the specified identifier (default is `true`).
         * @param bUnloadFirst Specifies if the namespace should unload if it is already available (default is `false`).
         * @return Returns a ref to the namespace.
         */
        static activateOrLoadUMD(
            sIdentifier: string,
            pContext: {},
            sContext: string,
            sUMD: string,
            bAlwaysLoad?: boolean,
            bUnloadFirst?: boolean
        ): INamespace | undefined;
        /**
         * Activate a namespace for the specified identifier (or tries to load it if it is not available).
         * @param sIdentifier Specifies the namespace identifier.
         * @param pContext Reference to a context to use.
         * @param sContext Specifies the UMD name of the context.
         * @param sPolicy Specifies the Trusted Types policy to use.
         * @param sURL Specifies the URL to load from.
         * @param fnCallback Invoked when the loading is done.
         * @param bAlwaysLoad Specifies if the bundle should always load, even when there is already a
         * namespace available with the specified identifier (default is `true`).
         * @param bUnloadFirst Specifies if the namespace should unload if it is already available (default is `false`).
         */
        static activateOrLoadURL(
            sIdentifier: string,
            pContext: {},
            sContext: string,
            sPolicy: string,
            sURL: string,
            fnCallback?: (pNamespace?: INamespace) => void,
            bAlwaysLoad?: boolean,
            bUnloadFirst?: boolean
        ): void;
        /** Resets all missing types. */
        static resetMissing(): void;
        /** Specifies block types to include. */
        static include(...sTypes: string[]): void;
        /** Specifies block types to exclude. */
        static exclude(...sTypes: string[]): void;
        /**
         * Retrieves if a block type is allowed.
         * @param sType Specifies the block type to check.
         * @returns Returns `true` if the block is allowed.
         */
        static isAllowed(sType: string): boolean;
        /**
         * Flags blocks.
         * @param sFlag Specifies the flag identifier.
         * @param sTypes Specifies the types to flag.
         */
        static flag(sFlag: string, ...sTypes: string[]): void;
        /**
         * Checks if a block has a flag.
         * @param sFlag Specifies the flag identifier to check.
         * @param sType Specifies the block type.
         * @returns Returns `true` if the block was flagged.
         */
        static hasFlag(sFlag: string, sType: string): boolean;
    }
    /**
     * Mounts (activates) a namespace context.
     * @param sIdentifier Specifies the namespace identifier.
     * @return Returns a ref to the namespace context.
     */
    export function mountNamespace(sIdentifier: string): INamespace;
    /** Unmounts (deactivates) the active namespace context. */
    export function unmountNamespace(): void;
    export type TMap<T> = (pRef: T, pIds: IId[], fnMap: TMap<T>) => T;
    export interface IId {
        from: string;
        to: string;
    }
    /**
     * Rotates the id of an item.
     * @param pIds Reference to the id array.
     * @param pRef Reference to the item.
     */
    export function rotateId<
        T extends {
            readonly id: string;
        },
    >(pIds: IId[], pRef: T): T;
    /**
     * Combines the id of an item.
     * @param pIds Reference to the id array.
     * @param pRef Reference to the item.
     * @param sHash Specifies the hash to combine with.
     */
    export function combineId<
        T extends {
            readonly id: string;
        },
    >(pIds: IId[], pRef: T, sHash: string): T;
    /**
     * Maps the id's in the source data to their rotated values.
     * @param fnMap Specifies the mapper function.
     * @param pSrc Reference to the data.
     */
    export function mapIds<T>(fnMap: TMap<T>, pSrc: T): T;
    /** Marks a property that affects the name or label of a node or condition. */
    export function affects<T extends NodeBlock | ConditionBlock>(
        sTarget: "#name" | "#label"
    ): (pTarget: T, sProperty: string, pDescriptor?: PropertyDescriptor) => void;
    /** Marks a property that affects the state of the condition. */
    export function affects<T extends ConditionBlock>(
        sTarget: "#condition"
    ): (pTarget: T, sProperty: string, pDescriptor?: PropertyDescriptor) => void;
    /** Marks a property that affects the slots or the required condition of a node. */
    export function affects<T extends NodeBlock>(
        sTarget: "#slots" | "#required"
    ): (pTarget: T, sProperty: string, pDescriptor?: PropertyDescriptor) => void;
    /**
     * Marks the block assigned function that is invoked when the block is assigned
     * to a node or condition. The following arguments are passed to the function:
     * - `previous` (NodeBlock | ConditionBlock | undefined): Reference to any
     * previous block that was attached (could be undefined when there was none).
     */
    export function assigned<T extends NodeBlock | ConditionBlock>(pTarget: T, sMethod: keyof T, pDescriptor?: PropertyDescriptor): void;
    /**
     * Defines a node block.
     * @param pProperties Specifies the properties for the block.
     */
    export function block(pProperties: INodeBlockDecorator): (pBlock: TNodeBlock) => void;
    /**
     * Defines a condition block.
     * @param pProperties Specifies the properties for the block.
     */
    export function block(pProperties: IConditionBlockDecorator): (pBlock: TConditionBlock) => void;
    /**
     * Marks the block created function that is invoked when the block is created
     * (right after the instance is created and just before deserialization occurs).
     */
    export function created<T extends NodeBlock | ConditionBlock>(pTarget: T, sMethod: keyof T, pDescriptor?: PropertyDescriptor): void;
    /**
     * Include property in the definition.
     * @param sType Specifies the type of the property (`string`, `number`, `boolean` or a unique custom identifier).
     * @param sOptional Specifies if the property is `optional` or `required`. Optional properties can have `undefined` as value.
     * @param sMode Specifies the mode:
     * - `r`: Reads a property from the definition;
     * - `w`: Writes a property to the definition;
     * - `rw`: Reads and writes a property from/to the definition.
     */
    export function definition<T>(
        sType?: "string" | "number" | "boolean" | string,
        sOptional?: "optional" | "required",
        sMode?: "r" | "w" | "rw"
    ): (pTarget: T, sProperty: string, pPropertyDescriptor?: PropertyDescriptor) => void;
    /** Include property in the definition. */
    export function definition<T>(pTarget: T, sProperty: string, pPropertyDescriptor?: PropertyDescriptor): void;
    /** Retrieves the type of the specified property. */
    export function getDefinitionType<T>(
        pTarget: T,
        sProperty: string
    ):
        | {
              readonly type: "string" | "number" | "boolean" | string;
              readonly optional: boolean;
              readonly isPrimitive: boolean;
          }
        | undefined;
    /**
     * Marks the block destroyed function that is invoked when the block is
     * destroyed.
     */
    export function destroyed<T extends NodeBlock | ConditionBlock>(pTarget: T, sMethod: keyof T, pDescriptor?: PropertyDescriptor): void;
    /**
     * Marks a function that is invoked when the supplied property is detached.
     * If your function returns a callback, the removal of the condition
     * block is canceled and the callback is invoked after all pending a-sync
     * operations on the map are done. Example: You have a condition block that is
     * attached to a node using the `Node` property of the condition block. When
     * the attached node is deleted, it is detached from the condition block and the
     * function is invoked.
     * @param sProperty Specifies the property to monitor.
     */
    export function detached<T extends ConditionBlock>(
        sProperty: keyof T
    ): (pTarget: T, sFunction: string, pDescriptor?: PropertyDescriptor) => void;
    /**
     * Marks the slot function where you define the slots for a block. The following
     * arguments are passed to the function:
     * - `slots` (SlotsOrchestrator): Reference to the `Slots` orchestrator.
     */
    export function slots<T extends NodeBlock>(pTarget: T, sMethod: keyof T, pDescriptor?: PropertyDescriptor): void;
    /**
     * Marks the block unassigned function that is invoked when the block is
     * unassigned from a node.
     */
    export function unassigned<T extends NodeBlock | ConditionBlock>(pTarget: T, sMethod: keyof T, pDescriptor?: PropertyDescriptor): void;
    /**
     * Marks the upgraded function that is invoked when a block is loaded that was
     * created using an older version of the block implementation. You can use an
     * upgrade function to migrate older blocks to the new version of the block.
     * The following arguments are passed to the function:
     * - `prevVersion` (string): String that contains the previous version number of
     * the block.
     */
    export function upgraded<T extends NodeBlock | ConditionBlock>(pTarget: T, sMethod: keyof T, pDescriptor?: PropertyDescriptor): void;
    export interface IMapChangeEvent extends IHookPayload<"OnChange"> {
        readonly map: Map;
    }
    export interface IMapResetEvent extends IHookPayload<"OnReset"> {
        readonly map: Map;
    }
    export interface IMapErrorEvent extends IHookPayload<"OnError"> {
        readonly map: Map;
        readonly erroneousBlocks: number;
        readonly missingBlockTypes: string[];
    }

    export { observe as detectChange };
}

declare module "@tripetto/runner/module/slots" {
    import { TAny } from "@tripetto/runner/module/functional";
    import { HookProps, IHookPayload, THooks } from "@tripetto/runner/module/hookup";
    import { IDimensionChangeEvent, IItemPopEvent, Item, Matrix } from "@tripetto/runner/module/matrix";
    import { ISerialize, TSerializeTypes } from "@tripetto/runner/module/serializer";

    export type TSlotEvents = "OnSlotRename" | "OnSlotRequired" | "OnSlotProperty";
    export interface ISlotEvent<H extends THooks, T extends Slot> extends IHookPayload<H> {
        /** Reference to the slot. */
        readonly slot: T;
    }
    export interface ISlotRenameEvent<T extends Slot> extends ISlotEvent<"OnSlotRename", T> {}
    export interface ISlotRequiredEvent<T extends Slot> extends ISlotEvent<"OnSlotRequired", T> {}
    export interface ISlotPropertyEvent<T extends Slot> extends ISlotEvent<"OnSlotProperty", T> {
        /** Specifies the changed property. */
        readonly property: keyof T;
    }
    /** Specifies the slot kinds. */
    export type Kinds = "meta" | "static" | "dynamic" | "feature";
    export type TPipeable =
        | boolean
        | {
              /** Optional name for the pipe. */
              readonly pipe?: string;
              /** Optional localized label for the pipe. */
              readonly label?: string;
              /** Optional alias for the pipe. */
              readonly alias?: string;
              /**
               * Specifies the field or content that should be used as the data that goes
               * into the pipe. Can be one of the following values:
               * - `value`: Use the current string value of the slot (this is the default behavior);
               * - `label`: Use the slot label;
               * - `name`: Use the name of the slot;
               * - Custom configuration to supply the data that goes into the pipe.
               */
              readonly content?:
                  | "value"
                  | "label"
                  | "name"
                  | {
                        /** Contains the content as a string without any markup or variables. */
                        readonly string: string;
                        /** Contains the content as text with support for variables. */
                        readonly text?: string;
                        /** Contains markdown content with support for basic formatting, hyperlinks and variables. */
                        readonly markdown?: string;
                    };
              /**
               * Specifies the name of a legacy pipe. Only here for backwards compatibility.
               * @deprecated
               */
              readonly legacy?: string;
          };
    export abstract class Slot<T extends TSerializeTypes = TSerializeTypes> extends Item<TSlotEvents> {
        /** Contains the static type identifier. */
        static readonly type: string;

        /** Contains the label of the slot. */
        label?: string;
        /** Contains the name of the slot. */
        name?: string;
        /** Contains the placeholder of the slot. */
        placeholder?: string;
        /** Contains an alias for the slot. */
        alias?: string;
        /** Contains if this slot is required. */
        required?: boolean;
        /** Contains if this slot is pipeable. */
        pipeable?: TPipeable;
        /** Contains the default slot data value. */
        default?: T;
        /** Contains if this slot is exportable. */
        exportable?: boolean;
        /** Contains if this slot is actionable. */
        actionable?: boolean;
        /** Contains if this slot is protected. */
        protected?: boolean;

        /**
         * Creates a new slot instance.
         * @param pType Reference to the type constructor.
         * @param sKind Specifies the kind.
         * @param sReference Specifies the reference for the slot.
         * @param nSequence Specifies the sequence number.
         * @param sPipe Specifies the pipe identifier of the slot.
         * @param pExchangables Specifies the exchangeable slot properties.
         * @param pSlotsOrId Contains a reference to the slots or the id for the slot.
         */
        constructor(
            pType: ISlotType,
            sKind: Kinds,
            sReference: string,
            nSequence?: number,
            sPipe?: string,
            pExchangables?: string[],
            pSlotsOrId?: Slots | string
        );
        /** Retrieves a reference to the slots. */
        get slots(): Slots | undefined;
        /** Retrieves the identifier of the slot. */
        get id(): string;
        /** Retrieves the slot type identifier. */
        get type(): string;
        /** Retrieves the slot kind. */
        get kind(): Kinds;
        /** Retrieves the sequence number. */
        get sequence(): number | undefined;
        /** Sets the sequence number. */
        set sequence(nSequence: number | undefined);
        /** Retrieves the slot reference. */
        get reference(): string;
        /** Retrieves the exchangeable slot properties. */
        get exchangeables(): {
            property: string;
            value: TAny;
        }[];

        /**
         * Fired when the slot is popped.
         * @param pEvent Specifies the event payload.
         * @event
         */
        protected onPop(pEvent: HookProps<IItemPopEvent<this>>): void;
        /**
         * Emits the `OnSlotProperty` event.
         * @param sProperty Specifies the changed property.
         * @event
         */
        propertyChange(sProperty: keyof this): void;
        /**
         * Serializes a slot.
         * @return Returns a reference to the serialized slot.
         */
        serialize(): ISlot<T>;
        /**
         * Deserializes to a slot instance.
         * @param pSlot Contains the serialized slot.
         * @return Returns a reference to the instance.
         */
        deserialize(pSlot: ISlot<T>): this;
        /**
         * Deprecates a slot.
         * @return Returns a reference to the instance.
         */
        deprecate(): this;
        /**
         * Deletes a slot.
         * @return Returns a reference to the instance.
         */
        delete(): this;
        /** Retrieves the pipe identifier for the slot. */
        pipe(pOrigin?: { readonly id: string }): string;
        /**
         * Retrieves the legacy pipe identifier for the slot.
         * @deprecated
         */
        legacyPipe(pOrigin?: { readonly id: string }): string | undefined;
        /**
         * Verifies if the supplied identifier is a pipe.
         * @param sId Specifies the identifier to check.
         * @return Returns `true` if the identifier is a pipe.
         */
        isPipe(sId: string | undefined): boolean;
        /** Specifies the exchangeable slot properties. */
        exchange(pExchangables: string[] | undefined): void;
        /**
         * Converts the supplied data to a valid value.
         * @param pData Specifies the data.
         * @return Returns the data value.
         */
        abstract toValue(pData: TSerializeTypes): T;
        /**
         * Converts the supplied data to a valid string.
         * @param pData Specifies the data.
         * @return Returns the data as a string.
         */
        abstract toString(pData: TSerializeTypes): string;
    }
    export interface ISlotType<T extends Slot = Slot> {
        /** Contains the slot type identifier. */
        readonly type: string;
        /**
         * Creates a new slot instance.
         * @param nSlotsId Contains the slots identifier.
         * @param pType Reference to the type constructor.
         * @param sKind Specifies the kind.
         * @param sReference Specifies the reference.
         * @param nSequence Specifies the sequence number.
         * @param sPipe Specifies the pipe identifier of the slot.
         * @param pExchangables Specifies the exchangeable slot properties.
         * @param pSlotsOrId Contains a reference to the slots or the id for the slot.
         */
        new (
            pType: ISlotType,
            sKind: Kinds,
            sReference: string,
            nSequence?: number,
            sPipe?: string,
            pExchangables?: (keyof T)[],
            pSlotsOrId?: Slots | string
        ): T;
    }
    export interface ISlotBase<T extends TSerializeTypes = TSerializeTypes> {
        /** Contains the id for the serialized slot. */
        readonly id: string;
        /** Contains the slot type. */
        readonly type: string;
        /** Contains the slot kind. */
        readonly kind: Kinds;
        /** Contains the slot reference. */
        readonly reference: string;
        /** Contains the slot sequence number. */
        readonly sequence?: number;
        /** Contains the label for the slot. */
        readonly label?: string;
        /** Contains the slot name. */
        readonly name?: string;
        /** Contains the slot placeholder. */
        readonly placeholder?: string;
        /** Contains the slot alias. */
        readonly alias?: string;
        /** Contains if the slot is required. */
        readonly required?: boolean;
        /** Contains if the slot is pipeable. */
        readonly pipeable?: TPipeable;
        /** Contains the default slot value. */
        readonly default?: T;
        /** Contains if this slot is exportable. */
        readonly exportable?: boolean;
        /** Contains if the slot is actionable. */
        readonly actionable?: boolean;
        /** Contains if the slot is protected. */
        readonly protected?: boolean;
    }
    export interface ISlotProperties<T extends Slot>
        extends Partial<Pick<T, Exclude<keyof ISlotBase, "id" | "type" | "kind" | "reference">>> {
        /** Contains the slot type. */
        readonly type: ISlotType<T>;
        /** Contains the slot reference. */
        readonly reference: string;
        /** Contains the label for the slot. */
        readonly label: string;
        /** Defines the pipe identifier of the slot. */
        readonly pipe?: string;
        /** Specifies the exchangeable slot properties. */
        readonly exchange?: (keyof T)[];
    }
    export interface ISlot<T extends TSerializeTypes = TSerializeTypes> extends ISlotBase<T>, ISerialize {}
    export class Slots extends Matrix<Slot, TSlotEvents> {
        /**
         * Registers a slot type.
         * @param pType Specifies the slot instance constructor.
         * @param sType Specifies the slot type.
         */
        static register<T extends Slot>(pType: ISlotType<T>, sType: string): void;
        /**
         * Retrieves the slot constructor of the specified type.
         * @param sType Specifies the slot type.
         * @return Returns the slot constructor or `undefined` if the slot type is not
         * available.
         */
        static ofType<T extends Slot>(sType: string): ISlotType<T> | undefined;
        /** Constructs a new slots instance. */
        constructor(pOrigin?: { readonly id: string });
        /** Retrieves the slots id. */
        get id(): string | undefined;
        /** Retrieves if the slots are being deserialized. */
        get isDeserializing(): boolean;
        /** Retrieves if multiple pipeable slots are present. */
        get hasMultiplePipeable(): boolean;

        /**
         * Fired when the amount of slots is changed.
         * @param pEvent Specifies the event payload.
         * @event
         */
        protected onDimensionChange(pEvent: IDimensionChangeEvent<this>): void;
        /**
         * Creates a new meta slot.
         * @param pProperties Specifies the properties for the slot.
         * @return Returns a reference to the slot.
         */
        meta<T extends Slot>(pProperties: ISlotProperties<T>): T;
        /**
         * Creates a new static slot.
         * @param pProperties Specifies the properties for the slot.
         * @return Returns a reference to the slot.
         */
        static<T extends Slot>(pProperties: ISlotProperties<T>): T;
        /**
         * Creates a new dynamic slot.
         * @param pProperties Specifies the properties for the slot.
         * @return Returns a reference to the slot.
         */
        dynamic<T extends Slot>(pProperties: ISlotProperties<T>): T;
        /**
         * Creates a new feature slot.
         * @param pProperties Specifies the properties for the slot.
         * @return Returns a reference to the slot.
         */
        feature<T extends Slot>(pProperties: ISlotProperties<T>): T;
        /**
         * Selects a slot.
         * @param sReferenceOrId Reference or identifier of the slot.
         * @param sKind Specifies the optional kind of the slot.
         * @return Returns the slot or `undefined` if no slot is found.
         */
        select<T extends Slot>(sReferenceOrId: string, sKind?: Kinds): T | undefined;
        /**
         * Selects a slot by the specified identifier.
         * @param sId Specifies the slot or pipe identifier to search for.
         * @return Returns the slot or `undefined` if no slot was found.
         */
        selectByIdentifier<T extends Slot>(sId: string): T | undefined;
        /**
         * Deprecates a slot.
         * @param sReferenceOrId Reference or identifier of the slot.
         * @param sKind Specifies the optional kind of the slot.
         * @return Returns the slot or `undefined` if no slot is found.
         */
        deprecate<T extends Slot>(sReferenceOrId: string, sKind?: Kinds): T | undefined;
        /**
         * Deletes a slot.
         * @param sReferenceOrId Reference or identifier of the slot.
         * @param sKind Specifies the optional kind of the slot.
         * @return Returns the slot or `undefined` if no slot is found.
         */
        delete<T extends Slot>(sReferenceOrId: string, sKind?: Kinds): T | undefined;
        /**
         * Removes all the slots from the collection except the supplied slots.
         * @param sKind Specifies the kind of slots to remove (or `undefined` to remove all).
         * @param pExclude Specifies the slots to exclude. Those are kept in the slots collection.
         */
        clean(sKind?: Kinds, ...pExclude: (Slot | undefined)[]): void;
        /**
         * Sorts the slots.
         * @return Returns `true` if the order of the slots is changed.
         */
        sort(): boolean;
        /**
         * Serializes the slots to an array.
         * @return Returns the slots array.
         */
        serialize(): ISlot[];
        /**
         * Deserializes slots.
         * @param pSlots Specifies the slots array.
         * @return Returns a reference to the instance.
         */
        deserialize(pSlots: ISlot[]): this;
        /** Destroys the slots instance. */
        destroy(): void;
    }
    export type Transformations = "none" | "capitalize" | "capitalize-words" | "capitalize-sentences" | "uppercase" | "lowercase";
    export type Precision = "years" | "months" | "days" | "hours" | "minutes" | "seconds" | "milliseconds";
    /**
     * Defines a slot type.
     * @param sType Specifies the slot type name.
     */
    export function slot<T extends Slot>(sType: string): (pType: ISlotType<T>) => void;
    /**
     * Marks a property as a slot property.
     * @param pTarget Reference to the slot.
     * @param sProperty Specifies the slot property.
     * @param pDescriptor Reference to the property descriptor.
     */
    export function property(pTarget: Slot, sProperty: string, pDescriptor?: PropertyDescriptor): void;
    class BooleanSlot extends Slot<boolean> {
        /** Contains the string label for false values. */
        labelForFalse?: string;
        /** Contains the string label for true values. */
        labelForTrue?: string;
        /**
         * Converts the supplied data to a valid boolean value.
         * @param pData Specifies the data.
         * @return Returns the boolean value.
         */
        toValue(pData: TSerializeTypes): boolean;
        /**
         * Converts the supplied data to a valid string.
         * @param pData Specifies the data.
         * @return Returns the data as a string.
         */
        toString(pData: TSerializeTypes): string;
    }
    class DateSlot extends Slot<number> {
        /** Specifies the date/time precision (defaults to `milliseconds`). */
        precision?: Precision;
        /** Contains the minimum date. */
        minimum?: Date | number | true;
        /** Contains the maximum date. */
        maximum?: Date | number | true;
        /** Retrieves if the slot supports time. */
        get supportsTime(): boolean;

        /**
         * Converts the supplied data to a date value.
         * @param pData Specifies the data.
         * @param sPrecision Specifies the precision to use.
         * @return Returns the date value.
         */
        toValue(pData: TSerializeTypes | Date, sPrecision?: Precision): number;
        /**
         * Converts the supplied data to a valid date object.
         * @param pData Specifies the data.
         * @param sPrecision Specifies the precision to use.
         * @return Returns the data as a date object.
         */
        toDate(pData: TSerializeTypes | Date, sPrecision?: Precision): Date;
        /**
         * Converts the supplied data to a valid string.
         * @param pData Specifies the data.
         * @param sPrecision Specifies the precision to use.
         * @return Returns the data as a string.
         */
        toString(pData: TSerializeTypes | Date, sPrecision?: Precision): string;
    }
    class NumberSlot extends Slot<number> {
        /**
         * Converts the supplied data to a valid number value.
         * @param pData Specifies the data.
         * @return Returns the number value.
         */
        toValue(pData: TSerializeTypes): number;
        /**
         * Converts the supplied data to a valid string.
         * @param pData Specifies the data.
         * @param fnFormatter Optional formatter function used when no separator, decimal or minus sign is specified.
         * @return Returns the data as a string.
         */
        toString(pData: TSerializeTypes, fnFormatter?: (nValue: number | string) => string): string;
    }
    export class Numeric extends Slot<number> {
        /** Contains the minimal value. */
        minimum?: number;
        /** Contains the maximum value. */
        maximum?: number;
        /** Contains the thousands separtor sign. */
        separator?: string;
        /** Contains the decimal sign. */
        decimal?: string;
        /** Contains the minus sign. */
        minus?: string;
        /** Contains the prefix. */
        prefix?: string;
        /** Contains the plural prefix. */
        prefixPlural?: string;
        /** Contains the suffix. */
        suffix?: string;
        /** Contains the plural suffix. */
        suffixPlural?: string;
        /** Contains the number of digits. */
        digits?: number;
        /** Retrieves the numeric precision. */
        get precision(): number | undefined;
        /** Sets the numeric precision. */
        set precision(nPrecision: number | undefined);
        /**
         * Converts the supplied data to a valid numeric value.
         * @param pData Specifies the data.
         * @return Returns the numeric value.
         */
        toValue(pData: TSerializeTypes): number;
        /**
         * Formats a string.
         * @param sNumber Specifies the number to format.
         * @param bPlural Specifies if the plural prefix and suffix should be used.
         * @return Returns the formatted string.
         */
        formatString(sNumber: string, bPlural: boolean): string;
        /**
         * Converts the supplied data to a valid string.
         * @param pData Specifies the data.
         * @param fnFormatter Optional formatter function used when no separator, decimal or minus sign is specified.
         * @return Returns the data as a string.
         */
        toString(pData: TSerializeTypes, fnFormatter?: (nValue: number | string, nPrecision?: number | "auto") => string): string;
    }
    class StringSlot extends Slot<string> {
        /**
         * Converts the supplied data to a valid string value.
         * @param pData Specifies the data.
         * @return Returns the string value.
         */
        toValue(pData: TSerializeTypes): string;
        /**
         * Converts the supplied data to a valid string.
         * @param pData Specifies the data.
         * @return Returns the data as a string.
         */
        toString(pData: TSerializeTypes): string;
    }
    export class Text extends Slot<string> {
        /** Retrieves the maximum text length. */
        get maxLength(): number | undefined;
        /** Sets the maximum text length. */
        set maxLength(nMaxLength: number | undefined);
        /** Specifies the transformation to apply. */
        transformation?: Transformations;
        /**
         * Converts the supplied data to a valid text value.
         * @param pData Specifies the data.
         * @return Returns the text value.
         */
        toValue(pData: TSerializeTypes): string;
        /**
         * Converts the supplied data to a valid string.
         * @param pData Specifies the data.
         * @return Returns the data as a string.
         */
        toString(pData: TSerializeTypes): string;
    }
    export { serialize, deserialize } from "@tripetto/runner/module/serializer";

    export { BooleanSlot as Boolean, DateSlot as Date, NumberSlot as Number, StringSlot as String };
}

declare module "@tripetto/runner/module/vfsm" {
    import { Await, Callback, ICallbackPromise } from "@tripetto/runner/module/callback";
    import { TAny } from "@tripetto/runner/module/functional";
    import { IHookPayload, THookContext, THooks } from "@tripetto/runner/module/hookup";
    import { Namespace } from "@tripetto/runner/module/l10n";
    import { Item, Matrix, StrictItem, StrictMatrix } from "@tripetto/runner/module/matrix";
    import { ISerialize, TSerializeTypes } from "@tripetto/runner/module/serializer";
    import { ISlot, Slot, Slots } from "@tripetto/runner/module/slots";

    export interface IOntologyProperties extends ISerialize {
        /** Contains the property identifier. */
        readonly id: string;
    }
    export type TBranchCulling = "first" | "each" | "all" | "none";
    export interface IBranch extends IOntologyProperties {
        /**
         * Specifies the jump reference for the branch. If this property is omitted
         * or an empty string, the branch successor will be determined
         * automatically. If this property is set to 'abort' the stack pointer will
         * be killed after the branch. If this property is set to the identifier
         * of another state, the stack pointer is redirected to that state.
         */
        readonly jump?: string | "abort" | "return";
        /** Specifies the culling mode for the branch. */
        readonly culling?: TBranchCulling;
        /** Specifies if this branch should spawn a new stack. */
        readonly spawn?: boolean;
    }
    export interface IFactory<
        Dispatcher extends StrictMatrix<Dispatcher, Factory<Dispatcher, Ontology, Hooks>, void, Ontology>,
        T extends Factory<Dispatcher, Ontology, Hooks>,
        Ontology extends IOntologyProperties,
        Hooks extends THooks = void,
    > {
        readonly property: string[];
        new (pDispatcher: Dispatcher, pOntology: Ontology): T;
    }
    abstract class Factory<
        Dispatcher extends StrictMatrix<Dispatcher, Factory<Dispatcher, Ontology, Hooks>, void, Ontology>,
        Ontology extends IOntologyProperties,
        Hooks extends THooks = void,
    > extends StrictItem<Dispatcher, Hooks, Ontology> {
        /** Contains the ontology property. */
        static readonly property: string[];

        /**
         * Constructs a new item.
         * @param pDispatcher Reference to the dispatcher.
         * @param sHash Specifies the unique hash for the item.
         */
        constructor(pDispatcher: Dispatcher, sHash: string);
        /** Retrieves the ancestor state. */
        get ancestor(): State | undefined;
        /** Retrieves the parent branch. */
        get branch(): Branch | undefined;
        /** Retrieves the identifier. */
        get id(): string;

        /**
         * Prepares the instance.
         * @param pAncestor Reference to the ancestor.
         * @param pBranch Reference to the branch.
         */
        prepare(pAncestor: State, pBranch?: Branch | undefined): Factory<Dispatcher, Ontology, Hooks>;
        /**
         * Sets the successor state.
         * @param sMode Specifies the mode.
         * @param pState Specifies the state to set.
         */
        setSuccessor(sMode: "live" | "preview", pState: State | undefined): void;
        /**
         * Retrieves a reference to the successor state.
         * @param sMode Specifies the mode.
         * @return Returns the successor state.
         */
        successor(sMode: "live" | "preview"): State | undefined;
    }
    export interface ICondition extends IOntologyProperties {}
    export abstract class Condition<T extends ICondition = ICondition> extends Factory<Conditions, T> {
        /**
         * Creates the context for the given condition props.
         * @param pCondition Reference to the condition props.
         * @return Returns the context.
         */
        static createContext<T extends ICondition>(pCondition: T): string;
        /**
         * Constructs a new condition.
         * @param pConditions Reference to the condition dispatcher.
         * @param pCondition Reference to the condition props.
         */
        constructor(pConditions: Conditions, pCondition: T);
        /** Reference to the conditions dispatcher. */
        protected get conditions(): Conditions;
        /** Reference to the parent branch. */
        get branch(): Branch;
        /** Reference to the parent state. */
        get state(): State;
        /** Retrieves the condition context. */
        get context(): string;
        /** Retrieves the condition properties. */
        get props(): Readonly<T>;
        /**
         * Invoked when the VFSM wants to verify the condition.
         * @param pContext Reference to the context.
         * @param pCallback Reference to the callback pointer. Pass this pointer as
         * return value to enable the asynchronous condition callback.
         * @return Returns the result of the condition or the callback reference if
         * the condition should be handled asynchronously.
         * @event
         */
        abstract onCondition(pContext: Context, pCallback: Callback<boolean>): boolean | Callback<boolean>;
        /**
         * Invoked when the condition is approved.
         * @param pContext Reference to the context.
         * @event
         */
        onApproved(pContext: Context): void;
    }
    export interface IChainLookup {
        /** Retrieves a state. */
        readonly state: (sHash: string) => State | undefined;
        /** Retrieves a transducer. */
        readonly transducer: (sHash: string) => Transducer | undefined;
        /** Retrieves a branch. */
        readonly branch: (sHash: string) => Branch | undefined;
        /** Retrieves a condition. */
        readonly condition: (sHash: string) => Condition | undefined;
        /** Retrieves a slot or slot pipe. */
        readonly slot: (sHash: string) => Slot | Slot[] | undefined;
    }
    export class Value<T extends TSerializeTypes = TSerializeTypes, S extends Slot<T> = Slot<T>> {
        /**
         * Creates a new value store.
         * @param pTransducer Reference to the transducer.
         * @param pSlot Reference to the slot.
         * @param sContext Contains the context of the value.
         * @param pContext Contains a reference to the context.
         * @param fnChange Contains the change callback.
         * @param pValue Contains the hot value.
         * @param sReference Contains the value reference.
         * @param sDisplay Contains the display value.
         * @param nTime Contains the UTC set time of the value.
         * @param bSealed Specifies if the value was sealed.
         * @param bLocked Specifies if the value was locked.
         */
        constructor(
            pTransducer: Transducer,
            pSlot: S,
            sContext: string,
            pContext: Context | undefined,
            fnChange: (pValue: Value<T, S>, sChange: "value" | "seal") => void,
            pValue?: TSerializeTypes,
            sReference?: string,
            sDisplay?: string,
            nTime?: number,
            bSealed?: boolean,
            bLocked?: boolean
        );
        /** Retrieves the value instance identifier. */
        get id(): number;
        /** Retrieves a unique key for the value within its context (the key is prefixed with an underscore). */
        get key(): string;
        /** Retrieves the context for the value. */
        get context(): "*" | string;
        /** Retrieves a reference to the context. */
        get contextRef(): Context | undefined;
        /** Retrieves a reference to the slot. */
        get slot(): S;
        /** Retrieves the pristine value. */
        get pristine(): TSerializeTypes;
        /** Sets the pristine value. */
        set pristine(pValue: TSerializeTypes);
        /** Retrieves the value. */
        get value(): T;
        /** Sets the value. */
        set value(pValue: T);
        /**
         * Retrieves the value as a string (this will always return a string with a
         * value regardless of a pristine value was set).
         */
        get string(): string;
        /** Retrieves the optional value reference. */
        get reference(): string | undefined;
        /** Retrieves the stage value. */
        get display(): string | undefined;
        /** Retrieves if there is a value. */
        get hasValue(): boolean;
        /** Retrieves if the value is modified. */
        get isModified(): boolean;
        /** Retrieves if the value is preliminarily. */
        get isPreliminarily(): boolean;
        /** Retrieves if the value is sealed. */
        get isSealed(): boolean;
        /** Retrieves if the value is dirty. */
        get isDirty(): boolean;
        /** Retrieves if the seal should to be verified. */
        get shouldVerifySeal(): boolean;
        /** Retrieves if the value is frozen. */
        get isFrozen(): boolean;
        /** Retrieves if the value is locked. */
        get isLocked(): boolean;
        /** Retrieves if the value is awaiting. */
        get isAwaiting(): boolean;
        /** Specifies if the value can be prefilled. */
        get allowPrefill(): boolean;
        /** Retrieves the value set timestamp. */
        get time(): number | undefined;
        /** Retrieves a immutable representation of the value. */
        get immutable(): ImmutableValue<T, S>;

        /** Precursor a value. */
        precursor(): void;
        /**
         * Sets the pristine value and optional reference.
         * @param pValue Specifies the pristine value.
         * @param sReference Specifies an optional value reference.
         * @param sDisplay Specifies the display value.
         * @return Returns the value.
         */
        set(pValue: TSerializeTypes, sReference?: string, sDisplay?: string): T;
        /**
         * Concatenates a value.
         * @param sValue Specifies the value to concatenate.
         * @param pContext Specifies the context of the value.
         * @param sSeparator Specifies a separator to use.
         * @returns Returns the concatenated string.
         */
        concatenate(sValue: string, pContext?: {} | string, sSeparator?: string): string;
        /**
         * Sets the output of an operation as value.
         * @param pValue Specifies the result of the operation.
         * @param pContext Specifies the context of the operation.
         * @returns Returns a reference to the value.
         */
        operation(pValue: TSerializeTypes, pContext: {} | string): this;
        /**
         * Resets the value and optional reference to the prefill/initial value.
         * @param pPrefillValue Specifies the prefill value.
         * @param sPrefillReference Specifies an optional prefill value reference.
         * @param sPrefillDisplay Specifies an optional prefill display value.
         * @return Retrieves the value.
         */
        reset(pPrefillValue?: TSerializeTypes, sPrefillReference?: string, sPrefillDisplay?: string): T;
        /**
         * Sets a default value and optional reference.
         * @param pValue Specifies the pristine value.
         * @param sReference Specifies an optional value reference.
         * @param sDisplay Specifies the display value.
         * @return Retrieves the value.
         */
        default(pValue: TSerializeTypes, sReference?: string, sDisplay?: string): T;
        /** Awaits a value. */
        await(): this;
        /** Cancels an await operation. */
        cancelAwait(): this;
        /** Specifies if the value is sealed. */
        seal(bSealed: boolean): void;
        /** Freezes a value. */
        freeze(): void;
        /** Unfreezes a value. */
        unfreeze(): void;
        /** Locks a value. */
        lock(): void;
        /** Unlocks a value. */
        unlock(): void;
        /** Clears a value. */
        clear(): T;
        /**
         * Imports a value.
         * @param pValue Specifies the pristine value.
         * @param sReference Specifies an optional value reference.
         * @param sDisplay Specifies the display value.
         * @param nTime Specifies the set timestamp.
         * @param bSilent Specifies if the import is silent and should not emit events.
         * @return Retrieves the value.
         */
        import(pValue: TSerializeTypes, sReference?: string, sDisplay?: string, nTime?: number, bSilent?: boolean): T;
        /**
         * Marks the value as confirmed. In this case it is not necessary to
         * explicit set a value to make the value valid.
         * @param shallow Specifies if a shallow confirm needs to be applied.
         * @return Returns a reference to the instance.
         */
        confirm(shallow?: boolean): this;
        /**
         * Marks the value as dirty. An explicit value should be set to mark
         * the value as valid or `confirm()` should be invoked.
         * @return Returns a reference to the instance.
         */
        dirty(): this;
        /**
         * Subscribe to value changes using the given context.
         * @param fnChange Specifies the function that is invoked when the value is changed.
         * @param pContext Specifies the context.
         * @param sMode Sepcifies the mode to use (defaults to `asynchronous`).
         * @return Returns a reference to the instance.
         */
        subscribe(fnChange: (pValue: Value<T, S>) => void, pContext?: THookContext, sMode?: "asynchronous" | "synchronous"): this;
        /**
         * Unsubscribe the given context from the value.
         * @param pContext Specifies the context.
         * @return Returns a reference to the instance.
         */
        unsubscribe(pContext?: THookContext): this;
        /**
         * Listens to value changes.
         * @param fnListener Specifies the event that is invoked when the value is changed.
         * @return Returns a reference to the instance.
         */
        useListener(fnListener: (pValue: Value<T, S>) => void): this;
        /**
         * Specifies a modifier function to use.
         * @param fnModifier Specifies the modifier function.
         * @return Returns a reference to the instance.
         */
        useModifier(
            fnModifier:
                | ((pValue: Value<T, S>) =>
                      | {
                            readonly value: TSerializeTypes;
                            readonly reference?: string;
                            readonly display?: string;
                        }
                      | undefined)
                | undefined
        ): this;
        /**
         * Attaches a context to the value.
         * @param pContext Reference to the context
         * @returns Returns a reference to the instance.
         */
        attachContext(pContext: Context | undefined): this;
        /**
         * Specifies a context function to use.
         * @param fnContext Specifies the context function.
         * @return Returns a reference to the instance.
         */
        useContext(fnContext: ((pValue: Value<T, S>, pContext: Context) => void) | undefined): this;
        /**
         * Mounts a new context.
         * @param pContext Reference to the context.
         * @return Returns a reference to the instance.
         */
        mountContext(pContext: Context): this;
    }
    export class ImmutableValue<T extends TSerializeTypes = TSerializeTypes, S extends Slot<T> = Slot<T>> {
        /**
         * Creates an immutable value instance.
         * @param pValue Reference to the mutable value instance.
         */
        constructor(pValue: Value<T, S>);
        /** Retrieves a unique key for the value within its context (the key is prefixed with an underscore). */
        get key(): string;
        /** Retrieves the context for the value. */
        get context(): "*" | string;
        /** Retrieves a reference to the slot. */
        get slot(): S;
        /** Retrieves the value. */
        get value(): T;
        /**
         * Retrieves the value as a string (this will always return a string with a
         * value regardless of a pristine value was set).
         */
        get string(): string;
        /** Retrieves the optional value reference. */
        get reference(): string | undefined;
        /** Retrieves the optional display value. */
        get display(): string | undefined;
        /** Retrieves the value set timestamp. */
        get time(): number | undefined;
        /** Retrieves if there is a value. */
        get hasValue(): boolean;
        /** Retrieves if the value is modified. */
        get isModified(): boolean;
        /** Retrieves if the value is sealed. */
        get isSealed(): boolean;
        /** Retrieves if the value is locked. */
        get isLocked(): boolean;
        /** Retrieves if the value is frozen. */
        get isFrozen(): boolean;
        /**
         * Subscribe to value changes using the given context.
         * @param fnChange Specifies the event that is invoked when the value is changed.
         * @param pContext Specifies the context.
         * @return Returns a reference to the instance.
         */
        subscribe(fnChange: (pValue: ImmutableValue<T, S>) => void, pContext?: THookContext): this;
        /**
         * Unsubscribe the given context from the value.
         * @param pContext Specifies the context.
         * @return Returns a reference to the instance.
         */
        unsubscribe(pContext?: THookContext): this;
    }
    export interface IValidatorSnapshot {
        /** Contains the transducer. */
        readonly a: string;
        /** Contains if the validator flags. */
        readonly b: number;
    }
    export const enum Opcode {
        /** An item is pushed to the stack. */
        Push = 0,
        /** An item is awaiting the outcome of the branch conditions. */
        Branch = 1,
        /**
         * An item is awaiting further processing after the branch conditions
         * are processed.
         */
        BranchWait = 2,
        /** An item state is entered. */
        Enter = 3,
        /** The enter conditions for an item are processed. */
        EnterCondition = 4,
        /** Awaiting the enter conditions. */
        EnterConditionWait = 5,
        /** Waiting for state feedback. */
        Wait = 6,
        /** The leave conditions for an item are processed. */
        LeaveCondition = 7,
        /** Awaiting the leave conditions. */
        LeaveConditionWait = 8,
        /** An item is awaiting pursuing actions. */
        Pursue = 9,
        /** An item is popped. */
        Pop = 10,
    }
    export interface IStackSnapshot {
        /** Contains the stack. */
        readonly a: string;
        /** Contains the counter. */
        readonly b?: number;
        /** Contains the opcode. */
        readonly c?: Opcode;
        /** Contains the flags. */
        readonly d?: number;
        /** Contains the ancestor. */
        readonly e?: string;
        /** Contains the state. */
        readonly f?: string;
        /** Contains the branch. */
        readonly g?: string;
        /** Contains the active branch. */
        readonly h?: string;
        /** Contains the condition. */
        readonly i?: string;
        /** Contains the return state. */
        readonly j?: string;
        /** Contains the transducer snapshot. */
        readonly k?: IValidatorSnapshot[];
        /** Contains the branch index. */
        readonly l?: number;
    }
    export interface IMomentSnapshot {
        /** Contains the stack snapshot. */
        readonly a: IStackSnapshot[];
        /** Contains the stack pointer. */
        readonly b?: string;
    }
    export interface IMoment {
        /** Checksum of the moment. */
        readonly checksum: string;
        /** Index of the moment */
        readonly index: number;
        /** Snapshot of the moment. */
        readonly snapshot: IMomentSnapshot;
        /** Reference to the state. */
        readonly state: State;
        /** Reference to the validated transducers. */
        readonly transducers: Transducer[];
        /** Context for the data. */
        readonly context: Context;
        /** Specifies the tense of the moment. */
        readonly tense: "past" | "present" | "future";
        /** Restores the moment. */
        readonly restore: () => void;
    }
    export interface IState extends IOntologyProperties {
        readonly type?: "nest" | "branch";
    }
    class Main extends State {
        /**
         * Constructs a new main state.
         * @param pStates Reference to the state dispatcher.
         */
        constructor(pStates: States);
        /** Enter condition for the main state. */
        onEnterCondition(): boolean;
        /** Main state is entered. */
        onEnter(): void;
        /** Leave condition for the main state. */
        onLeaveCondition(): boolean;
        /** Main state is validated. */
        onValidate(): boolean;
    }
    export enum Errors {
        /** No errors were detected. */
        None = 0,
        /** The state data in the ontology is invalid. */
        OntologyInvalidState = 1,
        /** The transducer data in the ontology is invalid. */
        OntologyInvalidTransducer = 2,
        /** The branch data in the ontology is invalid. */
        OntologyInvalidBranch = 4,
        /** The condition data in the ontology is invalid. */
        OntologyInvalidCondition = 8,
        /** The jump reference in the ontology is invalid. */
        OntologyInvalidJump = 16,
        /** The resume data is invalid. */
        ResumeInvalidHash = 32,
        /** One of more resume data slots are invalid. */
        ResumeInvalidData = 64,
        /** The resume stack is invalid. */
        ResumeInvalidStack = 128,
    }
    export type TStateEvents = "OnEnter" | "OnSkip" | "OnLeave" | "OnCancel" | "OnValidated" | "OnEvaluate";
    export interface IStateEvent<T extends THooks> extends IHookPayload<T> {
        readonly state: State;
        readonly context: Context;
    }
    export interface IStateEnterEvent extends IStateEvent<"OnEnter"> {}
    export interface IStateSkipEvent extends IStateEvent<"OnSkip"> {}
    export interface IStateLeaveEvent extends IStateEvent<"OnLeave"> {}
    export interface IStateCancelEvent extends IStateEvent<"OnCancel"> {}
    export interface IStateEvaluateEvent extends IStateEvent<"OnEvaluate"> {
        readonly evaluating: boolean;
    }
    export interface IStateValidatedEvent extends IStateEvent<"OnValidated"> {
        readonly result: "fail" | "pass";
        readonly type: "initial" | "revalidate";
    }
    export type TState<T extends State = State, Ontology extends IState = TAny> = IFactory<States, T, Ontology, TStateEvents>;
    export interface ITransducer extends IOntologyProperties {
        /** Contains the slots for the transducer. */
        readonly slots?: ISlot[];
    }
    export type TTransducerEvents = "OnEnter" | "OnSkip" | "OnLeave" | "OnCancel" | "OnValidated";
    export interface ITransducerEvent<T extends THooks> extends IHookPayload<T> {
        readonly transducer: Transducer;
        readonly context: Context;
    }
    export interface ITransducerEnterEvent extends ITransducerEvent<"OnEnter"> {}
    export interface ITransducerSkipEvent extends ITransducerEvent<"OnSkip"> {}
    export interface ITransducerLeaveEvent extends ITransducerEvent<"OnLeave"> {}
    export interface ITransducerCancelEvent extends ITransducerEvent<"OnCancel"> {}
    export interface ITransducerValidatedEvent extends ITransducerEvent<"OnValidated"> {
        readonly result: "fail" | "pass";
        readonly type: "initial" | "revalidate";
    }
    export type TTransducer<T extends Transducer = Transducer, Ontology extends ITransducer = TAny> = IFactory<
        Transducers,
        T,
        Ontology,
        TTransducerEvents
    >;
    export type TBranchEvents = "OnReady" | "OnEnter" | "OnSkip" | "OnLeave" | "OnCancel";
    export interface IBranchEvent<T extends THooks> extends IHookPayload<T> {
        readonly branch: Branch;
        readonly context: Context;
    }
    export interface IBranchReadyEvent extends IBranchEvent<"OnReady"> {}
    export interface IBranchEnterEvent extends IBranchEvent<"OnEnter"> {}
    export interface IBranchSkipEvent extends IBranchEvent<"OnSkip"> {}
    export interface IBranchLeaveEvent extends IBranchEvent<"OnLeave"> {}
    export interface IBranchCancelEvent extends IBranchEvent<"OnCancel"> {}
    export type TBranch<T extends Branch = Branch, Ontology extends IBranch = TAny> = IFactory<Branches, T, Ontology, TBranchEvents>;
    export type TCondition<T extends Condition = Condition, Ontology extends ICondition = TAny> = IFactory<Conditions, T, Ontology>;
    export interface IConstructors<S extends State, T extends Transducer, B extends Branch, C extends Condition> {
        readonly state: TState<S>;
        readonly transducer: TTransducer<T>;
        readonly branch: TBranch<B>;
        readonly condition: TCondition<C>;
    }
    export interface IValueSnapshot {
        /** Contains the context. */
        readonly a: string;
        /** Contains the value. */
        readonly b?: TSerializeTypes;
        /** Contains the reference. */
        readonly c?: string;
        /** Specifies value flags. */
        readonly d?: number;
        /** Contains the UTC set time of the value. */
        readonly e?: number;
        /** Contains the display value. */
        readonly f?: string;
    }
    export interface IDataSnapshot {
        /** Contains the store. */
        readonly a: string;
        /** Contains the values. */
        readonly b?: IValueSnapshot[];
    }
    export interface IInstanceSnapshot {
        /** Contains the ontology hash. */
        readonly a: string;
        /** Contains the moment snapshots. */
        readonly b: IMomentSnapshot[];
        /** Contains the data snapshots. */
        readonly c?: IDataSnapshot[];
        /** Contains the index of the active snapshot. */
        readonly d?: number;
        /** Contains if the instance allows concurrency. */
        readonly e?: true;
    }
    export interface IMetrics {
        /** Number of states. */
        states: number;
        /** Number of transducers. */
        transducers: number;
        /** Number of branches. */
        branches: number;
        /** Number of conditions. */
        conditions: number;
        /** Number of slots. */
        slots: number;
    }
    export type TOntologyEvents =
        | "OnLoad"
        | "OnUnload"
        | "OnStart"
        | "OnEnd"
        | "OnPause"
        | "OnResume"
        | "OnStop"
        | "OnFinish"
        | "OnInstanceCreate"
        | "OnInstanceStart"
        | "OnInstanceData"
        | "OnInstanceProcessing"
        | "OnInstanceEnd"
        | "OnInstancePause"
        | "OnInstanceStop"
        | "OnInstanceFinish";
    export interface IOntologyEvent<T extends THooks> extends IHookPayload<T> {
        readonly ontology: TOntology;
    }
    export interface IOntologyLoadEvent extends IOntologyEvent<"OnLoad"> {}
    export interface IOntologyUnloadEvent extends IOntologyEvent<"OnUnload"> {}
    export interface IOntologyStartEvent extends IOntologyEvent<"OnStart"> {}
    export interface IOntologyPauseEvent extends IOntologyEvent<"OnPause"> {}
    export interface IOntologyStopEvent extends IOntologyEvent<"OnStop"> {}
    export interface IOntologyFinishEvent extends IOntologyEvent<"OnFinish"> {}
    export interface IOntologyResumeEvent<T> extends IOntologyEvent<"OnResume"> {
        readonly data?: T;
    }
    export interface IOntologyEndEvent extends IOntologyEvent<"OnEnd"> {
        readonly type: "finished" | "stopped" | "paused";
    }
    export interface IOntologyInstanceEvent<T extends THooks> extends IOntologyEvent<T> {
        readonly instance: Instance;
    }
    export interface IOntologyInstanceCreateEvent extends IOntologyInstanceEvent<"OnInstanceCreate"> {}
    export interface IOntologyInstanceStartEvent extends IOntologyInstanceEvent<"OnInstanceStart"> {}
    export interface IOntologyInstancePauseEvent extends IOntologyInstanceEvent<"OnInstancePause"> {}
    export interface IOntologyInstanceStopEvent extends IOntologyInstanceEvent<"OnInstanceStop"> {}
    export interface IOntologyInstanceProcessingEvent extends IOntologyInstanceEvent<"OnInstanceProcessing"> {
        readonly processing: boolean;
    }
    export interface IOntologyInstanceEndEvent extends IOntologyInstanceEvent<"OnInstanceEnd"> {
        readonly type: "finished" | "stopped" | "paused";
    }
    export interface ISnapshot<T = unknown> {
        /** Contains the instance data. */
        readonly a: IInstanceSnapshot[];
        /** Contains custom data to store with the snapshot. */
        readonly b?: T;
    }
    export type TThreading = "single" | "multi";
    export type TValuesEvents = "OnValueChange" | "OnSealChange";
    export interface IChangeEvent<T extends TSerializeTypes, S extends Slot<T>, H extends THooks> extends IHookPayload<H> {
        /** Reference to the transducer to whom the value belongs. */
        readonly transducer: Transducer;
        /** Reference to the slot. */
        readonly slot: S;
        /** Reference to the data instance that holds the all values. */
        readonly data: Data;
        /** Identifier of the value. */
        readonly id: number;
        /** Contains the key of the context. */
        readonly context: string;
        /** Reference to the value. */
        readonly value: ImmutableValue<T, S>;
    }
    export interface IValueChangeEvent<T extends TSerializeTypes = TSerializeTypes, S extends Slot<T> = Slot<T>>
        extends IChangeEvent<T, S, "OnValueChange"> {}
    export interface ISealChangeEvent<T extends TSerializeTypes = TSerializeTypes, S extends Slot<T> = Slot<T>>
        extends IChangeEvent<T, S, "OnSealChange"> {}
    export type IDataChangeEvent = Omit<IValueChangeEvent, "hook" | "context"> & {
        /** Contains the key of the context. */
        readonly key: string;
        /** Contains if the data is sealed. */
        readonly isSealed: boolean;
        /** Contains a reference to the context (when available). */
        readonly context?: Context;
    };
    export type TOntology = Ontology<State, Transducer, Branch, Condition>;
    export abstract class Ontology<
        S extends State,
        T extends Transducer,
        B extends Branch,
        C extends Condition,
        O extends {} = {},
        H extends THooks = void,
    > extends Matrix<Instance, TOntologyEvents | H> {
        /**
         * Constructs a new ontology.
         * @param pState Reference to the state constructor.
         * @param pTransducer Reference to the transducer constructor.
         * @param pBranch Reference to the branch constructor.
         * @param pCondition Reference to the condition constructor.
         * @param pOntology Reference to the ontology data.
         * @param fnFingerprint Specifies a fingerprint generator.
         * @param fnStencil Specifies a stencil validator.
         * @param bAutoPushForward Specifies if auto push-forward should be used. when
         * enabled, steps forward are made automatically as long as there are no
         * validation obstructions (disabled by default).
         * @param bIgnoreValidation Specifies if a state that fails validation won't
         * block the state machine so it can continue with the next state. If this is
         * set to `true` the state machine will always try to progress till the end,
         * regardless of the validation state of the individual states. The state
         * machine is not able to complete when the validation of one of the states
         * has failed.
         * @param bCalculateFingerprint Specifies if the fingerprint should be
         * calculated (enabled by default). Disabling this calculation can improve
         * performance in preview/test mode.
         * @param sPreview Specifies if the preview mode is enabled. In this mode all
         * conditions and validations will pass without evaluating them. This allows
         * an application to iterate through all possible states and transducers. Can
         * be one of the following values:
         * - `disabled`: The preview mode is disabled;
         * - `compact`: Only show unique branches in the preview;
         * - `enabled`: Show every possible branch.
         * @param pL10 Reference to a l10n namespace to use.
         * @param bVerbose Enables or disables verbose logging (disabled by default).
         * @return Returns a reference to the instance.
         */
        constructor(
            pState: TState<S>,
            pTransducer: TTransducer<T>,
            pBranch: TBranch<B>,
            pCondition: TCondition<C>,
            pOntology?: string | O,
            fnFingerprint?: (pReference: S | T | B | C | Slot) => string,
            fnStencil?: (pReference: T) => boolean,
            bAutoPushForward?: boolean,
            bIgnoreValidation?: boolean,
            bCalculateFingerprint?: boolean,
            sPreview?: "disabled" | "compact" | "enabled",
            pL10?: Namespace,
            bVerbose?: boolean
        );

        /** Retrieves the constructors. */
        get constructors(): IConstructors<S, T, B, C>;
        /** Retrieves the ontology data. */
        get ontology(): Readonly<O> | undefined;
        /** Retrieves the unique ontology fingerprint. */
        get fingerprint(): string;
        /** Reference to the l10n namespace. */
        get l10n(): Namespace;
        /** Retrieves a reference to the state dispatcher. */
        get states(): States;
        /** Retrieves a reference to the main state. */
        get main(): Main | undefined;
        /** Retrieves if the ontology is loaded successfully. */
        get isLoaded(): boolean;
        /** Retrieves if the VFSM is running. */
        get isRunning(): boolean;
        /** Retrieves if the VFSM is stopped. */
        get isStopped(): boolean;
        /** Retrieves if the VFSM is about to finish */
        get isFinishing(): boolean;
        /** Retrieves if the VFSM has finished (without pausing or stopping it). */
        get isFinished(): boolean;
        /** Retrieves if the VFSM is pausing. */
        get isPausing(): boolean;
        /** Retrieves if the VFSM is paused. */
        get isPaused(): boolean;
        /** Retrieves if the preview mode is enabled. */
        get isPreview(): boolean;
        /** Retrieves if verbose logging is enabled. */
        get isVerbose(): boolean;
        /** Enables or disables verbose logging. */
        set isVerbose(bVerbose: boolean);
        /** Retrieves if automatic push-forward is enabled. */
        get autoPushForward(): boolean;
        /** Enables or disables automatic push-forward. */
        set autoPushForward(bAutoPushForward: boolean);
        /** Retrieves if validation is ignored or not. */
        get ignoreValidation(): boolean;
        /** Specifies if the validation needs to be ignored or not. */
        set ignoreValidation(bIgnoreValidation: boolean);
        /** Retrieves the ontology metrics. */
        get metrics(): Readonly<IMetrics>;
        /** Retrieves the log message list. */
        get log(): string[];
        /** Retrieves the logger function. */
        get logger(): (sMessage: string) => void;
        /** Sets the log function. */
        set logger(fnLogger: (sMessage: string) => void);

        /**
         * Invoked when an instance is created.
         * @param pInstance Reference to the instance.
         * @event
         */
        protected onInstanceCreate(pInstance: Instance): void;
        /**
         * Invoked when an instance is started.
         * @param pInstance Reference to the instance.
         * @event
         */
        protected onInstanceStart(pInstance: Instance): void;
        /**
         * Invoked when the collected data of an instance is changed.
         * @param pInstance Reference to the instance.
         * @param pDataChangeEvent Reference to a data change event.
         * @event
         */
        protected onInstanceData(pInstance: Instance, pDataChangeEvent: IDataChangeEvent): void;
        /**
         * Invoked when an instance is processing.
         * @param pInstance Reference to the instance.
         * @param bProcessing Specifies if the instance is processing.
         * @event
         */
        protected onInstanceProcessing(pInstance: Instance, bProcessing: boolean): void;
        /**
         * Invoked when an instance wants to check if it can step forward.
         * @param pInstance Reference to the instance.
         * @param pState Reference to the current state.
         * @return Returns `true` if step forward is allowed.
         * @event
         */
        protected onInstanceStepForward(pInstance: Instance, pState: State): boolean;
        /**
         * Invoked when the instance is updated.
         * @param pInstance Reference to the instance.
         * @event
         */
        protected onInstanceUpdate(pInstance: Instance): void;
        /**
         * Invoked when an instance ends. This event is always invoked
         * when an instance is finished, stopped or paused.
         * @param pInstance Reference to the instance.
         * @param sType Specifies why the instance has ended. Can be one of the
         * following values:
         * - `finished`: The instance was finished;
         * - `stopped`: The instance was forced to stop;
         * - `paused`: The instance was paused.
         * @event
         */
        protected onInstanceEnd(pInstance: Instance, sType: "finished" | "stopped" | "paused"): void;
        /**
         * Invoked when an instance is about to finish.
         * @param pInstance Reference to the instance.
         * @param fnFinish A callback function that can be used to control the finish process when you override this event and return `false`.
         * @return Return `true` if the instance finish is allowed or `false` if the instance finish should wait till the callback function is invoked.
         * @event
         */
        protected onInstanceFinishing(pInstance: Instance, fnFinish: (bFinish: boolean, sReference?: string) => void): boolean;
        /**
         * Invoked when an instance has finished.
         * @param pInstance Reference to the instance.
         * @event
         */
        protected onInstanceFinish(pInstance: Instance): void;
        /**
         * Invoked when an instance is paused.
         * @param pInstance Reference to the instance.
         * @event
         */
        protected onInstancePause(pInstance: Instance): void;
        /**
         * Invoked when an instance is stopped.
         * @param pInstance Reference to the instance.
         * @event
         */
        protected onInstanceStop(pInstance: Instance): void;
        /**
         * Spawns a new instance. Throws an error if no ontology is loaded.
         * @param sThreading Specifies if a single or multi threaded instance should be spawned.
         * @param pSnapshotOrCallback Specifies the optional instance snapshot.
         * @param fnInitialize Specifies an optional initializer function that can be used to prefill the instance with data.
         * @return Returns a reference to the instance.
         */
        protected spawn(sThreading?: TThreading, pSnapshot?: IInstanceSnapshot, fnInitialize?: (pInstance: Instance) => void): Instance;
        /**
         * Calculates the stencil hash for the specified type.
         * @param sType Specifies the stencil type (if omitted the exportables stencil is returned).
         * @returns Returns the stencil hash.
         */
        stencil(sType?: "exportables" | "actionables"): string;
        /**
         * Loads an ontology.
         * @param pOntology Specifies the ontology data.
         * @return Returns `Errors.None` if the ontology is loaded.
         */
        load(pOntology: O | string): Errors;
        /** Unloads the ontology. */
        unload(): void;
        /**
         * Starts a new instance. Throws an error if no ontology is loaded.
         * @param pSnapshot Specifies the optional instance snapshot.
         * @param fnInitialize Specifies an optional initializer function that can be used to prefill the instance with data.
         * @return Returns a reference to the instance.
         */
        start(pSnapshot?: IInstanceSnapshot, fnInitialize?: (pInstance: Instance) => void): Instance;
        /**
         * Stops all running instances.
         * @return Returns `true` if there was an actual instance running.
         */
        stop(): boolean;
        /**
         * Takes a snapshot of the VSFM ontology.
         * @param pCustomData Specifies custom data to store in the snapshot.
         * @return Returns the snapshot which is necessary to resume the VFSM
         * or `undefined` if no instance was active.
         */
        snapshot<Data>(pCustomData?: Data): ISnapshot<Data> | undefined;
        /**
         * Pauses the VFSM ontology.
         * @param pCustomData Specifies custom data to store in the snapshot.
         * @return Returns the snapshot which is necessary to resume the VFSM
         * or `undefined` if no instance was running.
         */
        pause<Data>(pCustomData?: Data): ISnapshot<Data> | undefined;
        /**
         * Pauses the VFSM ontology.
         * @param pCustomData Specifies custom data to store in the snapshot.
         * @param fnPausing Specifies a function that is invoked when the pause is
         * initiated. This function receives the pause snapshot together with a
         * callback function that needs to be invoked to indicate if the pause
         * should be executed or dismissed.
         * @return Returns a promise with the pause snapshot.
         */
        pause<Data>(
            pCustomData: Data | undefined,
            fnPausing: (pSnapshot: ISnapshot<Data>, fnDone: (bPause: boolean) => void) => void
        ): Promise<ISnapshot<Data>>;
        /**
         * Resumes the VFSM ontology. This will resume all instances that are
         * present in the snapshot data.
         * @param pSnapshot Specifies the snapshot data.
         * @return Returns `true` if the resume is successful and the VFSM is
         * running.
         */
        resume<Data>(pSnapshot: ISnapshot<Data>): boolean;
        /**
         * Enables or disables the preview mode. Any running instances are updated.
         * @param sMode Specifies the preview mode. Can be one of the following values:
         * - `disabled`: The preview mode is disabled;
         * - `compact`: Only show unique branches in the preview;
         * - `enabled`: Show every possible branch.
         * @param bRestart Specifies if the instances should be restarted.
         */
        previewMode(sMode?: "disabled" | "compact" | "enabled", bRestart?: boolean): "disabled" | "compact" | "enabled";
        /**
         * Iterates through each item in the ontology.
         * @param fnItem Callback which is invoked for each item.
         * @param sType Specifies the type of items.
         * @return Returns `true` if the iteration was interrupted.
         */
        forEach<Types extends State | Transducer | Branch | Condition>(
            fnItem: (pItem: Types) => boolean | void,
            sType?: "states" | "transducers" | "branches" | "conditions" | "all",
            pExclude?: State | Transducer | Branch | Condition
        ): boolean;
        /** Destroys the ontology. */
        destroy(): void;
    }
    export class OntologyProcessor<
        S extends State,
        T extends Transducer,
        B extends Branch,
        C extends Condition,
        O extends {} = {},
    > extends Ontology<S, T, B, C, O> {
        constructor(
            pState: TState<S>,
            pTransducer: TTransducer<T>,
            pBranch: TBranch<B>,
            pCondition: TCondition<C>,
            pOntology?: string | O,
            fnFingerprint?: (pReference: S | T | B | C | Slot) => string,
            fnStencil?: (pReference: T) => boolean
        );
    }
    export class States extends StrictMatrix<States, State, void, IState> {
        /**
         * Constructs a new state dispatcher.
         * @param pOntology Reference to the ontology.
         */
        constructor(pOntology: TOntology);
        /** Retrieves a reference to the ontology. */
        get ontology(): TOntology;
        /**
         * Creates a new main state.
         * @return Returns the main state.
         */
        main(): Main;
        /**
         * Creates a state.
         * @param pState Reference to the state data.
         * @param pBranch Reference to the parent branch.
         * @param pAncestor Reference to the ancestor state.
         * @param nEnumerator Specifies the enumerator of the state.
         * @return Returns a reference to the state.
         */
        create<T extends State>(pState: IState, pBranch: Branch, pAncestor: State, nEnumerator: number): T;
    }
    export interface IInstanceOrchestrator {
        /** Contains the unique ontology fingerprint. */
        readonly fingerprint: string;
        /** Reference to the l10n namespace. */
        readonly l10n: Namespace;
        /** Reference to the ontology states. */
        readonly states: States;
        /** Specifies if the automatic push-forward is enabled. */
        readonly autoPushForward: boolean;
        /** Specifies if the validation needs to be ignored. */
        readonly ignoreValidation: boolean;
        /** Contains the preview mode. */
        readonly preview: "disabled" | "compact" | "enabled";
        /** Chain. */
        readonly chain: IChainLookup;
        /** Contains the events. */
        readonly events: {
            /** Invoked when an instance is created. */
            onInstanceCreate: (pInstance: Instance) => void;
            /** Invoked when an instance is started. */
            onInstanceStart: (pInstance: Instance) => void;
            /** Invoked when the data of an instance has changed. */
            onInstanceData: (pInstance: Instance, pDataChangeEvent: IDataChangeEvent) => void;
            /** Invoked when the instance is processing. */
            onInstanceProcessing: (pInstance: Instance, bProcessing: boolean) => void;
            /** Invoked when the instance wants to step forward. */
            onInstanceStepForward: (pInstance: Instance, pState: State) => boolean;
            /** Invoked when the instance is updated. */
            onInstanceUpdate: (pInstance: Instance) => void;
            /** Invoked when an instance is about to end. */
            onInstanceFinishing: (pInstance: Instance, fnFinish: (bFinish: boolean, sReference?: string) => void) => boolean;
            /** Invoked when an instance has finished. */
            onInstanceFinish: (pInstance: Instance) => void;
            /** Invoked when an instance is paused. */
            onInstancePause: (pInstance: Instance) => void;
            /** Invoked when an instance is stopped. */
            onInstanceStop: (pInstance: Instance) => void;
            /** Invoked when an instance ends. */
            onInstanceEnd: (pInstance: Instance, sType: "finished" | "stopped" | "paused") => void;
        };
        /** Spawns a new instance. */
        readonly spawn: (pInstance: Instance, nIndex: number) => Instance;
        /** Retrieves a dependency tree of transducers that are affected by the slot. */
        readonly dependencies: (pSlot: Slot) => {
            readonly [transducer: string]: boolean | undefined;
        };
        /** Iterates through all possible transducers and their context. */
        readonly iterate: (fnTransducer: (pTransducer: Transducer, pContext: Condition[], sContext: string) => void) => void;
        /** Contains the exportables stencil. */
        readonly stencil: (sType: "exportables" | "actionables") => string;
        /** Retrieves if the transducer with the specified id has changed. */
        readonly hasChanged: (sId: string, bReset: boolean) => boolean;
        /** Logger. */
        readonly logger?: (sMessage: string) => void;
    }
    export interface IContent {
        readonly value: string;
        readonly type: "string" | "text" | "markdown";
        readonly separator: string;
    }
    export interface IDataValue {
        /** Contains the value. */
        readonly value: TSerializeTypes;
        /** Contains the reference. */
        readonly reference: string | undefined;
        /** Contains the display value. */
        readonly display: string | undefined;
        /** Contains the UTC set time of the value. */
        readonly time: number;
    }
    export interface IDataValues {
        readonly [context: string]: IDataValue | undefined;
    }
    export interface IDataImport {
        readonly [context: string]: Partial<IDataValue> | undefined;
    }
    export interface IStackOrchestrator {
        /** Reference to the instance. */
        readonly instance: Instance;
        /** Contains if the preview mode is enabled. */
        readonly preview: boolean;
        /** Contains if the compact preview mode is enabled. */
        readonly previewCompact: boolean;
        /** Spawns a new instance. */
        readonly spawn: (pState: State) => void;
        /** Feeds the state validation back to the orchestrator. */
        readonly validate: (pState: State, pContext: Context, bPassed: boolean) => boolean;
        /** Sets the validation state of the instance. */
        readonly validated: (pState: State) => void;
        /** Invoked when the stack makes a cycle. */
        readonly cycle: (bCycle: boolean) => void;
        /** Invoked when a stack is canceled. */
        readonly cancel: () => void;
        /** Snapshots. */
        readonly snapshot: {
            /** Pushes the current moment snapshot. */
            readonly push: () => void;
            /** Makes a snapshot of the current stack. */
            readonly make: () => void;
        };
        /** Pointer. */
        readonly pointer: {
            /** Retrieves the stack pointer. */
            readonly get: () => Stack | undefined;
            /** Assures a stack is bind to the pointer. */
            readonly assure: (pStack: Stack) => Stack | undefined;
            /** Releases the current pointer. */
            readonly release: () => void;
        };
        /** Chain. */
        readonly chain: IChainLookup;
        /** Logger. */
        readonly logger: (
            pStack: Stack,
            pAncestor: Stack | undefined,
            pState: State | undefined,
            pBranch: Branch | undefined,
            pCondition: Condition | undefined,
            pReturn: State | true | undefined
        ) => void;
    }
    class Validator extends Item {
        /**
         * Constructs a new transducer validator.
         * @param pTransducer Reference to the transducer.
         * @param pContext Context of the validator.
         * @param bEnabled Specifies if the transducer is enabled.
         * @param bPass Specifies if the validation is passed.
         */
        constructor(pTransducer: Transducer, pContext: Context, bEnabled: boolean, bPass?: boolean);
        /** Retrieves a reference to the transducer. */
        get transducer(): Transducer;
        /** Specifies if the transducer is enabled. */
        get isEnabled(): boolean;
        /** Retrieves if the transducer validation is passed. */
        get isPassed(): boolean;
        /** Retrieves if the transducer validation failed. */
        get isFailed(): boolean;
        /**
         * Validates the transducer.
         * @param pState Reference to the state.
         * @param sType Specifies the type of validation.
         * @param bPreview Specifies if the preview mode is enabled.
         * @param fnAssert Specifies the stack assert function.
         * @param fnDone Specifies the callback function that is invoked when the
         * validation is completed.
         * @return Returns `true` if the transducer was validated.
         */
        validate(
            pState: State | undefined,
            sType: "initial" | "revalidate",
            bPreview: boolean,
            fnAssert: (pPromise: ICallbackPromise<boolean>) => boolean,
            fnDone: () => void
        ): boolean;
        /** Invalidates the validation state. */
        invalidate(): void;
        /** Cancels a pending validation. */
        cancel(): void;
        /**
         * Snapshots the stack transducer validator.
         * @return Returns the stack transducer snapshot.
         */
        snapshot(): IValidatorSnapshot | undefined;
    }
    class Validators extends Matrix<Validator> {
        /** Retrieves the validated transducers. */
        get transducers(): Transducer[];
        /** Retrieves if one or more validators are enabled. */
        get isEnabled(): boolean;
        /** Retrieves if all validators passed the validation. */
        get isPassed(): boolean;
        /**
         * Creates a new transducer validator.
         * @param pTransducer Reference to the transducer.
         * @param pContext Context for the validator.
         * @param bEnabled Specifies if the transducer is enabled.
         */
        create(pTransducer: Transducer, pContext: Context, bEnabled: boolean): Validator;
        /**
         * Resumes a validator.
         * @param pTransducer Reference to the transducer.
         * @param pContext Context for the validator.
         * @param pSnapshot Reference to the snapshot data.
         */
        resume(pTransducer: Transducer, pContext: Context, pSnapshot: IValidatorSnapshot): Validator;
        /**
         * Retrieves the validator for the specified transducer.
         * @param pTransducer Specifies the transducer.
         * @return Returns the validator instance or `undefined`.
         */
        forTransducer(pTransducer: Transducer): Validator | undefined;
        /** Clears all validators. */
        clear(): void;
    }
    class Stack extends Item {
        /**
         * Creates a new stack.
         * @param pStack Reference to the stack matrix.
         * @param pOrchestrator Reference to the stack orchestrator.
         * @param pAncestor Reference to the stack ancestor.
         * @param pState Reference to a state.
         * @param pBranch Reference to a branch.
         * @param pCondition Reference to a condition.
         * @param pBranched Contains a reference to the active branch.
         * @param pValidators Reference to the transducer validators.
         * @param nOpcode Specifies the opcode.
         * @param nCounter Specifies the number of loops.
         * @param nSteps Specifies the number of steps.
         * @param bReturn Specifies if there is a return value.
         * @param bReturnOverride Specifies if a return override value is present.
         * @param pReturn Specifies the return state.
         * @param bBranching Specifies if the stack is branching.
         * @param nBranch Contains the index number of the branch.
         */
        static create(
            pStack: Matrix<Stack>,
            pOrchestrator: IStackOrchestrator,
            pState: State | undefined,
            pAncestor?: Stack | undefined,
            pBranch?: Branch | undefined,
            pCondition?: Condition | undefined,
            pBranched?: Branch | undefined,
            pValidators?: Validators | undefined,
            nOpcode?: Opcode,
            nCounter?: number,
            bReturn?: boolean,
            bReturnOverride?: boolean,
            pReturn?: State | undefined,
            bBranching?: boolean,
            nBranch?: number | undefined
        ): Stack;

        /** Retrieves the identifier. */
        get id(): string;
        /** Retrieves the instance of the stack. */
        get instance(): Instance;
        /** Contains a reference to the ancestor stack. */
        get ancestor(): Stack | undefined;
        /** Retrieves the stack trace. */
        get trace(): string;
        /** Reference to the state for the stack. */
        get state(): State | undefined;
        /** Retrieves the validated transducers for the stack. */
        get transducers(): Transducer[];
        /** Reference to the branch for the stack. */
        get branch(): Branch | undefined;
        /** Retrieves the branch index number. */
        get branchIndex(): number;
        /** Reference to the condition for the stack. */
        get condition(): Condition | undefined;
        /** Retrieves the mutable stack context. */
        get mutableContext(): Condition | undefined;
        /** Retrieves the immutable stack context. */
        get immutableContext(): Condition | undefined;
        /** Retrieves the stack checksum. */
        get checksum(): string;
        /** Retrieves if the stack is branching. */
        get isBranch(): boolean;
        /** Specifies if the stack is scheduled for the pursue step. */
        get isScheduled(): boolean;
        /** Retrieves if the stack branch is at the finish. */
        get isAtFinish(): boolean;
        /** Retrieves if the stack is evaluating. */
        get isEvaluating(): boolean;

        /**
         * Performs a step.
         * @param nOpcode Specifies the opcode to be executed.
         */
        step(nOpcode?: Opcode): void;
        /**
         * Invalidates a transducer.
         * @param pTransducer Specifies the transducer to invalidate.
         */
        invalidate(pTransducer: Transducer): void;
        /**
         * Retrieves the validation state of the supplied transducer.
         * @param pTransducer Specifies the transducer.
         * @return Returns the validation state.
         */
        validationOf(pTransducer: Transducer): "unknown" | "pass" | "fail";
        /** Cancels the stack. */
        cancel(): void;
        /** Destroys the stack. */
        destroy(): void;
        /**
         * Snapshots the stack.
         * @return Returns the stack snapshot.
         */
        snapshot(): IStackSnapshot;
    }
    export class Values<T extends TSerializeTypes = TSerializeTypes, S extends Slot<T> = Slot<T>> extends Item<TValuesEvents> {
        /**
         * Constructs a new values store.
         * @param pTransducer Reference to the transducer.
         * @param pInstance Reference to the instance.
         * @param pOrchestrator Specifies the instance orchestrator.
         * @param pSlot Reference to the slot.
         */
        constructor(
            pTransducer: Transducer,
            pSlot: S,
            pInstance: Instance,
            pOrchestrator: IInstanceOrchestrator,
            fnUpdate: (pEvent: IDataChangeEvent) => void
        );
        /** Retrieves a reference to the data instance. */
        get data(): Data;
        /** Retrieves a reference to the transducer. */
        get transducer(): Transducer;
        /** Retrieves a reference to the slot. */
        get slot(): S;
        /** Retrieves the values. */
        get values(): IDataValues;
        /** Retrieves if there are sealed values collected. */
        get hasSealedValues(): boolean;

        /**
         * Retrieves the most relevant value for the supplied stack.
         * @param pStack Reference to the stack to use as a context.
         * @param bContextual Specifies if the value is contextual (local).
         * @param pContext Reference to the context instance.
         * @return Returns a mutable value.
         */
        mutableValue(pStack: Stack | undefined, bContextual: boolean, pContext: Context): Value<T, S>;
        /**
         * Retrieves the most relevant value for the supplied stack.
         * @param pStack Reference to the stack to use as a context.
         * @return Returns an immutable value.
         */
        immutableValue(pStack: Stack | undefined): ImmutableValue<T, S> | undefined;
        /**
         * Retrieves the most relevant values for the supplied stack.
         * @param pStack Reference to the stack to use as a context.
         * @return Returns an array of immutable values.
         */
        immutableValues(pStack: Stack | undefined): ImmutableValue<T, S>[];
        /**
         * Retrieves if the value of the specified context was modified.
         * @param sContext Specifies the context.
         * @return Returns `true` if the value was modified.
         */
        isModified(sContext: string): boolean;
        /**
         * Snapshots the store.
         * @return Returns the store snapshot.
         */
        snapshot(): IDataSnapshot | undefined;
        /**
         * Restores the values.
         * @param pSnapshot Specifies the snapshot to restore.
         */
        restore(pSnapshot: IDataSnapshot): void;
        /** Freeze the data. */
        freeze(): void;
        /** Unfreeze the data. */
        unfreeze(): void;
        /**
         * Imports a single value.
         * @param sContext Specifies the context.
         * @param pData Specifies the data to import.
         */
        importValue(sContext: string, pData: Partial<IDataValue>): void;
        /**
         * Import a values object.
         * @param pValues Specifies the values to import.
         */
        import(pValues: IDataImport): void;
        /** Retrieves if there is any value set. */
        hasValue(pStack: Stack | undefined): boolean;
        /** Retrieves the value of the value set. */
        getValue(pStack: Stack | undefined): number | boolean | undefined;
        /** Retrieves all string values. */
        getString(
            pStack: Stack | undefined,
            pContext: Context,
            bPipe: boolean,
            fnToString?: (pValue: ImmutableValue<T, S>, pContext: Context) => string | undefined
        ): string[];
        /** Retrieves the concatenated content for all values. */
        getContent(
            pStack: Stack | undefined,
            pContext: Context,
            bPipe: boolean,
            sSeparator: string,
            fnToString?: (pValue: ImmutableValue<T, S>, pContext: Context) => string | undefined
        ): IContent[];
        /** Retrieves a list of values refs */
        getRefs(pStack: Stack | undefined, bPipe: boolean): string[];
        /**
         * Inherit instance data.
         * @param pInheritor Specifies the instance that inherits the data.
         */
        inherit(pInheritor: Instance): void;
    }
    export class Data extends Matrix<Values, TValuesEvents> {
        /**
         * Creates a new data instance.
         * @param pInstance Reference to the instance.
         * @param pOrchestrator Specifies the instance orchestrator.
         * @param fnUpdate Specifies the update handler.
         */
        constructor(pInstance: Instance, pOrchestrator: IInstanceOrchestrator, fnUpdate: (pEvent: IDataChangeEvent) => void);
        /** Retrieves all exportable values. */
        get exportables(): Values[];
        /** Retrieves if there are sealed values collected. */
        get hasSealedValues(): boolean;
        /**
         * Retrieve the values for the supplied slot.
         * @param pSlotOrId Reference to the slot, value or slot identifier.
         * @return Returns the values or `undefined` if no values are found.
         */
        forSlot<T extends TSerializeTypes, S extends Slot<T>>(
            pSlotOrId:
                | Slot
                | {
                      slot: Slot;
                  }
                | string
        ): Values<T, S> | undefined;
        /** Freeze the data. */
        freeze(): void;
        /** Unfreeze the data. */
        unfreeze(): void;
    }
    export type TInstanceEvents = "OnCreate" | "OnStart" | "OnEnd" | "OnPause" | "OnStop" | "OnFinish";
    export interface IInstanceEvent<T extends THooks> extends IHookPayload<T> {
        readonly instance: Instance;
    }
    export interface IInstanceCreateEvent extends IInstanceEvent<"OnCreate"> {}
    export interface IInstanceStartEvent extends IInstanceEvent<"OnStart"> {}
    export interface IInstancePauseEvent extends IInstanceEvent<"OnPause"> {}
    export interface IInstanceStopEvent extends IInstanceEvent<"OnStop"> {}
    export interface IInstanceEndEvent extends IInstanceEvent<"OnEnd"> {
        readonly type: "finished" | "stopped" | "paused";
    }
    export class Instance extends Item<TInstanceEvents> {
        /**
         * Constructs the instance.
         * @param pOrchestrator Specifies the instance orchestrator.
         * @param sThreading Specifies the threading model (`single` or `multi`).
         * @param pBootstrap Specifies the bootstrap state.
         * @param pSnapshot Specifies an optional snapshot to resume.
         * @param fnInitialize Specifies an optional initializer function that can be used to prefill the instance with data.
         */
        constructor(
            pOrchestrator: IInstanceOrchestrator,
            sThreading: TThreading,
            pBootstrap: State | undefined,
            pSnapshot?: IInstanceSnapshot,
            fnInitialize?: (pInstance: Instance) => void
        );

        /** Retrieves the instance identifier. */
        get id(): string;
        /** Retrieves the namespace identifier. */
        get l10n(): Namespace;
        /** Retrieves the unique ontology fingerprint. */
        get fingerprint(): string;
        /** Retrieves if the instance allows concurrency. */
        get allowConcurrency(): boolean;
        /** Retrieves if the preview mode is enabled. */
        get isPreview(): boolean;
        /** Retrieves if the instance is initialized. */
        get isInitialized(): boolean;
        /** Retrieves if the instance is running. */
        get isRunning(): boolean;
        /** Retrieves if the instance is stopped (interrupted). */
        get isStopped(): boolean;
        /** Retrieves if the instance is being paused. */
        get isPausing(): boolean;
        /** Retrieves if the instance is paused. */
        get isPaused(): boolean;
        /** Retrieves if the instance is at the start. */
        get isAtStart(): boolean;
        /** Retrieves if the instance is at the head. */
        get isAtHead(): boolean;
        /** Retrieves if the instance is at the finish. */
        get isAtFinish(): boolean;
        /** Retrieves if the instance is finishable using the `finish()` method. */
        get isFinishable(): boolean;
        /** Retrieves if the instance is finishing. */
        get isFinishing(): boolean;
        /** Retrieves if the instance has finished. */
        get isFinished(): boolean;
        /** Retrieves the finish reference. */
        get finishReference(): string;
        /** Retrieves if the instance has any data collected. */
        get hasDataCollected(): boolean;
        /** Retrieves the chain lookup object. */
        get lookup(): IChainLookup;
        /** Retrieves the data. */
        get data(): Data;
        /** Retrieves a history of all moments. */
        get history(): IMoment[];
        /** Retrieves the checksum. */
        get checksum(): string;
        /** Retrieves the present moment. */
        get presentMoment(): IMoment | undefined;
        /** Retrieves the instance snapshot. */
        get snapshot(): IInstanceSnapshot;
        /** Retrieves instance error information. */
        get errors(): number;

        /**
         * Opens a transaction that collects all value changes until `closeTransaction` is invoked.
         * @param pTransducer Specifies the transducer that serves as origin.
         * @param fnTransaction Specifies the function that is invoked.
         */
        createTransaction<T = void>(pTransducer: Transducer, fnTransaction: () => T): void | T;
        /**
         * Reads from the instance cache.
         * @param sKey Specifies the cache key.
         * @return Returns the value;
         */
        readFromCache<T>(sKey: string): T | undefined;
        /**
         * Writes a value to the instance cache.
         * @param sKey Specifies the cache key.
         * @param pValue Specifies the value to cache.
         * @return Returns the value.
         */
        writeToCache<T>(sKey: string, pValue: T): T;
        /**
         * Calculates the stencil hash for the specified type.
         * @param sType Specifies the stencil type (if omitted the exportables stencil is returned).
         * @returns Returns the stencil hash.
         */
        stencil(sType?: "exportables" | "actionables"): string;
        /**
         * Starts the instance.
         * @return Returns `true` if the instance is started.
         */
        start(): boolean;
        /** Restarts the instance. */
        restart(): void;
        /**
         * Stops the instance.
         * @return Returns `true` if the instance was running and is stopped.
         */
        stop(): boolean;
        /**
         * Pauses the instance.
         * @return Returns the instance snapshot necessary to resume the instance or undefined if the instance could not be paused.
         */
        pause(): IInstanceSnapshot | undefined;
        /**
         * Step forward in time.
         * @return Returns `true` if the step succeeded.
         */
        stepForward(): boolean;
        /**
         * Step backward in time.
         * @return Returns `true` if the step succeeded.
         */
        stepBackward(): boolean;
        /**
         * Step to the start.
         * @return Returns `true` if the step succeeded.
         */
        stepToStart(): boolean;
        /**
         * Step to the head of the history.
         * @return Returns `true` if the step succeeded.
         */
        stepToHead(): boolean;
        /**
         * Finish the instance when it is at the end and there are slots collected.
         * @return Returns a promise that resolves when the instance was finished.
         */
        finish(): Promise<void>;
        /**
         * Iterates through all possible transducers and their context.
         * @param fnTransducer Specifies a function that is invoked for each transducer.
         */
        transducers<T extends Transducer, C extends Condition>(
            fnTransducer: (pTransducer: T, pContext: C[], sContext: string) => void
        ): void;
        /** Retrieves if the specified transducer is in the present moment. */
        isTransducerPresent(pRef: Transducer): boolean;
        /**
         * Mark the transducers that are related to the slot as changed.
         * @param pSlot Reference to the slot.
         * @param bOwnerOnly Specifies if only the slot owner needs to be marked (defaults to `false`).
         */
        markAsChanged(pSlot: Slot, bOwnerOnly?: boolean): void;
        /**
         * Retrieves if the specified transducer has changed.
         * @param sId Specifies the transducer identifier.
         * @param bReset Specifies if the change flag needs to be reset.
         */
        hasChanged(sId: string, bReset?: boolean): boolean;
        /**
         * Inherits instance data.
         * @param pInstance Reference to the instance.
         * @returns Returns a reference to the instance.
         */
        inherit(pInstance: Instance): this;
    }
    export interface IVariable {
        /** Contains the identifier of the variable. */
        readonly id: string;
        /** Contains the value as a string. */
        readonly string: string;
        /** Contains the content for the variable. */
        readonly content: IContent[];
        /** Contains if a value is present. */
        readonly hasValue: boolean;
        /** Contains the value. */
        readonly value?: TSerializeTypes;
        /** Contains the value reference. */
        readonly reference?: string;
        /** Contains the display value. */
        readonly display?: string;
        /** Reference to the slot. */
        readonly slot?: Slot;
        /** Contains a list of slot references covered by the variable. */
        readonly refs: string[];
        /** Subscribe to variable changes. */
        readonly subscribe: (fnChange: (pVariable: IVariable) => void, pContext?: THookContext) => void;
        /** Unsubscribe a context from variable changes. */
        readonly unsubscribe: (pContext: THookContext) => void;
    }
    export interface IValueProxy {
        /** Contains the context of the proxy. */
        readonly context: string | undefined;
        /** Contains the value as a string. */
        readonly string: string;
        /** Contains the content for the variable. */
        readonly content: IContent[];
        /** Contains the value. */
        readonly value?: TSerializeTypes;
        /** Contains the value reference. */
        readonly reference?: string;
        /** Contains the display value. */
        readonly display?: string;
        /** Contains if a value is present. */
        readonly hasValue: boolean;
        /** Contains a list of slot references covered by the proxy. */
        readonly refs: string[];
        /** Updates the immutable value. */
        readonly update: (pValue: ImmutableValue) => void;
    }
    export class Context {
        /**
         * Creates a new context.
         * @param pStack Reference to the stack.
         * @param pChain Reference to the chain.
         */
        constructor(pStack: Stack, pChain: IChainLookup);
        /** Retrieves the instance of the context. */
        get instance(): Instance;
        /** Retrieves the l10n namespace */
        get l10n(): Namespace;
        /** Retrieves the context instance identifier. */
        get id(): number;
        /** Retrieves the context key. */
        get key(): string;
        /** Retrieves the index of the context. */
        get index(): number;

        /**
         * Retrieves the validation state of the supplied transducer.
         * @param pTransducer Specifies the transducer.
         * @return Returns the validation state.
         */
        validationOf(pTransducer: Transducer): "unknown" | "pass" | "fail";
        /**
         * Retrieves if this context is the mutable context of the supplied stack.
         * @param pStack Reference to the stack.
         * @return Returns `true` if the context is of the supplied stack.
         */
        isMutableContextOf(pStack: Stack): boolean;
        /**
         * Retrieves the mutable value for the supplied slot instance or identifier.
         * @param pSlotOrId Reference to the slot, value or slot identifier.
         * @return Returns the value or `undefined` if no value was found.
         */
        mutableValueOf<T extends TSerializeTypes, S extends Slot<T> = Slot<T>>(
            pSlotOrId:
                | Slot
                | {
                      slot: Slot;
                  }
                | string
        ): Value<T, S> | undefined;
        /**
         * Retrieves the immutable value for the supplied slot instance or identifier.
         * @param pSlotOrId Reference to the slot, value or slot identifier.
         * @return Returns the value or `undefined` if no value was found.
         */
        immutableValueOf<T extends TSerializeTypes, S extends Slot<T> = Slot<T>>(
            pSlotOrId:
                | Slot
                | {
                      slot: Slot;
                  }
                | string
        ): ImmutableValue<T, S> | undefined;
        /**
         * Retrieves the contextual value for the supplied slot instance or identifier.
         * @param pSlotOrId Reference to the slot, value or slot identifier.
         * @return Returns the value or `undefined` if no value was found.
         */
        contextualValueOf<T extends TSerializeTypes, S extends Slot<T> = Slot<T>>(
            pSlotOrId:
                | Slot
                | {
                      slot: Slot;
                  }
                | string
        ): Value<T, S> | undefined;
        /**
         * Generates a value proxy for the supplied slot instance.
         * @param pValues Reference to the value store.
         * @param pSlot Reference to the slot.
         * @param bPipe Specifies if the variable if part of a pipe.
         * @param sSeparator Specifies the value separator.
         * @param fnToString Optional function that is used to cast the variable to
         * a string.
         * @return Returns a proxy object.
         */
        proxyValueOf(
            pValues: Values,
            pSlot: Slot,
            bPipe: boolean,
            sSeparator: string,
            fnToString?: (pValue: ImmutableValue, pContext: Context) => string | undefined
        ): IValueProxy;
        /**
         * Retrieves the variable for the supplied slot instance or (pipe) identifier.
         * @param pSlotOrId Reference to the slot, value or slot identifier.
         * @param fnPipe Specifies the function used to retrieve the pipe identifier.
         * @param fnToString Optional function that is used to cast the variable to
         * a string.
         * @param finishReferenceIdentifier Specifies the identifier that retrieves
         * the finish reference.
         * @param sSeparator Specifies the separator used for multiple values in a pipe.
         * @param bPipe Specifies the variable is part of a pipe.
         * @return Returns the variable or `undefined` if the variable was not found,
         * not valid or not set.
         */
        variableFor(
            pSlotOrId:
                | Slot
                | {
                      slot: Slot;
                  }
                | string,
            fnPipe?: (pCondition: Condition, pContext: Context) => string | undefined,
            fnToString?: (pValue: ImmutableValue, pContext: Context) => string | undefined,
            finishReferenceIdentifier?: string,
            sSeparator?: string,
            bPipe?: boolean
        ): IVariable | undefined;
    }
    export abstract class Transducer<T extends ITransducer = ITransducer> extends Factory<Transducers, T, TTransducerEvents> {
        /** Contains the await pointer for the transducer. */
        await: Await | undefined;
        /**
         * Constructs a new transducer.
         * @param pTransducers Reference to the transducer dispatcher.
         * @param pTransducer Reference to the transducer data.
         */
        constructor(pTransducers: Transducers, pTransducer: T);
        /** Retrieves a reference to the transducers. */
        protected get transducers(): Transducers;
        /** Retrieves a reference to the parent state. */
        get state(): State;
        /** Retrieves a reference to the slots. */
        get slots(): Slots;
        /** Retrieves the transducer properties. */
        get props(): Readonly<T>;
        /**
         * Seal or unseal the values.
         * @param pContext Reference to the context.
         * @param bSeal Specifies if the values should be sealed.
         */
        seal(pContext: Context, bSeal: boolean): void;
        /**
         * Retrieves if the seal should be verified.
         * @param pContext Reference to the context.
         * @return Returns `true` if the seal needs verification.
         */
        shouldVerifySeal(pContext: Context): boolean;
        /**
         * Retrieves if one or more of the transducer slots are awaiting a value.
         * @param pContext Reference to the context.
         * @return Returns `true` if a slot is awaiting a value.
         */
        isAwaiting(pContext: Context): boolean;
        /**
         * Invoked when the VFSM wants to verify the condition for the transducer.
         * This event is invoked just before the transducer is entered.
         * @param pContext Reference to the context.
         * @param pCallback Reference to the callback pointer. Pass this pointer as
         * return value to enable the asynchronous condition callback.
         * @return Returns the result of the condition or the callback reference if
         * the condition should be handled asynchronously.
         * @event
         */
        abstract onEnterCondition(pContext: Context, pCallback: Callback<boolean>): boolean | Callback<boolean>;
        /**
         * Invoked when the transducer is entered.
         * @param pContext Reference to the context.
         * @param pAwait Reference to the await pointer. Pass this pointer as return
         * value to enable asynchronous validation.
         * @return Return the await pointer to implement asynchronous transducer validation.
         * @event
         */
        abstract onEnter(pContext: Context, pAwait: Await): void | Await;
        /**
         * Invoked when the transducer is skipped due to a failing enter condition.
         * @param pContext Reference to the context.
         * @event
         */
        onSkip(pContext: Context): void;
        /**
         * Invoked when the transducer is left.
         * @param pContext Reference to the context.
         * @event
         */
        onLeave(pContext: Context): void;
        /**
         * Invoked when the transducer is canceled.
         * @param pContext Reference to the context.
         * @event
         */
        onCancel(pContext: Context): void;
        /**
         * Invoked before the transducer is validated. Can be used to do data
         * sanitizing before validation occurs.
         * @param pContext Reference to the context.
         * @event
         */
        onBeforeValidate(pContext: Context): void;
        /**
         * Invoked when the transducer is validated.
         * @param pContext Reference to the context.
         * @param sCurrent Specifies the current transducer validation state.
         * @param pCallback Reference to the callback pointer. Pass this pointer as
         * return value to enable the asynchronous validation callback.
         * @return Returns the result of the validation or the callback reference if
         * the validation should be handled asynchronously.
         * @event
         */
        abstract onValidate(
            pContext: Context,
            sCurrent: "unknown" | "fail" | "pass",
            pCallback: Callback<boolean>
        ): boolean | Callback<boolean>;
        /**
         * Invoked when the transducer is validated.
         * @param pContext Reference to the context.
         * @param sResult Specifies the validation result.
         * @param sType Specifies the validation type.
         * @event
         */
        onValidated(pContext: Context, sResult: "fail" | "pass", sType: "initial" | "revalidate"): void;
        /**
         * Invoked when a side effect is generated.
         * @param pContext Reference to the context.
         * @param pTransducer Specifies the transducer that caused the side effect.
         * @event
         */
        onSideEffect(pContext: Context, pTransducer: Transducer): void;
    }
    export class Transducers extends StrictMatrix<Transducers, Transducer, void, ITransducer> {
        /**
         * Constructs a new transducer dispatcher.
         * @param pState Reference to the state.
         */
        constructor(pState: State);
        /** Retrieves a reference to the parent state. */
        get state(): State;
        /**
         * Creates a transducer.
         * @param pTransducer Reference to the transducer ontology.
         * @return Returns a reference to the transducer instance.
         */
        create<T extends Transducer>(pTransducer: ITransducer): T;
    }
    export abstract class State<T extends IState = IState> extends Factory<States, T, TStateEvents> {
        /** Contains the await pointer for the state. */
        await: Await | undefined;
        /**
         * Constructs a new state.
         * @param pStates Reference to the state dispatcher.
         * @param pState Specifies the state data.
         */
        constructor(pStates: States, pState: T);
        /** Retrieves a reference to the states. */
        get states(): States;
        /** Retrieves a reference to the ontology. */
        get ontology(): TOntology;
        /** Retrieves a reference to the transducer dispatcher. */
        get transducers(): Transducers;
        /** Retrieves a reference to the branch dispatcher. */
        get branches(): Branches;
        /** Retrieves if the state is the main state. */
        get isMain(): boolean;
        /** Retrieves the state properties. */
        get props(): Readonly<T>;
        /** Retrieves if the state is evaluating. */
        get isEvaluating(): boolean;
        /**
         * Contains the state enumerator. This is a chronological number for each
         * state. The first state has a enumerator value of `1` and the last state
         * equals the value of the `metrics.states` of a ontology instance. You can
         * use this property to calculate a simple progress indicator.
         */
        get enumerator(): number;
        /**
         * Prepares the instance.
         * @param pAncestor Reference to the ancestor.
         * @param pBranch Reference to the branch.
         * @param nEnumerator Specifies the enumerator value.
         */
        prepare(pAncestor: State, pBranch: Branch, nEnumerator?: number): State<T>;
        /**
         * Evaluates the state.
         * @param pReference Reference to the callback or promise.
         * @param pContext Reference to the context.
         */
        evaluate<C>(
            pReference: Callback<C> | ICallbackPromise<C>,
            pContext: Context,
            fnAssert: (pPromise: ICallbackPromise<C>) => boolean
        ): void;
        /**
         * Invoked when the VFSM wants to verify the enter condition for the state.
         * This event is invoked just before the state is entered and it is also
         * invoked for the main state. This allows you to use a condition for the
         * main state which lets you control the main application branch. If you
         * override this function you have to make sure to return an appropriate
         * value for the main state.
         * @param pContext Reference to the context.
         * @param pCallback Reference to the callback pointer. Pass this pointer as
         * return value to enable the asynchronous condition callback.
         * @return Returns the result of the condition or the callback reference if
         * the condition should be handled asynchronously.
         * @event
         */
        abstract onEnterCondition(pContext: Context, pCallback: Callback<boolean>): boolean | Callback<boolean>;
        /**
         * Invoked when state is entered.
         * @param pContext Reference to the context.
         * @param pAwait Reference to the await pointer. Pass this pointer as return
         * value to enable the asynchronous callback.
         * @return Returns the callback reference if the function should be handled
         * asynchronously.
         * @event
         */
        abstract onEnter(pContext: Context, pAwait: Await): void | Await;
        /**
         * Invoked when state is skipped due to a failing enter condition.
         * @param pContext Reference to the context.
         * @event
         */
        onSkip(pContext: Context): void;
        /**
         * Invoked when the VFSM wants to verify the leave condition for the state.
         * This event is invoked just before the state is left.
         * @param pContext Reference to the context.
         * @param pCallback Reference to the callback pointer. Pass this pointer as
         * return value to enable the asynchronous condition callback.
         * @return Returns the result of the condition or the callback reference if
         * the condition should be handled asynchronously.
         * @event
         */
        abstract onLeaveCondition(pContext: Context, pCallback: Callback<boolean>): boolean | Callback<boolean>;
        /**
         * Invoked when the state is left.
         * @param pContext Reference to the context.
         * @return Returns the callback reference if the function should be handled
         * asynchronously.
         * @event
         */
        onLeave(pContext: Context): void;
        /**
         * Invoked when the state cannot be left due to a failing leave condition.
         * @param pContext Reference to the context.
         * @param pAwait Reference to the await pointer. Pass this pointer as return
         * value to enable the asynchronous callback.
         * @event
         */
        onLeaveError(pContext: Context, pAwait: Await): void | Await;
        /**
         * Invoked when the state is canceled.
         * @param pContext Reference to the context.
         * @event
         */
        onCancel(pContext: Context): void;
        /**
         * Invoked when the state needs to be validated.
         * @param pContext Reference to the context.
         * @param sCurrent Specifies the current validation state.
         * @param pCallback Reference to the callback pointer. Pass this pointer as
         * return value to enable the asynchronous validation callback.
         * @return Returns the result of the validation or the callback reference if
         * the validation should be handled asynchronously.
         * @event
         */
        abstract onValidate(
            pContext: Context,
            sCurrent: "unknown" | "fail" | "pass",
            pCallback: Callback<boolean>
        ): boolean | Callback<boolean>;
        /**
         * Invoked when the state is validated.
         * @param pContext Reference to the context.
         * @param sResult Specifies the validation state.
         * @param sType Specifies if the validation type.
         * @event
         */
        onValidated(pContext: Context, sResult: "fail" | "pass", sType: "initial" | "revalidate"): void;
        /**
         * Invoked when the state starts or stops evaluating.
         * @param pContext Reference to the context.
         * @param bEvaluating Specifies if the state is evaluating.
         * @event
         */
        onEvaluate(pContext: Context, bEvaluating: boolean): void;
    }
    export class Branches extends StrictMatrix<Branches, Branch, void, IBranch> {
        /**
         * Constructs a new branch dispatcher.
         * @param pState Reference to the parent state.
         */
        constructor(pState: State);
        /** Retrieves a reference to the parent state. */
        get state(): State;
        /**
         * Creates a branch.
         * @param pBranch Reference to the branch ontology.
         * @param pAncestor Reference to the ancestor state.
         * @return Returns a reference to the branch instance.
         */
        create<T extends Branch>(pBranch: IBranch, pAncestor: State): T;
    }
    export abstract class Branch<T extends IBranch = IBranch> extends Factory<Branches, T, TBranchEvents> {
        /**
         * Constructs a new branch.
         * @param pBranches Reference to the branch dispatcher.
         * @param pBranch Reference to the branch data.
         */
        constructor(pBranches: Branches, pBranch: T);
        /** Retrieves a reference to the branches. */
        protected get branches(): Branches;
        /** Retrieves an array with states. */
        get states(): State[];
        /** Retrieves a reference to the parent state. */
        get state(): State;
        /** Retrieves a reference to the condition dispatcher. */
        get conditions(): Conditions;
        /** Retrieves the branch properties. */
        get props(): Readonly<T>;
        /** Retrieves the culling mode for the branch. */
        get culling(): TBranchCulling;
        /** Retrieves if this branch should spawn a new stack. */
        get spawn(): boolean;
        /** Retrieves if this is the main branch. */
        get isMain(): boolean;
        /** Retrieves if this branch is a finish. */
        get isFinish(): boolean;
        /**
         * Retrieves the entry state for the branch.
         * @param sMode Specifies the mode.
         * @return Returns the entry state.
         */
        entry(sMode: "live" | "preview"): State | undefined;
        /**
         * Invoked when the VFSM wants to verify the condition for the branch.
         * @param pContext Reference to the context.
         * @param pCallback Reference to the callback pointer. Pass this pointer as
         * return value to enable the asynchronous condition callback.
         * @return Returns the result of the condition or the callback reference if
         * the condition should be handled asynchronously.
         * @event
         */
        abstract onCondition(pContext: Context, pCallback: Callback<boolean>): boolean | Callback<boolean>;
        /**
         * Invoked when the branch is ready for entering. The condition is approved.
         * @param pContext Reference to the context.
         * @event
         */
        onReady(pContext: Context): void;
        /**
         * Invoked when the branch is entered.
         * @param pContext Reference to the context.
         * @event
         */
        onEnter(pContext: Context): void;
        /**
         * Invoked when the branch is skipped due to a failing enter condition.
         * @param pContext Reference to the context.
         * @event
         */
        onSkip(pContext: Context): void;
        /**
         * Invoked when the branch is left.
         * @param pContext Reference to the context.
         * @event
         */
        onLeave(pContext: Context): void;
        /**
         * Invoked when the branch is canceled.
         * @param pContext Reference to the context.
         * @event
         */
        onCancel(pContext: Context): void;
    }
    export class Conditions extends StrictMatrix<Conditions, Condition, void, ICondition> {
        /**
         * Constructs a new condition dispatcher.
         * @param Reference to the parent branch.
         */
        constructor(pBranch: Branch);
        /** Retrieves a reference to the parent branch. */
        get branch(): Branch;
        /**
         * Creates a condition.
         * @param pCondition Reference to the condition ontology.
         * @return Returns a reference to the condition instance or `undefined` if
         * a similar condition was already found.
         */
        create<T extends Condition>(pCondition: ICondition): T | undefined;
    }
    export type TTypes = TState | TTransducer | TBranch | TCondition;
    /**
     * Sets the property name for an ontology.
     * @param sProperty Specifies the property name.
     */
    export function ontology<T extends TTypes>(...sProperty: string[]): (pType: T) => void;
}
